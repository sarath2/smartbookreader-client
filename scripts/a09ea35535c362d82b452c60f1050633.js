// save us one ajax call that we will always have to make
// this can also be grabbed by navigating to /epub_content/metadata.json
window.ReadiumLibraryData = [
	{
		"fixed_layout":false,
		"open_to_spread":false,
		"cover_href":"/images/library/missing-cover-image.png",
		"created_at":"2012-03-27T19:22:01.521Z",
		"updated_at":"2012-03-27T19:23:38.309Z",
		"key":"1",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/1/EPUB/package.opf",
		"id":"code.google.com.epub-samples.linear-algebra",
		"epub_version":"3.0",
		"title":"A First Course in Linear Algebra",
		"author":"Robert A. Beezer",
		"publisher":"",
		"description":"",
		"rights":"This work is shared with the public using the GNU Free Documentation License, Version 1.2.",
		"language":"en",
		"pubdate":"",
		"modified_date":"2012-03-05T12:47:00Z",
		"layout":"",
		"spread":"",
		"orientation":"",
		"ncx":""
	},
	{
		"fixed_layout":false,
		"open_to_spread":false,
		"cover_href":"/epub_content/2/EPUB/images/portrait.jpg",
		"created_at":"2012-03-27T19:24:45.543Z",
		"updated_at":"2012-03-27T19:25:00.094Z",
		"key":"2",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/2/EPUB/cole.opf",
		"id":"code.google.com.epub-samples.cole-voyage-of-life",
		"epub_version":"3.0",
		"title":"Thomas Cole - The Voyage of Life",
		"author":"Jesse Dylan",
		"publisher":"",
		"description":"",
		"rights":"This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.",
		"language":"en-US",
		"pubdate":"",
		"modified_date":"2012-03-20T11:37:00Z",
		"layout":"",
		"spread":"",
		"orientation":"",
		"ncx":""
	},{
		"fixed_layout":false,
		"open_to_spread":false,
		"cover_href":"/epub_content/3/EPUB/wasteland-cover.jpg",
		"created_at":"2012-03-27T19:25:40.235Z",
		"updated_at":"2012-03-27T19:26:06.326Z",
		"key":"3",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/3/EPUB/wasteland.opf",
		"id":"code.google.com.epub-samples.wasteland-basic","epub_version":"3.0",
		"title":"The Waste Land","author":"T.S. Eliot",
		"publisher":"",
		"description":"",
		"rights":"This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"language":"en-US",
		"pubdate":"2011-09-01",
		"modified_date":"2012-01-18T12:47:00Z",
		"layout":"",
		"spread":"",
		"orientation":"",
		"ncx":"ncx"
	},{
		"fixed_layout":true,
		"open_to_spread":false,
		"cover_href":"/epub_content/4/EPUB/Image/cover.jpg",
		"created_at":"2012-03-28T18:24:18.450Z",
		"updated_at":"2012-03-28T18:25:32.553Z",
		"key":"4",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/4/EPUB/package.opf",
		"id":"urn:uuid:d5803940-647f-11e1-ad77-0002a5d5c51b",
		"epub_version":"3.0",
		"title":"Page Blanche","author":"Boulet",
		"publisher":"éditions Delcourt",
		"description":"",
		"rights":"This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"language":"fr",
		"pubdate":"2012-01-18",
		"modified_date":"2012-03-06T12:00:00Z",
		"layout":"pre-paginated",
		"spread":"auto",
		"orientation":"auto",
		"ncx":""
	}, {
		"author": "Mary Webb",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-04-10T21:47:53.353Z",
		"description": "",
		"epub_version": "2.0",
		"fixed_layout": false,
		"id": "urn:uuid:ADDB2B4D-BA43-4DE9-8BAB-CF8759C8F843",
		"key": "3921047c34132ab12338059f09bbf5c8",
		"language": "en-gb",
		"layout": "",
		"modified_date": "",
		"ncx": "ncx",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/5/OPS/content.opf",
		"pubdate": "2002",
		"publisher": "epubBooks (www.epubbooks.com)",
		"rights": "↵            Provided for free by epubBooks.com. Not for commercial use.↵            This EPUB eBook is released under a Creative Commons (BY-NC-ND/3.0) Licence.↵            Source text and images are in the Public Domain.↵      ",
		"spread": "",
		"src_url": "webb-precious-bane.epub",
		"title": "Precious Bane",
		"updated_at": "2012-04-10T21:48:57.267Z"
	}, {
		"apple_fixed": false,
		"author": "EPUB 3 Working Group",
		"cover_href": "/epub_content/epub30_spec/EPUB/img/epub_logo_color.jpg",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.epub30-spec",
		"key": "epub30_spec",
		"language": "en",
		"layout": "",
		"modified_date": "2012-02-27T16:38:35Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/epub30_spec/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "EPUB 3.0 Specification",
		"updated_at": "2012-06-15T00:06:37.334Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "http://www.aozora.gr.jp/cards/000148/card776.html",
		"key": "kusamakura",
		"language": "ja-jp",
		"layout": "",
		"modified_date": "2012-04-24T00:00:00Z",
		"ncx": "ncxtoc",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/kusamakura/OPS/package.opf",
		"page_prog_dir": "rtl",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "草枕",
		"updated_at": "2012-06-15T00:06:55.212Z"
	}, {
		"apple_fixed": false,
		"author": "Herman Melville",
		"cover_href": "/epub_content/moby_dick/OPS/images/9780316000000.jpg",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.moby-dick-basic",
		"key": "moby_dick",
		"language": "en-US",
		"layout": "",
		"modified_date": "2012-01-18T12:47:00Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/moby_dick/OPS/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "Harper & Brothers, Publishers",
		"rights": "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Moby-Dick",
		"updated_at": "2012-06-15T00:07:21.516Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/epub_content/trees/EPUB/cover.jpg",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "Test of canvas element and CSS3 multi-column layout",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.trees",
		"key": "trees",
		"language": "en",
		"layout": "",
		"modified_date": "2012-04-05T12:47:00Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/trees/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Trees",
		"updated_at": "2012-06-15T00:07:49.803Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-06-15T00:08:27.336Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": true,
		"id": "urn:uuid:A649F639-6C1F-1014-8CC3-F813564D7508",
		"key": "haruko",
		"language": "ja-jp",
		"layout": "pre-paginated",
		"modified_date": "2012-05-24T00:00:00Z",
		"ncx": "ncxtoc",
		"open_to_spread": false,
		"orientation": "portrait",
		"package_doc_path": "/epub_content/haruko/OPS/package.opf",
		"page_prog_dir": "rtl",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "landscape",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "ハルコさんの彼氏",
		"updated_at": "2012-06-15T00:08:36.776Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-06-15T00:08:27.336Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.hefty.water",
		"key": "hefty_water",
		"language": "en",
		"layout": "",
		"modified_date": "2012-03-29T12:00:00Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/hefty_water/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "2012-03-29",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Hefty Water",
		"updated_at": "2012-06-15T00:09:37.681Z"
	}, {
		"apple_fixed": false,
		"author": "Matt Garrish",
		"cover_href": "/epub_content/accessible_epub_3/EPUB/covers/9781449328030_lrg.jpg",
		"created_at": "2012-06-15T00:10:25.327Z",
		"current_margin": 1,
		"current_theme": "default-theme",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"font_size": 10,
		"id": "urn:isbn:9781449328030",
		"key": "accessible_epub_3",
		"language": "en",
		"layout": "",
		"modified_date": "2012-02-20T22:17:24Z",
		"ncx": "ncx",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/accessible_epub_3/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "2012",
		"publisher": "O’Reilly Media, Inc.",
		"rights": "Copyright © 2012 O’Reilly Media, Inc",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Accessible EPUB 3",
		"two_up": true,
		"updated_at": "2012-06-15T00:13:26.319Z"
	}, {
		"apple_fixed": false,
		"author": "Pr David Khayat",
		"cover_href": "/epub_content/regime_anticancer_arabic/EPUB/Image/cover.jpg",
		"created_at": "2012-06-15T00:11:17.450Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.regime-anticancer-arabic",
		"key": "regime_anticancer_arabic",
		"language": "ar",
		"layout": "",
		"modified_date": "2012-03-26T12:00:00Z",
		"ncx": "ncx",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/regime_anticancer_arabic/EPUB/package.opf",
		"page_prog_dir": "rtl",
		"paginate_backwards": false,
		"pubdate": "2012",
		"publisher": "Hachette Antoine",
		"rights": "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Le Vrai Régime anti-cancer",
		"updated_at": "2012-06-15T00:11:57.065Z"
	}
]
// This is the namespace and initialization code that is used by
// by the epub viewer of the chrome extension

window.Readium = {
	Models: {},
	Collections: {},
	Views: {},
	Routers: {},
	Utils: {},
	Init: function() {
		_router = new Readium.Routers.ViewerRouter();
		Backbone.history.start({pushState: true});
	}
};

$(function() {
	// call the initialization code when the dom is loaded
	window.Readium.Init();
});
Readium.HttpFileApi = function(initCallback) {
    var api = {
        readTextFile: function(path, readCallback, errorCallback) {
            $.ajax({
                //'cache' : false,
                'url' : path,
                'dataType' : 'text',
                'success' : function(data, textStatus, jqXHR) {
                    readCallback(data, jqXHR)
                },
                'error' : function(data, textStatus, jqXHR) {
                    errorCallback(data, textStatus, jqXHR)
                }
            })
        },

        getFsUri: function(path, successCallback, errorCallback) {
            successCallback(document.location.protocol + '//' + document.location.host + path)
        }
    }

    return function ( callback ) {
        callback(api);
        return api;
    }
}();

// patch in:
// TODO: Find a way to easily patch in
Readium.FileSystemApi = Readium.HttpFileApi
Readium.Utils.setCookie = function(c_name,value,exdays) {
	var exdate=new Date();
	exdate.setDate(exdate.getDate() + exdays);
	var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
	document.cookie=c_name + "=" + c_value;
}


Readium.Utils.getCookie = function(c_name) {
	var i, x, y, ARRcookies=document.cookie.split(";");
	for (i = 0; i < ARRcookies.length; i++) {
		x = ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
		y = ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
		x = x.replace(/^\s+|\s+$/g,"");
		if ( x == c_name ) {
			return unescape(y);
		}
	}
}

Readium.Utils.trimString = function(str) {
	return str.replace(/^\s+|\s+$/g, '');
}
/*
 * A sync for backbone based on html5 fs api
 */

BBFileSystemSync = function(method, model, options) {

	if(!model.file_path) {
		throw "Cannot sync the model to the fs without a path";
	}

	// this is a read only sync, no saving for now
	switch (method) {
        case "read":
            Readium.FileSystemApi(function(api) {
            	api.readTextFile(model.file_path, function(a,b) {
            		options.success(a);
            	}, function(e) {
            		options.error(e);
            	});
            });
            break;
        case "create":
            throw "Not yet implemented";
            break;
        case "update":
            throw "Not yet implemented";
            break;
        case "delete":
            throw "Not yet implemented";
            break;
    }

    return null;
	
}
// Description: This model is responsible for implementing the Alternate Style Tags specification
// found at http://idpf.org/epub/altss-tags/. The model selects a "preferred" style sheet or style set 
// with which to render an ePUB document. 
// 
// Notes: The convention in this model is to prepend the names of "private" methods with an underscore ('_')
//
// TODO: More validation for style sets with mixed rel="alternate ..." and rel="stylesheet"?
// TODO: Ensure that the "default" style set (the default in the ePub) is activated if no tags are supplied
 

Readium.Models.AlternateStyleTagSelector = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {},

	/* Description: Activate a style set based on a single, or set, of ePub alternate style tags
	 * Arguments (
	 *   altStyleTags: An array of ePUB alternate style tags
	 *   bookDom: An epub document object
	 * )
	 */
	activateAlternateStyleSet: function(altStyleTags, bookDom) {

		var $bookStyleSheets;
		var styleSetTitles = [];
		var that = this;
		var styleSetToActivate;

		// If there are no alternate tags supplied, do not change the style sets
		if (altStyleTags.length === 0) {

			return bookDom;
		}

		// Get all style sheets in the book dom
		$bookStyleSheets = $("link[rel*='stylesheet']", bookDom);

		// If the book does not have any stylesheets, do not change style sets
		if ($bookStyleSheets.length === 0) {

			return bookDom;
		}

		// Maintain original information about stylesheets
		$bookStyleSheets = this._storeOriginalAttributes($bookStyleSheets);

		// Get a list of the unique style set titles 
		styleSetTitles = this._getStyleSetTitles($bookStyleSheets);

		// Determine which style set should be activated
		styleSetToActivate = this._getStyleSetTitleToActivate($bookStyleSheets, styleSetTitles, altStyleTags);

		// If no style was found to activate, based on the supplied tags, do not change the style sets
		if (styleSetToActivate === null) {

			return bookDom;
		}

		// Activate the specified style set, de-activing all others
		this._activateStyleSet($bookStyleSheets, styleSetToActivate);

		return bookDom;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	/* Description: Activate the specified style set and de-activate all others
	 * Design rationale: The disabled property is used to activate/de-activate the style sheets, as opposed to changing 
	 * attribute values, as this ensures that the document is re-rendered
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 *   styleSetToActivate: The attribute value for the "title" property of the style set to activate
	 * )
	 */
	_activateStyleSet: function (bookStyleSheets, styleSetToActivate) {

		bookStyleSheets.each(function () {

			$styleSheet = $(this);

			// The stylesheets must all be set as preferred so that when enabled, they will be activated
			$styleSheet.attr("rel", "stylesheet");
			// Always leave persistent style sets activated
			if ($styleSheet.attr('title') === undefined) {

				$styleSheet[0].disabled = false;
			}
			// Activate this style set
			else if ($.trim($styleSheet.attr('title')) === styleSetToActivate) {

				// Chrome is buggy and change to disabled = false is only
				// picked up if you first set it to true
				$styleSheet[0].disabled = true;
				$styleSheet[0].disabled = false;
			}
			// De-activate other style sets
			else {

				$styleSheet[0].disabled = true;
			}
		});

		return bookStyleSheets;
	},

	/* Description: Creates data attributes to store the original stylesheet attribute values
	 * Design rationale: The "rel" attribute must be modified in other methods but we need to "remember" 
	 * the author's original style sheet specification
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 * )
	 */
	_storeOriginalAttributes: function(bookStyleSheets) {

		var $styleSheet;

		// For each style sheet, if the original value attributes are empty, set them
		bookStyleSheets.each(function() {

			$styleSheet = $(this);

			if ($styleSheet.data('orig-rel') === undefined) {

				$styleSheet.attr('data-orig-rel', $styleSheet.attr("rel"));
			}
		});

		return bookStyleSheets;
	},

	/* Description: Finds the title of the style set to activate using HTML preference rules for style sheets, as well as ePub 
	 * alternate style tags.
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets 
	 *   styleSetTitles: An array of the unique style set titles for the ePub
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 * Error handling: Returns null if not title is found
	 */
	_getStyleSetTitleToActivate: function (bookStyleSheets, styleSetTitles, altStyleTags) {

		var styleSetTagMatches = [];
		var styleSetNum;
		var $styleSet;
		var maxNumTagMatches;
		var styleSetCandidates = [];

		// Find the style set with the most matching alternate tags, removing mututally exclusive tags
		for (styleSetNum = 0; styleSetNum < styleSetTitles.length; styleSetNum += 1) {

			$styleSet = bookStyleSheets.filter("link[title='" + styleSetTitles[styleSetNum] + "']");
			$styleSet = this._removeMutuallyExclusiveAltTags($styleSet);
			styleSetTagMatches.push(
				{ "numAltTagMatches" : this._getNumAltStyleTagMatches($styleSet, altStyleTags),
				  "styleSetTitle" : styleSetTitles[styleSetNum] }
			);
		}

		// Get a list of the style sets with the maximum number of tag matches
		// _.max returns one of the info elements with a maximum value, which is why the numAltTagMatches property is used to retrieve the actual max value
		maxNumTagMatches = (_.max(styleSetTagMatches, function (styleSetTagMatchInfo) { return styleSetTagMatchInfo.numAltTagMatches } )).numAltTagMatches;

		// Do nothing if there are no matching tags
		if (maxNumTagMatches === 0) {

			return null;
		}

		// Get a list of the style sets that had the maximum number of alternate tag matches
		_.each(styleSetTagMatches, function(styleSetTagMatchInfo) {

			if (styleSetTagMatchInfo['numAltTagMatches'] === maxNumTagMatches) {

				styleSetCandidates.push(styleSetTagMatchInfo["styleSetTitle"]);
			}
		});

		// If there is only one style set in the candidate list
		if (styleSetCandidates === 1) {

			return styleSetCandidates[0];
		}
		// Since there are multiple candidates, return the style set that is preferred (the first style set with rel="stylesheet")
		else {

			var candidateNum;
			for (candidateNum = 0; candidateNum < styleSetCandidates.length; candidateNum++) {

				// TODO: This assumes that all the style sheets in the style set are marked as either preferred or alternate. It simply checks the first 
				// style sheet of every style set.
				$styleSet = bookStyleSheets.filter("link[title='" + styleSetCandidates[candidateNum] + "']");
				if ($.trim($($styleSet[0]).attr("data-orig-rel")) === "stylesheet") {

					return styleSetCandidates[candidateNum];
				}
			}

			// If none of the stylesheets were preferred (only rel="alternate stylesheet"), return the first style set title
			return styleSetCandidates[0];
		}
	},

	/* Description: Finds the unique list of style set titles from the set of style sheets for the ePub
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePub's style sheets 
	 * )
	 */
	_getStyleSetTitles: function (bookStyleSheets) {

		var styleSetTitles = [];

		// Find the unique style sets from the 'title' property
		bookStyleSheets.each(function() {

			var styleSheetTitle = $(this).attr("title");
			if (!_.include(styleSetTitles, styleSheetTitle)) {

				styleSetTitles.push(styleSheetTitle);
			}
		});

		return styleSetTitles;
	},

	/* Description: Finds the number of alternate style tags in a style set's class attribute
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 */
	_getNumAltStyleTagMatches: function (styleSet, altStyleTags) {

		var numMatches = 0;

		// If the alt style tag is found in the style set, increment num matches
		var altTagNum;
		for (altTagNum = 0; altTagNum < altStyleTags.length; altTagNum += 1) {

			// filter used so top-level elements are selected
			if (styleSet.filter("link[class*='" + altStyleTags[altTagNum] + "']").length > 0) {

				numMatches++;	
			}
		}

		return numMatches;
	},

	// 
	/* Description: This method removes, thus ignoring, mututally exclusive alternate tags within a style set
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 * )
	 */
	//TODO: Maybe change this to act on data- attributes, rather than the actual class attribute
	_removeMutuallyExclusiveAltTags: function (styleSet) {

		var $styleSheet;

		if (styleSet.filter("link[class*='night']").length > 0 &&
		    styleSet.filter("link[class*='day']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.night').length > 0) {

					$styleSheet.toggleClass('night');
				}

				if ($styleSheet.filter('.day').length > 0) {

					$styleSheet.toggleClass('day');
				}
			});
		}

		if (styleSet.filter("link[class*='vertical']").length > 0 &&
			styleSet.filter("link[class*='horizontal']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.vertical').length > 0) {
					
					$styleSheet.toggleClass('vertical');
				}

				if ($styleSheet.filter('.horizontal').length > 0) {

					$styleSheet.toggleClass('horizontal');
				}
			});
		}

		return styleSet;
	}
});

// based on http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
Readium.Utils.Guid = function() {
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    	var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
    	return v.toString(16);
	});
};

// roughly based on http://documentcloud.github.com/backbone/docs/backbone-localstorage.html
Readium.Utils.LocalStorageAdaptor = function(storeName) {

	var _data;

	var save = function() {
		localStorage.setItem(storeName, JSON.stringify(_data));
	};

	var create = function(model) {
		if (!model.id) model.id = model.attributes.id = guid();
		_data[model.id] = model;
		save();
		return model;
	};

	var update = function(model) {
		_data[model.id] = model;
		save();
		return model;
	};

	var find = function(model) {
		return _data[model.id];
	};

	var findAll = function() {
		return _.values(_data);
	};


	var destroy = function(model) {
		delete _data[model.id];
		save();
		return model;
	};

	return function(method, model, options) {

		var resp;
		var strData = localStorage.getItem(storeName);
		_data = ( strData && JSON.parse(strData)) || {};

		switch (method) {
			case "read":    resp = model.id ? find(model) : findAll(); break;
			case "create":  resp = create(model);                            break;
			case "update":  resp = update(model);                            break;
			case "delete":  resp = destroy(model);                           break;
		}

		if (resp) {
			if(options.success) {
				options.success(resp);
			}
		} else {
			if(options.error) {
				options.error("Record not found");	
			}
		}
	};

};
// Description: This model is responsible for implementing the Alternate Style Tags specification
// found at http://idpf.org/epub/altss-tags/. The model selects a "preferred" style sheet or style set 
// with which to render an ePUB document. 
// 
// Notes: The convention in this model is to prepend the names of "private" methods with an underscore ('_')
//
// TODO: More validation for style sets with mixed rel="alternate ..." and rel="stylesheet"?
// TODO: Ensure that the "default" style set (the default in the ePub) is activated if no tags are supplied
 

Readium.Models.AlternateStyleTagSelector = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {},

	/* Description: Activate a style set based on a single, or set, of ePub alternate style tags
	 * Arguments (
	 *   altStyleTags: An array of ePUB alternate style tags
	 *   bookDom: An epub document object
	 * )
	 */
	activateAlternateStyleSet: function(altStyleTags, bookDom) {

		var $bookStyleSheets;
		var styleSetTitles = [];
		var that = this;
		var styleSetToActivate;

		// If there are no alternate tags supplied, do not change the style sets
		if (altStyleTags.length === 0) {

			return bookDom;
		}

		// Get all style sheets in the book dom
		$bookStyleSheets = $("link[rel*='stylesheet']", bookDom);

		// If the book does not have any stylesheets, do not change style sets
		if ($bookStyleSheets.length === 0) {

			return bookDom;
		}

		// Maintain original information about stylesheets
		$bookStyleSheets = this._storeOriginalAttributes($bookStyleSheets);

		// Get a list of the unique style set titles 
		styleSetTitles = this._getStyleSetTitles($bookStyleSheets);

		// Determine which style set should be activated
		styleSetToActivate = this._getStyleSetTitleToActivate($bookStyleSheets, styleSetTitles, altStyleTags);

		// If no style was found to activate, based on the supplied tags, do not change the style sets
		if (styleSetToActivate === null) {

			return bookDom;
		}

		// Activate the specified style set, de-activing all others
		this._activateStyleSet($bookStyleSheets, styleSetToActivate);

		return bookDom;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	/* Description: Activate the specified style set and de-activate all others
	 * Design rationale: The disabled property is used to activate/de-activate the style sheets, as opposed to changing 
	 * attribute values, as this ensures that the document is re-rendered
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 *   styleSetToActivate: The attribute value for the "title" property of the style set to activate
	 * )
	 */
	_activateStyleSet: function (bookStyleSheets, styleSetToActivate) {

		bookStyleSheets.each(function () {

			$styleSheet = $(this);

			// The stylesheets must all be set as preferred so that when enabled, they will be activated
			$styleSheet.attr("rel", "stylesheet");
			// Always leave persistent style sets activated
			if ($styleSheet.attr('title') === undefined) {

				$styleSheet[0].disabled = false;
			}
			// Activate this style set
			else if ($.trim($styleSheet.attr('title')) === styleSetToActivate) {

				// Chrome is buggy and change to disabled = false is only
				// picked up if you first set it to true
				$styleSheet[0].disabled = true;
				$styleSheet[0].disabled = false;
			}
			// De-activate other style sets
			else {

				$styleSheet[0].disabled = true;
			}
		});

		return bookStyleSheets;
	},

	/* Description: Creates data attributes to store the original stylesheet attribute values
	 * Design rationale: The "rel" attribute must be modified in other methods but we need to "remember" 
	 * the author's original style sheet specification
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 * )
	 */
	_storeOriginalAttributes: function(bookStyleSheets) {

		var $styleSheet;

		// For each style sheet, if the original value attributes are empty, set them
		bookStyleSheets.each(function() {

			$styleSheet = $(this);

			if ($styleSheet.data('orig-rel') === undefined) {

				$styleSheet.attr('data-orig-rel', $styleSheet.attr("rel"));
			}
		});

		return bookStyleSheets;
	},

	/* Description: Finds the title of the style set to activate using HTML preference rules for style sheets, as well as ePub 
	 * alternate style tags.
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets 
	 *   styleSetTitles: An array of the unique style set titles for the ePub
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 * Error handling: Returns null if not title is found
	 */
	_getStyleSetTitleToActivate: function (bookStyleSheets, styleSetTitles, altStyleTags) {

		var styleSetTagMatches = [];
		var styleSetNum;
		var $styleSet;
		var maxNumTagMatches;
		var styleSetCandidates = [];

		// Find the style set with the most matching alternate tags, removing mututally exclusive tags
		for (styleSetNum = 0; styleSetNum < styleSetTitles.length; styleSetNum += 1) {

			$styleSet = bookStyleSheets.filter("link[title='" + styleSetTitles[styleSetNum] + "']");
			$styleSet = this._removeMutuallyExclusiveAltTags($styleSet);
			styleSetTagMatches.push(
				{ "numAltTagMatches" : this._getNumAltStyleTagMatches($styleSet, altStyleTags),
				  "styleSetTitle" : styleSetTitles[styleSetNum] }
			);
		}

		// Get a list of the style sets with the maximum number of tag matches
		// _.max returns one of the info elements with a maximum value, which is why the numAltTagMatches property is used to retrieve the actual max value
		maxNumTagMatches = (_.max(styleSetTagMatches, function (styleSetTagMatchInfo) { return styleSetTagMatchInfo.numAltTagMatches } )).numAltTagMatches;

		// Do nothing if there are no matching tags
		if (maxNumTagMatches === 0) {

			return null;
		}

		// Get a list of the style sets that had the maximum number of alternate tag matches
		_.each(styleSetTagMatches, function(styleSetTagMatchInfo) {

			if (styleSetTagMatchInfo['numAltTagMatches'] === maxNumTagMatches) {

				styleSetCandidates.push(styleSetTagMatchInfo["styleSetTitle"]);
			}
		});

		// If there is only one style set in the candidate list
		if (styleSetCandidates === 1) {

			return styleSetCandidates[0];
		}
		// Since there are multiple candidates, return the style set that is preferred (the first style set with rel="stylesheet")
		else {

			var candidateNum;
			for (candidateNum = 0; candidateNum < styleSetCandidates.length; candidateNum++) {

				// TODO: This assumes that all the style sheets in the style set are marked as either preferred or alternate. It simply checks the first 
				// style sheet of every style set.
				$styleSet = bookStyleSheets.filter("link[title='" + styleSetCandidates[candidateNum] + "']");
				if ($.trim($($styleSet[0]).attr("data-orig-rel")) === "stylesheet") {

					return styleSetCandidates[candidateNum];
				}
			}

			// If none of the stylesheets were preferred (only rel="alternate stylesheet"), return the first style set title
			return styleSetCandidates[0];
		}
	},

	/* Description: Finds the unique list of style set titles from the set of style sheets for the ePub
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePub's style sheets 
	 * )
	 */
	_getStyleSetTitles: function (bookStyleSheets) {

		var styleSetTitles = [];

		// Find the unique style sets from the 'title' property
		bookStyleSheets.each(function() {

			var styleSheetTitle = $(this).attr("title");
			if (!_.include(styleSetTitles, styleSheetTitle)) {

				styleSetTitles.push(styleSheetTitle);
			}
		});

		return styleSetTitles;
	},

	/* Description: Finds the number of alternate style tags in a style set's class attribute
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 */
	_getNumAltStyleTagMatches: function (styleSet, altStyleTags) {

		var numMatches = 0;

		// If the alt style tag is found in the style set, increment num matches
		var altTagNum;
		for (altTagNum = 0; altTagNum < altStyleTags.length; altTagNum += 1) {

			// filter used so top-level elements are selected
			if (styleSet.filter("link[class*='" + altStyleTags[altTagNum] + "']").length > 0) {

				numMatches++;	
			}
		}

		return numMatches;
	},

	// 
	/* Description: This method removes, thus ignoring, mututally exclusive alternate tags within a style set
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 * )
	 */
	//TODO: Maybe change this to act on data- attributes, rather than the actual class attribute
	_removeMutuallyExclusiveAltTags: function (styleSet) {

		var $styleSheet;

		if (styleSet.filter("link[class*='night']").length > 0 &&
		    styleSet.filter("link[class*='day']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.night').length > 0) {

					$styleSheet.toggleClass('night');
				}

				if ($styleSheet.filter('.day').length > 0) {

					$styleSheet.toggleClass('day');
				}
			});
		}

		if (styleSet.filter("link[class*='vertical']").length > 0 &&
			styleSet.filter("link[class*='horizontal']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.vertical').length > 0) {
					
					$styleSheet.toggleClass('vertical');
				}

				if ($styleSheet.filter('.horizontal').length > 0) {

					$styleSheet.toggleClass('horizontal');
				}
			});
		}

		return styleSet;
	}
});

Readium.Models.ManifestItem = Backbone.Model.extend({
	
	parseMetaTags: function() {
		 var pageSize;
		// only need to go through this one time, so only parse it
		// if it is not already known
		if(typeof this.get("meta_width") !== "undefined") {
			return;
		}

		if(this.isSvg()) {
			pageSize = this.parseViewboxTag();
		}
		else if(!this.isImage()) {
			pageSize = this.parseViewportTag();
		}

		if(pageSize) {
			this.set({"meta_width": pageSize.width, "meta_height": pageSize.height});
		}
	},

	getContentDom: function() {
		var content = this.get('content');
		if(content) {
			var parser = new window.DOMParser();
			return parser.parseFromString(content, 'text/xml');
		}
	},

	// for fixed layout xhtml we need to parse the meta viewport
	// tag to determine the size of the pages. more info in the 
	// [fixed layout spec](http://idpf.org/epub/fxl/#dimensions-xhtml-svg)
	parseViewportTag: function() {
		var dom = this.getContentDom();
		if(!dom) {
			return;
		}
		var viewportTag = dom.getElementsByName("viewport")[0];
		if(!viewportTag) {
			return null;
		}
		// this is going to be ugly
		var str = viewportTag.getAttribute('content');
		str = str.replace(/\s/g, '');
		var valuePairs = str.split(',');
		var values = {};
		var pair;
		for(var i = 0; i < valuePairs.length; i++) {
			pair = valuePairs[i].split('=');
			if(pair.length === 2) {
				values[ pair[0] ] = pair[1];
			}
		}
		values['width'] = parseFloat(values['width'], 10);
		values['height'] = parseFloat(values['height'], 10);
		return values;
	},

	// for fixed layout svg we need to parse the viewbox on the svg
	// root tag to determine the size of the pages. more info in the 
	// [fixed layout spec](http://idpf.org/epub/fxl/#dimensions-xhtml-svg)
	parseViewboxTag: function() {

		// The value of the ‘viewBox’ attribute is a list of four numbers 
		// `<min-x>`, `<min-y>`, `<width>` and `<height>`, separated by 
		// whitespace and/or a comma
		var dom = this.getContentDom();
		if(!dom) {
			return;
		}
		var viewboxString = dom.documentElement.getAttribute("viewBox");
		// split on whitespace and/or comma
		var valuesArray = viewboxString.split(/,?\s+|,/);
		var values = {};
		values['width'] = parseFloat(valuesArray[2], 10);
		values['height'] = parseFloat(valuesArray[3], 10);
		return values;

	},

	resolvePath: function(path) {
		return this.collection.packageDocument.resolvePath(path)
	},

	resolveUri: function(path) {
		return this.collection.packageDocument.resolveUri(path)	
	},

	isSvg: function() {
		return this.get("media_type") === "image/svg+xml";
	},

	isImage: function() {
		var media_type = this.get("media_type");

		if(media_type && media_type.indexOf("image/") > -1) {
			// we want to treat svg as a special case, so they
			// are not images
			return media_type !== "image/svg+xml";
		}
		return false;
	},

	// Load this content from the filesystem
	loadContent: function() {
		var that = this;
		var path = this.resolvePath(this.get("href"));
		
		Readium.FileSystemApi(function(api) {
			api.readTextFile(path, function(result) {
				that.set( {content: result} );
			}, function() {
				console.log("Failed to load file: " + path);
			})
		});
	}
	
});

Readium.Models.SpineItem = Readium.Models.ManifestItem.extend({

	initialize: function() {
		if(this.isFixedLayout()) {
			this.on("change:content", this.parseMetaTags, this);
			this.loadContent();
		}
		
	},

	// this method creates the JSON representation of a manifest item
	// that is used to render out a page view.
	buildSectionJSON: function(manifest_item, spine_index) {
		if(!manifest_item) {
			return null;
		}
		var section = Object.create(null);
		section.width = this.get("meta_width") || 0;
		section.height = this.get("meta_height") || 0;
		section.uri = this.packageDocument.resolveUri(manifest_item.get('href'));
		section.page_class = this.getPageSpreadClass(manifest_item, spine_index);
		return section;
	},

	toJSON: function() {
		if(this.isFixedLayout()) {
			this.parseMetaTags();
		}
		var json = {};
		json.width = this.get("meta_width") || 0;
		json.height = this.get("meta_height") || 0;
		json.uri = this.resolveUri(this.get('href'));
		json.page_class = this.getPageSpreadClass();
		return json;
	},

	// when rendering fixed layout pages we need to determine whether the page
	// should be on the left or the right in two up mode, options are:
	// 	left_page: 		render on the left side
	//	right_page: 	render on the right side
	//	center_page: 	always center the page horizontally
	// REFACTORING CANDIDATE: This method is too long. 
	getPageSpreadClass: function() {
		var book = this.collection.packageDocument.get("book");
		var spine_index = this.get("spine_index");
		var pageSpreadProperty;
		var spineItems = this.collection;
		var numPagesBetween;
		var lastSpecifiedPageSpread;

		if(book.get("apple_fixed")) {
			// the logic for apple fixed layout is a little different:
			/*
			if(!book.get("open_to_spread")) {
				// page spread is disabled for this book
				return	"center_page"
			}
			else if(spine_index === 0) {
				*/
			if(spine_index === 0) {
				// for ibooks, odd pages go on the right. This means
				// the first page (0th index) will always be on the right
				// without a left counterpart, so center it
				return "center_page";
			}
			else if (spine_index % 2 === 1 && 
				spine_index === this.collection.length) {

				// if the last spine item in the book would be on the left, then
				// it would have no left counterpart, so center it
				return "center_page";
			}
			else {
				// otherwise first page goes on the right, and then alternate
				// left - right - left - right etc
				return (spine_index % 2 === 0 ? "right_page" : "left_page");
			}
		}
		else {

			// If the page spread property has been set for this spine item, return 
			// the name of the appropriate spread class. 
			// Note: As there are only three valid values (left, right, center) for the page
			// spread property in ePub 3.0, if the property is set and 
			// it is not "left" or "right, "center" will always be assumed. 
			if (this.get("page_spread")) {

				pageSpreadProperty = this.get("page_spread");
				if (pageSpreadProperty === "left") {

					return "left_page";
				}
				else if (pageSpreadProperty === "right") {

					return "right_page";
				}
				else {
					return "center_page";
				}
			}
			// If the page spread property is not set, we must iterate back through the EPUB's spine items to find 
			//   the last spine item with a page-spread value set. We can use that value, whether there are an even or odd
			//   number of pages between this spine item and the "last" one, and the page progression direction of the EPUB
			//   to determine the appropriate page spread value for this spine item. 
			// REFACTORING CANDIDATE: WAY too much nesting here. This should be moved to it's own method, at the least.
			else {

				// If this is the first spine item, assign left or right based on page progression direction
				if (spine_index === 0) {

					return book.get("page_prog_dir") === "rtl" ? "right_page" : "left_page";
				}
				else {

					// Find last spine item with page-spread value and use it to determine the appropriate value for 
					//   this spine item.
					for (var currSpineIndex = spine_index - 1; currSpineIndex >= 0; currSpineIndex--) {

						// REFACTORING CANDIDATE: This would be clearer if the currSpineIndex === 0 case was 
						//   handled seperately. 
						if (currSpineIndex === 0 || spineItems.at(currSpineIndex).get("page_spread")) {

							// Handles the case where currSpineIndex === 0 and a page-spread value has not been specified
							lastSpecifiedPageSpread = 
								spineItems.at(currSpineIndex).get("page_spread") ? spineItems.at(currSpineIndex).get("page_spread") : 
								book.get("page_prog_dir") === "rtl" ? "right" : "left";

							numPagesBetween = spine_index - currSpineIndex;

							if (numPagesBetween % 2 === 0) {

								return lastSpecifiedPageSpread === "left" ? "left_page" : 
									lastSpecifiedPageSpread === "right" ? "right_page" :
									book.get("page_prog_dir") === "rtl" ? "left_page" : "right_page";
							}
							// Odd number of pages between current and last spine item with a specified page-spread value
							else {

								return lastSpecifiedPageSpread === "left" ? "right_page" :
									lastSpecifiedPageSpread === "right" ? "left_page" :
									book.get("page_prog_dir") === "rtl" ? "right_page" : "left_page";
							}
						}
					}
				}
			}
		}
	},

	isFixedLayout: function() {

		// if it an svg or image then it is fixed layout
		if(this.isSvg() || this.isImage()) {
			return true;
		}

		// if there is a fixed_flow property, then it takes precedence
		if(typeof this.get("fixed_flow") !== 'undefined') {
			return this.get('fixed_flow');
		}

		// nothing special about this spine item, fall back to the books settings
		return this.collection.isBookFixedLayout();
	},

	// Description: Determines if the first page of the content document should be offset in a synthetic layout
	firstPageOffset : function () {

		// Get book properties
		var notFixedLayout = !this.isFixedLayout();
		var pageProgDirIsRTL = this.get("page_prog_dir") === "rtl" ? true : false;
		var pageSpreadLeft = this.get("page_spread") === "left" ? true : false;
		var pageSpreadRight = this.get("page_spread") === "right" ? true : false;

		// Default to no page spread specified if they are both set on the spine item
		if (pageSpreadRight && pageSpreadLeft) {
			pageSpreadRight = false;
			pageSpreadLeft = false;
		}

		if (notFixedLayout) {

			if (pageProgDirIsRTL) {

				if (pageSpreadLeft) {
					return true;
				}
			}
			else {

				if (pageSpreadRight) {
					return true;
				}
			}
		}

		return false;
	},

	// REFACTORING CANDIDATE: caching the the fixed layout views. I do not remember the reason that
	// we are doing this. Possible that it is not necessary...
	getPageView: function() {
		if(!this.view) {
			if(this.isImage()) {
				this.view = new Readium.Views.ImagePageView({model: this});
			}
			else {
				this.view = new Readium.Views.FixedPageView({model: this});	
			}
			
		}
		return this.view;
	},
    
    hasMediaOverlay: function() {
        return !!this.get("media_overlay") && !!this.getMediaOverlay();
    },
    
    getMediaOverlay: function() {
		return this.collection.getMediaOverlay(this.get("media_overlay"));
    }
});



Readium.Collections.ManifestItems = Backbone.Collection.extend({
	model: Readium.Models.ManifestItem,

	initialize: function(models, options) {
		this.packageDocument = options.packageDocument;   
    }
});

Readium.Collections.Spine = Backbone.Collection.extend({
	model: Readium.Models.SpineItem,

	initialize: function(models, options) {
		this.packageDocument = options.packageDocument;
	},

	isBookFixedLayout: function() {
		return this.packageDocument.get("book").isFixedLayout();
	},

	getMediaOverlay: function(id) {
        return this.packageDocument.getMediaOverlayItem(id);
    }
});
// `PackageDocumentParser` are used to parse the xml of an epub package
// document and build a javascript object. The constructor accepts an
// instance of `URI` that is used to resolve paths durring the process
Readium.Models.PackageDocumentParser = function(uri_object) {
	this.uri_obj = uri_object;
};

// We use [Jath](https://github.com/dnewcome/jath) for converting xml into
// JSON in a declaritive manner. This is the template that performs that
// conversion
Readium.Models.PackageDocumentParser.JathTemplate = {

	metadata:  { 
		id: "//def:metadata/dc:identifier",
		epub_version: "//def:package/@version",
		title: "//def:metadata/dc:title",
		author: "//def:metadata/dc:creator",
		publisher: "//def:metadata/dc:publisher",
		description: "//def:metadata/dc:description",
		rights: "//def:metadata/dc:rights",
		language: "//def:metadata/dc:language",
		pubdate: "//def:metadata/dc:date",
		modified_date: "//def:metadata/def:meta[@property='dcterms:modified']",
		layout: "//def:metadata/def:meta[@property='rendition:layout']",
		spread: "//def:metadata/def:meta[@property='rendition:spread']",
		orientation: "//def:metadata/def:meta[@property='rendition:orientation']",
		ncx: "//def:spine/@toc",
		page_prog_dir: "//def:spine/@page-progression-direction",
		active_class: "//def:metadata/def:meta[@property='media:active-class']"
	 },

	manifest: [ "//def:item", { 
		id: "@id",
		href: "@href",
		media_type: "@media-type",
		properties: "@properties",
        media_overlay: "@media-overlay"
	} ],
						 
	spine: [ "//def:itemref", { idref: "@idref", properties: "@properties", linear: "@linear" } ],

	bindings: ["//def:bindings/def:mediaType", { 
		handler: "@handler",
		media_type: "@media-type"
	} ]
	
};

// Parse an XML package document into a javascript object
Readium.Models.PackageDocumentParser.prototype.parse = function(xml_content) {

	var json, manifest, cover, xmlDom;
	if(typeof(xml_content) === "string" ) {
		var parser = new window.DOMParser;
  		xmlDom = parser.parseFromString(xml_content, 'text/xml');
	}
	else {
		xmlDom = xml_content;
	}

	Jath.resolver = function( prefix ) {
		var mappings = { 
    		def: "http://www.idpf.org/2007/opf",
			dc: "http://purl.org/dc/elements/1.1/"
		};
		return mappings[ prefix ];
	}

	json = Jath.parse( Readium.Models.PackageDocumentParser.JathTemplate, xmlDom);

	// parse the page-progression-direction if it is present
	json.paginate_backwards = this.paginateBackwards(xmlDom);

	// try to find a cover image
	cover = this.getCoverHref(xmlDom);
	if(cover) {
		json.metadata.cover_href = this.resolveUri(cover);
	}		
	if(json.metadata.layout === "pre-paginated") {
		json.metadata.fixed_layout = true;
	}
    
    // parse the manifest into a proper collection
	json.manifest = new Readium.Collections.ManifestItems(json.manifest, {packageDocument: this});

	// create a map of all the media overlay objects
	json.mo_map = this.resolveMediaOverlays(json.manifest);

	// parse the spine into a proper collection
	json.spine = this.parseSpineProperties(json.spine);

	// return the parse result
	return json;

};

	

Readium.Models.PackageDocumentParser.prototype.getCoverHref = function(dom) {
	var manifest; var $imageNode;
	manifest = dom.getElementsByTagName('manifest')[0];

	// epub3 spec for a cover image is like this:
	/*<item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />*/
	$imageNode = $('item[properties~="cover-image"]', manifest);
	if($imageNode.length === 1 && $imageNode.attr("href") ) {
		return $imageNode.attr("href");
	}

	// some epub2's cover image is like this:
	/*<meta name="cover" content="cover-image-item-id" />*/
	var metaNode = $('meta[name="cover"]', dom);
	var contentAttr = metaNode.attr("content");
	if(metaNode.length === 1 && contentAttr) {
		$imageNode = $('item[id="'+contentAttr+'"]', manifest);
		if($imageNode.length === 1 && $imageNode.attr("href")) {
			return $imageNode.attr("href");
		}
	}

	// that didn't seem to work so, it think epub2 just uses item with id=cover
	$imageNode = $('#cover', manifest);
	if($imageNode.length === 1 && $imageNode.attr("href")) {
		return $imageNode.attr("href");
	}

	// seems like there isn't one, thats ok...
	return null;
};

Readium.Models.PackageDocumentParser.prototype.parseSpineProperties = function(spine) {
	
	var parseProperiesString = function(str) {
		var properties = {};
		var allPropStrs = str.split(" "); // split it on white space
		for(var i = 0; i < allPropStrs.length; i++) {
			// brute force!!!
			//rendition:orientation landscape | portrait | auto
			//rendition:spread none | landscape | portrait | both | auto

			//rendition:page-spread-center 
			//page-spread | left | right
			//rendition:layout reflowable | pre-paginated
			if(allPropStrs[i] === "rendition:page-spread-center") properties.page_spread = "center";
			if(allPropStrs[i] === "page-spread-left") properties.page_spread = "left";
			if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
			if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
			if(allPropStrs[i] === "rendition:layout-reflowable") properties.fixed_flow = false;
			if(allPropStrs[i] === "rendition:layout-pre-paginated") properties.fixed_flow = true;
		}
		return properties;
		
	}

	for(var i = 0; i < spine.length; i++) {
		var props = parseProperiesString(spine[i].properties);
		// add all the properties to the spine item
		_.extend(spine[i], props);
	}
	return spine;
};

// resolve the url of smils on any manifest items that have a MO
// attribute
Readium.Models.PackageDocumentParser.prototype.resolveMediaOverlays = function(manifest) {
	var that = this;
    var momap = {};
    
    // create a bunch of media overlay objects
    manifest.forEach( function(item) {
		if(item.get("media_type") === "application/smil+xml") {
            var url = that.resolveUri(item.get("href"));
            var moObject = new Readium.Models.MediaOverlay();
            moObject.setUrl(url);
            moObject.fetch(); 
            momap[item.id] = moObject;
        }
	});
	return momap;
};

// parse the EPUB3 `page-progression-direction` attribute
Readium.Models.PackageDocumentParser.prototype.paginateBackwards = function(xmlDom) {
	return $('spine', xmlDom).attr('page-progression-direction') === "ltr";
};


// combine the spine item data with the corresponding manifest
// data to build useful set of backbone objects
Readium.Models.PackageDocumentParser.prototype.crunchSpine = function(spine, manifest) {
	//var bbSpine = new Readium.Collections.Spine(spine, {packageDocument: this});
	var that = this;
	var index = -1; // to keep track of the index of each spine item
	
	var bbSpine = _.map(spine, function(spineItem) {
		index += 1;
		
		var manItem = manifest.find(function(x) {
			if(x.get("id") === spineItem["idref"]) return x;
		});

		// crunch spine attrs and manifest attrs together into one obj
		var book = that.get("book");
		return _.extend({}, spineItem, manItem.attributes, {"spine_index": index}, {"page_prog_dir": book.get("page_prog_dir")});
	});

	return new Readium.Collections.Spine(bbSpine, {packageDocument: this});
};

// convert a relative uri to a fully resolved one
Readium.Models.PackageDocumentParser.prototype.resolveUri = function(rel_uri) {
	uri = new URI(rel_uri);
	return uri.resolve(this.uri_obj).toString();
};
// This class is used to navigate an EPub's package document
Readium.Models.PackageDocument = Backbone.Model.extend({

	initialize: function(attributes, options) {
		var that = this;
		
		if(!attributes.file_path) {
			// Sanity Check: we need to know where to fetch the data from
			throw "This class cannot be synced without a file path";
		}
		else {
			// set it as a property of `this` so that `BackboneFileSystemSync`
			// knows how to find it
			this.file_path = attributes.file_path;

			// use the `FileSystemApi` to generate a fully resolved
			// `filesytem:url`
			Readium.FileSystemApi(function(api) {
				api.getFsUri(that.file_path, function(uri) {
					that.uri_obj = new URI(uri);
				})
			});
		}
		this.on('change:spine_position', this.onSpinePosChanged);
		
    },

    onSpinePosChanged: function() {
    	if( this.get("spine_position") >= this.previous("spine_position") ) {
    		this.trigger("increased:spine_position");
    	}
    	else {
    		this.trigger("decreased:spine_position");
    	}
    },

	// just want to make sure that we do not slip into an
	// invalid state
	validate: function(attrs) {
		
		if( !( attrs.manifest || this.get("manifest") ) ) {
			return "ERROR: All ePUBs must have a manifest";
		}

		//validate the spine exists and the position is valids
		var spine = attrs.spine || this.get("spine") ;
		if( !spine ) {
			return "ERROR: All ePUBs must have a spine";
		}
		if(attrs.spine_position < 0 || attrs.spine_position >= spine.length)	{
			return "ERROR: invalid spine position";
		}
	},

	sync: BBFileSystemSync,

	defaults: {
		spine_position: 0
	},
	
	getManifestItemById: function(id) {
		return this.get("manifest").find(function(x) { 
					if(x.get("id") === id) return x;
				});
	},

	getSpineItem: function(index) {
		return this.get("res_spine").at(index);
	},

	spineLength: function() {
		return this.get("res_spine").length;
	},

	// gets the next position in the spine for which the
	// spineItem does not have `linear='false'`. The start
	// param is the non-inclusive position to begin the search
	// from. If start is not supplied, the search will begin at
	// postion 0. If no linear position can be found, this 
	// funciton returns -1
	getNextLinearSpinePostition: function(start) {
		var spine = this.get("res_spine");
		if(start === undefined || start < -1) {
			start = -1;
		}

		while(start < spine.length - 1) {
			start += 1;
			if(spine.at(start).get("linear") !== "no") {
				return start;
			}
		}

		return -1;
	},

	// gets the previous position in the spine for which the
	// spineItem does not have `linear='false'`. The start
	// param is the non-inclusive position to begin the search
	// from. If start is not supplied, the search will begin at
	// the end of the spine. If no linear position can be found, 
	// this function returns -1
	getPrevLinearSpinePostition: function(start) {
		var spine = this.get("res_spine");
		if(start === undefined || start > spine.length) {
			start = spine.length;
		}

		while(start > 0) {
			start -= 1;
			if(spine.at(start).get("linear") !== "no") {
				return start;
			}
		}

		return -1;
	},

	goToNextSection: function() {
		var cp = this.get("spine_position");
		this.set({spine_position: (cp + 1) });
	},

	goToPrevSection: function() {
		var cp = this.get("spine_position");
		this.set({spine_position: (cp - 1) });	
	},

	spineIndexFromHref: function(href) {
		var spine = this.get("res_spine");
		href = this.resolveUri(href).replace(/#.*$/, "");
		for(var i = 0; i < spine.length; i++) {
			var path = spine.at(i).get("href");
			path = this.resolveUri(path).replace(/#.*$/, "");
			if(path === href) {
				return i;
			}
		}
		return -1;
	},

	goToHref: function(href) {
		var spine = this.get("spine");
		var manifest = this.get("manifest");
		var that = this;
		href = that.resolveUri(href).replace(/#.*$/, "");
		var node = manifest.find(function(x) {
			var path = that.resolveUri(x.get("href")).replace(/#.*$/, "");
			if (href == path) return x;
		});
								 
		// didn't find the spine node, href invalid
		if(!node) {
			return null;
		}

		var id = node.get("id");
		
		for(var i = 0; i < spine.length; ++i ) {
			if(spine[i].idref === id) {
				// always aproach link spine items in fwd dir
				this.set({spine_position: i}, {silent: true});
				this._previousAttributes.spine_position = 0
				this.trigger("change:spine_position")
				break;
			}
		}
	},

	getTocItem: function() {
		var manifest = this.get("manifest");
		var spine_id = this.get("metadata").ncx;
		var item = manifest.find(function(item){ 
			if (item.get("properties").indexOf("nav") !== -1) {
				return true;
			}
			else {
				return false;
			}
		});

		if( item ) {
			return item;
		}

		if( spine_id && spine_id.length > 0 ) {
			return manifest.find(function(item) {
				return item.get("id") === spine_id;
			});
		}

		return null;
	},

	getMediaOverlayItem: function(idref) {
		// just look up the object in the mo_map
		var map = this.get("mo_map");
		return map && map[idref];
	},

	// combine the spine item data with the corresponding manifest
	// data to build useful set of backbone objects
	crunchSpine: function(spine, manifest) {
		//var bbSpine = new Readium.Collections.Spine(spine, {packageDocument: this});
		var that = this;
		var index = -1; // to keep track of the index of each spine item
		
		var bbSpine = _.map(spine, function(spineItem) {
			index += 1;
			
			var manItem = manifest.find(function(x) {
				if(x.get("id") === spineItem["idref"]) return x;
			});

			// crunch spine attrs and manifest attrs together into one obj
			var book = that.get("book");
			return _.extend({}, spineItem, manItem.attributes, {"spine_index": index}, {"page_prog_dir": book.get("page_prog_dir")});
		});

		// Add the index of the spine item to the manifest item's id to prevent the backbone collection
		//   from finding duplicate manifest items when different itemref elements in the spine reference
		//   the same manifest item through the "idref" attribute.
		$.each(bbSpine, function () {
			this.id = this.id + this.spine_index;
		});

		return new Readium.Collections.Spine(bbSpine, {packageDocument: this});
	},

	parse: function(xmlDom) {
		var parser = new Readium.Models.PackageDocumentParser(this.uri_obj);
		var json = parser.parse(xmlDom);
		json.res_spine = this.crunchSpine(json.spine, json.manifest);
		return json;
	},

	resolveUri: function(rel_uri) {
		uri = new URI(rel_uri);
		return uri.resolve(this.uri_obj).toString();
	},

	// reslove a relative file path to relative to this the
	// the path of this pack docs file path
	resolvePath: function(path) {
		var suffix;
		var pack_doc_path = this.file_path;
		if(path.indexOf("../") === 0) {
			suffix = path.substr(3);
		}
		else {
			suffix = path;
		}
		var ind = pack_doc_path.lastIndexOf("/")
		return pack_doc_path.substr(0, ind) + "/" + suffix;
	}


});
// Description: This model is a sort of "controller" for an ePUB, managing the interaction between calling code
//   and the saved epub. This model also exposes and persists properties that determine how an epub is displayed in 
//   Readium. Some of these properties are determined by the user, such as whether two pages are being displayed, the font size etc.
//   Other properties are determined by the user's interaction with the reader and the structure of the book. These include
//   the current spine item rendered in the viewer, as well the logic that governs changing the current spine item.  
//
// Rationale: This model is designed to expose a useful concept of an "epub" to the rest of Readium. This includes the contents
//   of the epub itself, as well as view properties (mentioned above) and the logic governing interaction with epub properties and 
//   contents. It is the intention for this model that it have little to no knowledge of how an epub is rendered. It is intended 
//   that Backbone attributes (getting/setting) and the backbone attribute event model (events fired on attribute changes) should 
//   the primary ways of interacting with this model.

// REFACTORING CANDIDATE: Need to think about the purpose and implementation of the hash_fragment attribute

Readium.Models.EPUBController = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {

		// capture context for use in callback functions
		var that = this;

		this.epub = this.get("epub");
        
        this.set("media_overlay_controller", 
            new Readium.Models.MediaOverlayController({epubController : this}));

		// create a [`Paginator`](/docs/paginator.html) object used to initialize
		// pagination strategies for the spine items of this book
		this.paginator = new Readium.Models.PaginationStrategySelector({book: this});

		// Get the epub package document
		this.packageDocument = this.epub.getPackageDocument();

		// TODO: this might have to change: Should this model load the package document or epub_state??
		// load the `packageDocument` from the HTML5 filesystem asynchroniously
		this.packageDocument.fetch({

			// success callback is executed once the filesSystem contents have 
			// been read and parsed
			success: function() {

				// restore the position the reader left off at from cookie storage
				var pos = that.restorePosition();
                that.get("media_overlay_controller").restoredPosition();
				that.set("spine_position", pos);

				// tell the paginator to start rendering spine items from the 
				// freshly restored position
				var items = that.paginator.renderSpineItems(false);
				that.set("rendered_spine_items", items);
				
				// check if a TOC is specified in the `packageDocument`
				that.set("has_toc", ( !!that.packageDocument.getTocItem() ) );
			}
		});
        
        // `change:spine_position` is triggered whenver the reader turns pages
		// accross a `spine_item` boundary. We need to cache thier new position
		// and 
		this.on("change:spine_position", this.savePosition, this);

		// If we encounter a new fixed layout section, we need to parse the 
		// `<meta name="viewport">` to determine the size of the iframe
		this.on("change:spine_position", this.setMetaSize, this);
	},

	// Description: Persists the attributes of this model
	// Arguments (
	//   attrs: doesn't appear to be used
	//   options: 
	//	)
	// Rationale: Each epub unpacked and saved to the filesystem in Readium has a unique
	//   key. "_epubViewProperties" is appended to this unique key to persist the read/write
	//   attributes separately from the read-only attributes of the epub.
	save: function(attrs, options) {
		// TODO: this should be done properly with a backbone sync
		var ops = {
			success: function() {
			}
		}
		_.extend(ops,options);
		var that = this;

		// Set attributes required to persist the epub-specific viewer properties
		this.set("updated_at", new Date());
		this.set("key", this.epub.get("key") + "_epubViewProperties");

		// Persist viewer properties
		Lawnchair(function() {
			this.save(that.toJSON(), ops.success);
		});
	},

	defaults: {
		"font_size": 10,
    	"two_up": false,
    	"full_screen": false,
    	"toolbar_visible": true,
    	"toc_visible": false,
    	"rendered_spine_items": [],
    	"current_theme": "default-theme",
    	"current_margin": 3,
    	"epubCFIs" : {}
  	},

  	// Description: serialize this models state to `JSON` so that it can
  	//   be persisted and restored
  	toJSON: function() {

  		// only save attrs that should be persisted:
  		return {
			"updated_at": this.get("updated_at"),
			"current_theme": this.get("current_theme"),
			"current_margin": this.get("current_margin"),
			"two_up": this.get("two_up"),
			"font_size": this.get("font_size"),
			"key": this.get("key"),
			"epubCFIs" : this.get("epubCFIs")
		};
	},

	toggleFullScreen: function() {
		var fullScreen = this.get("full_screen");
		this.set({full_screen: !fullScreen});
	},

	increaseFont: function() {
		var size = this.get("font_size");
		this.set({font_size: size + 1})
	},

	decreaseFont: function() {
		var size = this.get("font_size");
		this.set({font_size: size - 1})
	},

	toggleToc: function() {
		var vis = this.get("toc_visible");
		this.set("toc_visible", !vis);
	},

	// Description: Obtains the href and hash (if it exists) to set as the current "position"
	//    of the epub. Any views and models listening to epub attributes are informed through
	//    the backbone event broadcast.
	// Arguments (
	//   href (URL): The url and hash fragment that indicates the position in the epub to set as
	//   the epub's current position. This argument either has to be the absolute path of the resource in 
	//   the filesystem, or the path of the resource RELATIVE to the package document.
	//   When a URI is resolved by the package document model, it assumes that any relative path for a resource is
	//   relative to the package document.
	// )
	goToHref: function(href) {
		// URL's with hash fragments require special treatment, so
		// first thing is to split off the hash frag from the rest
		// of the url:
		var splitUrl = href.match(/([^#]*)(?:#(.*))?/);

		// Check if the hash contained a CFI reference
		if (splitUrl[2] && splitUrl[2].match(/epubcfi/)) {

			this.handleCFIReference(splitUrl[2]);
		}
		// The href is a standard hash fragment
		else {

			// REFACTORING CANDIDATE: Move this into its own "private" method
			if(splitUrl[1]) {
				var spine_pos = this.packageDocument.spineIndexFromHref(splitUrl[1]);

				if (this.get("media_overlay_controller")) {
                    this.get("media_overlay_controller").goToHref(href);
				}
                
                var reRenderSpinePos = true;
				// if media overlays are playing, don't re-render spine position. it causes flashing and breaks highlighting.
                if (this.get("media_overlay_controller").get("state") != "unavailable") {
                    reRenderSpinePos = false;
                } 
                this.setSpinePos(spine_pos, false, reRenderSpinePos, splitUrl[2]);	
				this.set("hash_fragment", splitUrl[2]);
			}
		}
	},

	getToc: function() {
		var item = this.packageDocument.getTocItem();
		if(!item) {
			return null;
		}
		else {
			var that = this;
			return Readium.Models.Toc.getToc(item, {
				file_path: that.resolvePath(item.get("href")),
				book: that
			});
		}
	},

	// Note: "Section" actually refers to a spine item
	getCurrentSection: function(offset) {
		if(!offset) {
			offset = 0;
		}
		var spine_pos = this.get("spine_position") + offset;
		return this.packageDocument.getSpineItem(spine_pos);
	},

	// REFACTORING CANDIDATE: this should be renamed to indicate it applies to the entire epub.
	//   This is only passing through this data to avoid breaking code in viewer.js. Eventually
	//   this should probably be removed. 
	isFixedLayout: function() {
		return this.epub.isFixedLayout();
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	handleCFIReference : function (CFI) {

		var packageDocument;
		var hrefOfFirstContentDoc;
		var spinePos;
		var elementId;

		// REFACTORING CANDIDATE: This is a temporary approach for retrieving a document representation of the 
		//   package document. Probably best that the package model be able to return this representation of itself.
        $.ajax({

            type: "GET",
            url: this.epub.get("root_url"),
            dataType: "xml",
            async: false,
            success: function (response) {

                packageDocument = response;
            }
        });

		// get the href of the first content document
		hrefOfFirstContentDoc = EPUBcfi.Interpreter.getContentDocHref(CFI, packageDocument);

		// get the spine position of the content document and add the cfi to the current list, set the spine position
		spinePos = this.packageDocument.spineIndexFromHref(hrefOfFirstContentDoc);

		// Generate an element id from the CFI
		// REFACTORING CANDIDATE: There is no need for this to be a cryptographic hash function. It was chosen 
		//   because the Crypto library was already part of Readium. All that is required here is a unique id
		//   for injected elements. 
		var elementId = Crypto.SHA1(CFI);

		this.addCFIwithPayload(CFI, spinePos, "<span id='" + elementId + "' class='cfi_marker' data-cfi='" + CFI + "'></span>");
		this.setSpinePos(spinePos, false, true, elementId);
		this.set("hash_fragment", elementId);
	},

	restorePosition: function() {
		var pos = Readium.Utils.getCookie(this.epub.get("key"));
		return parseInt(pos, 10) || this.packageDocument.getNextLinearSpinePostition();
	},

	savePosition: function() {
		Readium.Utils.setCookie(this.epub.get("key"), this.get("spine_position"), 365);
	},

	resolvePath: function(path) {
		return this.packageDocument.resolvePath(path);
	},

	hasNextSection: function() {
		var start = this.get("spine_position");
		return this.packageDocument.getNextLinearSpinePostition(start) > -1;
	},

	hasPrevSection: function() {
		var start = this.get("spine_position");
		return this.packageDocument.getPrevLinearSpinePostition(start) > -1;
	},
	
	// goes the next linear section in the spine. Non-linear sections should be
	// skipped as per [the spec](http://idpf.org/epub/30/spec/epub30-publications.html#sec-itemref-elem)
	// REFACTORING CANDIDATE: I think this is a public method and should be moved to the public section
	goToNextSection: function() {

		var cp = this.get("spine_position");
		var pos = this.packageDocument.getNextLinearSpinePostition(cp);
		if(pos > -1) {
			this.setSpinePos(pos, false, false);
		}
	},
	
	// goes the previous linear section in the spine. Non-linear sections should be
	// skipped as per [the spec](http://idpf.org/epub/30/spec/epub30-publications.html#sec-itemref-elem)
	// REFACTORING CANDIDATE: I think this is a public method and should be moved to the public section
	goToPrevSection: function() {
		var cp = this.get("spine_position");
		var pos = this.packageDocument.getPrevLinearSpinePostition(cp);
		if(pos > -1) {
			this.setSpinePos(pos, true, false);
		}
	},

	// Description: Sets the current spine position for the epub, checking if the spine
	//   item is already rendered. 
	// Arguments (
	//	 pos (integer): The index of the spine element to set as the current spine position
	//   goToLastPageOfSection (boolean): Set the viewer to the last page of the spine item (content document/svg)
	//     that will be loaded.
	//   reRenderSpinePos (boolean): Force the spine item to be re-rendered, regardless of whether it is the 
	//     currently set spine item.
	//   goToHashFragmentId: Set the view position to the element with the specified id. This parameter 
	//     overrides the behaviour of "goToLastPageOfSection"
	//	)
	// REFACTORING CANDIDATE: The abstraction here is getting sloppy, as goToHashFragmentId overrides goToLastPageOfSection
	//   and generally, the behaviour of this method is not entirely clear from its name. Perhaps a simple renaming of the
	//   method would suffice? Additionally, the internal impementation could be reviewed to tightened up (comments below).
	setSpinePos: function(pos, goToLastPageOfSection, reRenderSpinePos, goToHashFragmentId) {

		// check for invalid spine position
		if (pos < 0 || pos >= this.packageDocument.spineLength()) {
			
			return;
		}

		var spineItems = this.get("rendered_spine_items");
		var spinePosIsRendered = spineItems.indexOf(pos) >=0 ? true : false;
		var renderedItems;

		// REFACTORING CANDIDATE: There is a somewhat hidden dependency here between the paginator
		//   and the setting of the spine_position. The pagination strategy selector re-renders based on the currently
		//   set spine_position on this model. The pagination strategy selector has a reference to this model, which is 
		//   how it accesses the new spine_position, through the "getCurrentSection" method. 
		//   This would be clearer if the spine_position to set were passed explicitly to the paginator. 
		this.set("spine_position", pos);

		// REFACTORING CANDIDATE: This event should only be triggered for fixed layout sections
		this.trigger("FXL_goToPage");

		// Render the new spine position if it is not already rendered. Otherwise, check if a re-render should
		// be forced (in case a new CFI has to be injected, for example). 
		if (!spinePosIsRendered) {

			renderedItems = this.paginator.renderSpineItems(goToLastPageOfSection, goToHashFragmentId);
			this.set("rendered_spine_items", renderedItems);
		}
		else {

			if (reRenderSpinePos) {

				this.removeLastPageCFI();
				renderedItems = this.paginator.renderSpineItems(goToLastPageOfSection, goToHashFragmentId);
				this.set("rendered_spine_items", renderedItems);				
			}
			else {

				if (!this.isFixedLayout() && goToHashFragmentId) {
					this.paginator.v.goToHashFragment(goToHashFragmentId);
				}
			}
		}
	},

	setMetaSize: function() {

		if(this.meta_section) {
			this.meta_section.off("change:meta_height", this.setMetaSize);
		}
		this.meta_section = this.getCurrentSection();
		if(this.meta_section.get("meta_height")) {
			this.set("meta_size", {
				width: this.meta_section.get("meta_width"),
				height: this.meta_section.get("meta_height")
			});
		}
		this.meta_section.on("change:meta_height", this.setMetaSize, this);
	},

	// REFACTORING CANDIDATE: The methods related to maintaining a hash of cfi information and payloads
	//   will likely be refactored into its own backbone object.
	addCFIwithPayload : function (CFI, spinePosition, htmlPayload, bodyType) {

		var cfiPayload = { contentDocSpinePos : spinePosition, payload : htmlPayload, type : bodyType };
		this.get("epubCFIs")[CFI] = cfiPayload;
	},

	addLastPageCFI : function (CFI, spinePosition) {

		// Create last page marker
		var elementId = Crypto.SHA1(CFI);
		var marker = "<span id='" + elementId + "' data-last-page-cfi='" + CFI + "' class='cfi-marker last-page'></span>";

		// Create payload
		var cfiPayload = { contentDocSpinePos : spinePosition, payload : marker, type : "last-page" };

		// Check if a last page marker already exists
		var CFIPayloads = this.get("epubCFIs");

		// Check every CFI payload for a "last-page" type, in case more than one exists
		$.each(CFIPayloads, function (currCFI, payloadObject) {

			if (this.type === "last-page") {
				delete CFIPayloads[currCFI]
			}
		});

		// Add the new last page marker
		this.get("epubCFIs")[CFI] = cfiPayload;	
	},

	removeLastPageCFI : function () {

		var activeCFIs = this.get("epubCFIs");
		$.each(activeCFIs, function (currCFI, payloadObject) {

			if (this.type === "last-page") {
				delete activeCFIs[currCFI];
			}
		});
	}
});
Readium.Models.OptionsPresenter = Backbone.Model.extend({

	initialize: function() {
		var book = this.get("book");
		if(!book) {
			throw "ebook must be set in the constructor";
		}
		this.resetOptions();

		// keep self up to date with book
		// Rationale: The options presenter is instantiated when the EPUB viewer is. Because the options presenter 
		//   is persistent throughout the entire time the viewer (a single EPUB) is open, it must be updated if these 
		//   EPUB attributes are somehow changed. 
		book.on("change:font_size", this.resetOptions, this);
		book.on("change:two_up", this.resetOptions, this);
		book.on("change:current_theme", this.resetOptions, this);
		book.on("change:current_margin", this.resetOptions, this);
	},

	applyOptions: function() {
		var book = this.get("book");

		// Disable event handlers to update these EPUB attributes
		book.off("change:font_size", this.resetOptions);
		book.off("change:two_up", this.resetOptions);
		book.off("change:current_theme", this.resetOptions);
		book.off("change:current_margin", this.resetOptions);

		// set everything but two_up
		book.set({
			"font_size": 		this.get("font_size"),
	    	"current_theme": 	this.get("current_theme"),
	    	"current_margin": 	this.get("current_margin")
		});

		// cannot set two_up directly, need to call toggle
		// so determine if we should
		var shouldToggleTwoUp = this.get("two_up") !== book.get("two_up");
		if (shouldToggleTwoUp) {

			book.set("two_up", !book.get("two_up"));
		}

		// Re-enable event handlers after update is complete
		book.on("change:font_size", this.resetOptions, this);
		book.on("change:two_up", this.resetOptions, this);
		book.on("change:current_theme", this.resetOptions, this);
		book.on("change:current_margin", this.resetOptions, this);

		// persist user settings for next time
		book.save();
	},

	resetOptions: function() {
		var book = this.get("book");
		this.set({
			"font_size": 		book.get("font_size"),
	    	"two_up": 			book.get("two_up"),
	    	"current_theme": 	book.get("current_theme"),
	    	"current_margin": 	book.get("current_margin")
		});
	}
});
Readium.Models.Toc = Backbone.Model.extend({

	sync: BBFileSystemSync,

	initialize: function(options) {
		this.file_path = options.file_path;
		this.book = options.book;
		this.book.on("change:toc_visible", this.setVisibility, this);
		this.book.on("change:toolbar_visible", this.setTocVis, this);
	},

	// Rationale: Readium expects that any hrefs to EPUB content are either absolute references or references to the content relative
	//   to the EPUBs package document. Since any href passed to this method is specified as either absolute (in which case we 
	//   don't need to worry) or as relative to the nav document (where the click was generated, as this is the toc), we need
	//   to construct an absolute path from that.
	handleLink: function(href) {

		var TOCHref = this.book.packageDocument.getTocItem().get("href");

		// If toc is in the same folder as the package document, use the href straight
		if (TOCHref.indexOf("/") === -1) {

			this.book.goToHref(href);	
		}
		// If the href target is in a child folder of the toc folder, create the relative URI
		// If the href target is in a parent folder of the toc folder, this will fail, for now.
		else {

			var TOC_URI = new URI(TOCHref);
			var targetHrefURI = new URI(href);

			// Use the TOC path, relative to the package document to create an href for the target resource which will also be relative
			//   to the package document (or absolute, if the href for the TOC was absolute).
			href = targetHrefURI.resolve(TOC_URI).toString();
			this.book.goToHref(href);
		}
	},

	setVisibility: function() {
		this.set("visible", this.book.get("toc_visible"));
	},

	hide: function() {
		this.book.set("toc_visible", false)
	},

	setTocVis: function() {
		if(!this.book.get("toolbar_visible")) {
			this.book.set("toc_visible", false);
		}
	},

	defaults: {
		visible: false
	}

}, {
	// Class Level Attributes!
	XHTML_MIME: "application/xhtml+xml",
	XML_MIME: "text/xml",	
	NCX_MIME: "application/x-dtbncx+xml",
	getToc: function(manItem, options) {
		var media_type = manItem.get("media_type");
		if(media_type === Readium.Models.Toc.XHTML_MIME || 
				media_type === Readium.Models.Toc.XML_MIME) {
			return new Readium.Models.XhtmlToc(options);
		}
		else if (media_type ===  Readium.Models.Toc.NCX_MIME) {
			return new Readium.Models.NcxToc(options);
		}
	}
});


Readium.Models.NcxToc = Readium.Models.Toc.extend({

	jath_template: {

		title: "//ncx:docTitle/ncx:text",

		navs: [ "//ncx:navMap/ncx:navPoint", { 
			text: "ncx:navLabel/ncx:text",
			href: "ncx:content/@src"
		} ]
	},

	// Rationale: This method does not use JATH to parse an NCX document, as JATH doesn't really support elements nested 
	//   recursively, as is possibly the case for navPoint elements in an NCX document. 
	parse: function (xmlDom) {
		var ncxJson = {};

		var $navMap;
		var that = this;

		if (typeof(xmlDom) === "string") {
			var parser = new window.DOMParser;
      		xmlDom = parser.parseFromString(xmlDom, 'text/xml');
		}

		// Get NCX TOC text title
		ncxJson.title = $($("text", $("docTitle", xmlDom)[0])[0]).text();
		
		// For each navpoint, create navPoint objects recursively
		ncxJson.navs = [];
		$navMap = $("navMap", xmlDom);
		$.each($navMap.children(), function() {

			if ($(this).is("navPoint")) {

				ncxJson.navs.push(that.createNavPointObject($(this)));
			}
		});

		return ncxJson;
	},

	// Description: Creates an object that represents a NCX navPoint.   
	// Rationale: Since navPoints can be nested within each other, this method creates each navPoint object recursively.
	createNavPointObject : function ($navPoint) {

		var jsonNavPoint = {};
		var that = this;

		// Each navPoint object has a content src, a label and 0 or more child navPoints
		jsonNavPoint.navs = [];
		$.each($navPoint.children(), function () {

			$currElement = $(this);
			if ($currElement.is("content")) {

				jsonNavPoint.href = $currElement.attr("src");
			}
			else if ($currElement.is("navLabel")) {

				jsonNavPoint.text = $($("text", $currElement)[0]).text();
			}
			else if ($currElement.is("navPoint")) {

				jsonNavPoint.navs.push(that.createNavPointObject($currElement));
			}
		});

		return jsonNavPoint;
	},

	TocView: function() {
		return new Readium.Views.NcxTocView({model: this});
	}
});

Readium.Models.XhtmlToc = Readium.Models.Toc.extend({

	parse: function(xmlDom) {
		var json = {};
		if(typeof(xmlDom) === "string" ) {
			var parser = new window.DOMParser;
      		xmlDom = parser.parseFromString(xmlDom, 'text/xml');
		}
		json.title = $('title', xmlDom).text();
		json.body = $('body', xmlDom);
		return json;
	},

	TocView: function() {
		return new Readium.Views.XhtmlTocView({model: this});
	}
});
// SmilModel both creates and plays the model
// Right now, the model extends the SMIL XML DOM; 
// if this becomes too heavy, we could use a custom lightweight tree instead
Readium.Models.SmilModel = function() {
    
    // these are playback logic functions for SMIL nodes
    // the context of each function is the node itself, as these functions will be attached to the nodes as members
    // e.g. 
    // parNode.render = parRender
    // seqNode.render = seqRender
    // etc
    NodeLogic = {
        
        parRender: function() {
            $.each(this.childNodes, function(index, value) {
                if (value.hasOwnProperty("render")) {
                    value.render();
                }
            });
        },
    
        // render starting at the given node; if null, start at the beginning
        seqRender: function(node) {
            if (node == null) {
                this.firstElementChild.render();
            }
            else {
                node.render();
            }
        },
    
        // called when the clip has completed playback
        audioNotifyChildDone: function() {
            this.parentNode.notifyChildDone(this);
        },
    
        // receive notice that a child node has finished playing
        parNotifyChildDone: function(node) {
            // we're only expecting one audio node child that we have to wait for
            // in the case of a more complex SMIL document (i.e. not media overlays), 
            // we might have to wait for more children to finish playing
            if (node.tagName == "audio") {
                this.parentNode.notifyChildDone(this);
            }
        },
    
        // receive notice that a child node has finished playing
        seqNotifyChildDone: function(node) {
            if (node.nextElementSibling == null) {
                if (this == root) {
                    notifySmilDone();
                }
                else {
                    this.parentNode.notifyChildDone(this);
                }
            }
            else {
                // prepare to play the next child node
                this.render(node.nextElementSibling);
            }
        }
    };
    
    
    // default renderers for time container playback
    // treat <body> like <seq>
    var renderers = {"seq": NodeLogic.seqRender, 
                    "par": NodeLogic.parRender, 
                    "body": NodeLogic.seqRender};
                    
    // each node type has a notification function associated with it
    // the notifiers get called when a child of the node has finished playback
    var notifiers = {"seq": NodeLogic.seqNotifyChildDone, 
                    "par": NodeLogic.parNotifyChildDone, 
                    "body": NodeLogic.seqNotifyChildDone,
                    "audio": NodeLogic.audioNotifyChildDone,
                    "text": function() {}}
    var url = null;
    var urlObj = null;
    var notifySmilDone = null;
    var root = null;
    
    // call this first with the media node renderers to add them to the master list
    this.addRenderers = function(rendererList) {
        renderers = $.extend(renderers, rendererList);
    };
    
    // set this so the model can resolve src attributes
    this.setUrl = function(fileUrl) {
        url = fileUrl;
        urlObj = new URI(url);
    };
    
    // set the callback for when the tree is done
    this.setNotifySmilDone = function(fn) {
        notifySmilDone = fn;
    };
    
    // build the model
    // node is the root of the SMIL tree, for example the body node of the DOM
    this.build = function(node) {
        root = node;
        processTree(node);
    };
    
    // prepare the tree to start rendering from a node
    this.render = function(node) {
        if (node == null || node == undefined || node == root) {
            root.render(null);
        }
        else {
            // if we're jumping to a point in the middle of the tree, then mark the first audio clip as a jump target
            // because it affects audio playback
            var audioNode = this.peekNextAudio(node);
            audioNode.isJumpTarget = true;
            node.parentNode.render(node);
        }
    };
    
    // find the first node with the given attribute value
    // e.g.
    // findNodeByAttrValue("*", "id", "num1")
    // findNodeByAttrValue("text", "", "")
    // findNodeByAttrValue("*", "id", "")
    // but NOT findNodeByAttrValue("text", "", "num1")
    this.findNodeByAttrValue = function(nodename, attr, val) {
        if (root == null) return null;
        var res = null;
        var attr_ = attr;
        
        if (attr_.indexOf(":") != -1) {
            // normalize for jquery
            attr_ = attr_.replace(":", "\\:");
        }
        
        var selector = nodename;
        if (attr_ != "") {
            selector += "[" + attr_;
            if (val != "") {
                selector += "='" + val + "'";
            }
            selector += "]";
        }
        res = $(root).find(selector);
        res = res.length == 0 ? null : res[0]; // grab first result
          
        return res;
    };
    
    // see what the next audio node is going to be
    // TODO take skippability into consideration
    this.peekNextAudio = function(currentNode) {
        
        // these first 2 cases are arguably just here for convenience: if we're near an audio node, then return it
        // TODO this does not consider that audio elements are actually optional children of <par>
        if (currentNode.tagName == "par") {
            return $(currentNode).find("audio")[0];
        }
        // TODO same as above
        if (currentNode.tagName == "text") {
            return $(currentNode.parentNode).find("audio")[0];
        }
        
        // if we aren't near an audio node, then keep looking
        var node = currentNode.parentNode;
        // go up the tree until we find a relative
        while(node.nextElementSibling == null) {
            node = node.parentNode;
            if (node == root) {
                return null;
            }
        }
        // find the first audio node
        return $(node.nextElementSibling).find("audio")[0];
    };
    
    // recursively process a SMIL XML DOM
    function processTree(node) {
        processNode(node);
        if (node.childNodes.length > 0) {
            $.each(node.childNodes, function(idx, val) {
                processTree(val);
            });
        }
    }       
    
    // process a single node and attach render and notify functions to it
    function processNode(node) {
        // add a toString method for debugging
        node.toString = function() {
            var string = "<" + this.nodeName;
            for (var i = 0; i < this.attributes.length; i++) {
                string += " " + this.attributes.item(i).nodeName + "=" + this.attributes.item(i).nodeValue;
            }
            string += ">";
            return string;
        };
        
        // connect the appropriate renderer
        if (renderers.hasOwnProperty(node.tagName)) {
            node.render = renderers[node.tagName];
        }
        
        // connect the appropriate notifier
        if (notifiers.hasOwnProperty(node.tagName)) {
            node.notifyChildDone = notifiers[node.tagName];
        }
        
        scrubAttributes(node);
    }
    
    // make sure the attributes are to our liking
    function scrubAttributes(node) {
        // process audio nodes' clock values
        if (node.tagName == "audio") {
            if ($(node).attr("src") != undefined) {
                $(node).attr("src", resolveUrl($(node).attr("src")));
            }    
            if ($(node).attr("clipBegin") != undefined) {
                $(node).attr("clipBegin", resolveClockValue($(node).attr("clipBegin")));
            }
            else {
                $(node).attr("clipBegin", 0);
            }
            if ($(node).attr("clipEnd") != undefined) {
                $(node).attr("clipEnd", resolveClockValue($(node).attr("clipEnd")));
            }
            else {
                $(node).attr("clipEnd", -1);
            }
        }
        else if (node.tagName == "text") {
            if ($(node).attr("src") != undefined) {
                $(node).attr("src", resolveUrl($(node).attr("src")));
            }
            if ($(node).attr("epub:textref") != undefined) {
                $(node).attr("epub:textref", resolveUrl($(node).attr("epub:textref")));
            }
        }
    }
    
    // TODO in the future, this will act as a skippability filter
    function canPlayNode(node) {
        return true;
    }
    
    // resolve url against SmilModel's urlObj
    function resolveUrl(url) {
        var url_ = new URI(url);
        return url_.resolve(urlObj).toString();
    }
    
    // parse the timestamp and return the value in seconds
    // supports this syntax: http://idpf.org/epub/30/spec/epub30-mediaoverlays.html#app-clock-examples
    function resolveClockValue(value) {        
        var hours = 0;
        var mins = 0;
        var secs = 0;
        
        if (value.indexOf("min") != -1) {
            mins = parseFloat(value.substr(0, value.indexOf("min")));
        }
        else if (value.indexOf("ms") != -1) {
            var ms = parseFloat(value.substr(0, value.indexOf("ms")));
            secs = ms/1000;
        }
        else if (value.indexOf("s") != -1) {
            secs = parseFloat(value.substr(0, value.indexOf("s")));                
        }
        else if (value.indexOf("h") != -1) {
            hours = parseFloat(value.substr(0, value.indexOf("h")));                
        }
        else {
            // parse as hh:mm:ss.fraction
            // this also works for seconds-only, e.g. 12.345
            arr = value.split(":");
            secs = parseFloat(arr.pop());
            if (arr.length > 0) {
                mins = parseFloat(arr.pop());
                if (arr.length > 0) {
                    hours = parseFloat(arr.pop());
                }
            }
        }
        var total = hours * 3600 + mins * 60 + secs;
        return total;
    }
};
// loads and plays a single SMIL document
Readium.Models.MediaOverlay = Backbone.Model.extend({
    audioplayer: null,
    smilModel: null,
    consoleTrace: false,
    url: null,
    urlObj: null,
    
    // observable properties
    defaults: {
        current_text_src: null,    
        has_started_playback: false,
        is_document_done: false,
        is_playing: false,
        is_ready: false
    },
    
    initialize: function() {
        var self = this;
        this.audioplayer = new Readium.Models.AudioClipPlayer();

        // always know whether we're playing or paused
        this.audioplayer.setNotifyOnPause(function() {
            self.set({is_playing: self.audioplayer.isPlaying()});
        });
        this.audioplayer.setNotifyOnPlay(function(){
           self.set({is_playing: self.audioplayer.isPlaying()});
        });    
    },
    
    // set the URL before calling fetch()
    setUrl: function(smilUrl) {
        this.url = smilUrl;
        this.urlObj = new URI(this.url);
    },
    
    // start retrieving the data
    fetch: function(options) {
        this.set({is_ready: false});
        options = options || {};
        options.dataType="xml";
        Backbone.Model.prototype.fetch.call(this, options);
    },
    
    // backbone fetch() callback; passes in an xml data object
    parse: function(xml) {
        var self = this;
        this.smilModel = new Readium.Models.SmilModel();
        this.smilModel.setUrl(this.url);
        this.smilModel.setNotifySmilDone(function() {
            self.debugPrint("document done");
            self.set({is_document_done: true});
        });
        
        // very important piece of code: attach render functions to the model
        // at runtime, 'this' is the node in question
        this.smilModel.addRenderers({            
            "audio": function() {
                // have the audio player inform the node directly when it's done playing
                var thisNode = this;
                self.audioplayer.setNotifyClipDone(function() {
                    thisNode.notifyChildDone();
                });
                var isJumpTarget = false;
                if (this.hasOwnProperty("isJumpTarget")) {
                    isJumpTarget = this.isJumpTarget;
                    // reset the node's property
                    this.isJumpTarget = false;
                }

                // play the node
                self.audioplayer.play($(this).attr("src"), parseFloat($(this).attr("clipBegin")), parseFloat($(this).attr("clipEnd")), isJumpTarget);
            }, 
            "text": function(){
                var src = $(this).attr("src");
                self.debugPrint("Text: " + src);
                self.set("current_text_src", src);
            }
        });
        
        // start the playback tree at <body>
        var smiltree = $(xml).find("body")[0]; 
        this.smilModel.build(smiltree);
        this.set({is_ready: true});
    },
    // start playback
    // node is a SMIL node that indicates the starting point
    // if node is null, playback starts at the beginning
    startPlayback: function(node) {
        if (this.get("is_ready") === false) {
            this.debugPrint("document not ready");
            return;
        }
        this.set({is_document_done: false});
        this.set({has_started_playback: true});
        this.smilModel.render(node);        
    },
    pause: function() {
        if (this.get("is_ready") == false) {
            this.debugPrint("document not ready");
            return;
        }
        if (this.get("has_started_playback") == false) {
            this.debugPrint("can't pause: playback not yet started");
            return;
        }
        this.audioplayer.pause();
    },
    resume: function() {
        if (this.get("is_ready") == false) {
            this.debugPrint("document not ready");
            return;
        }
        if (this.get("has_started_playback") == false) {
            this.debugPrint("can't resume: playback not yet started");
            return;
        }
        this.audioplayer.resume();        
    },
    findNodeByTextSrc: function(src) {
        if (this.get("is_ready") == false) {
            this.debugPrint("document not ready");
            return null;
        }
        
        if (src == null || src == undefined || src == "") {
            return null;
        }
        
        var elm = this.smilModel.findNodeByAttrValue("text", "src", src);
        if (elm == null){
            elm = this.smilModel.findNodeByAttrValue("seq", "epub:textref", src);
        }    
        return elm;
    },
    setVolume: function(value) {
        this.audioplayer.setVolume(value);
    },
    setRate: function(value) {
        this.audioplayer.setRate(value);
    },
    getVolume: function() {
        return this.audioplayer.getVolume();
    },
    getRate: function() {
        return this.audioplayer.getRate();
    },
    reset: function() {
        this.set("current_text_src", null);
        this.set("has_started_playback", false);
        this.audioplayer.reset();
    },
    setConsoleTrace: function(onOff) {
        this.consoleTrace = onOff;
        this.audioplayer.setConsoleTrace(onOff);
    },
    debugPrint: function(str) {
        if (this.consoleTrace) {
            console.log("MediaOverlay: " + str);
        }
    }
});
Readium.Models.AudioClipPlayer = function() {
    
    // clip info
    var src = null;
    var clipBegin = null;
    var clipEnd = null;
    
    // force the clip to reset its start time
    var forceReset = false;
    
    // the html audio element created to hold whatever the current file is
    var elm = new Audio();
    
    // callback function
    var notifyClipDone = null;
    
    // send debug statements to the console
    var consoleTrace = false;
    
    // ID of the setInterval timer
    var intervalId = null;
    
    // current rate; default is normal speed
    var rate = 1.0;
    
    this.setNotifyClipDone = function(notifyClipDoneFn) {
        notifyClipDone = notifyClipDoneFn;
    };
    this.setConsoleTrace =  function(isOn) {
        consoleTrace = isOn;
    };
    
    // clipBeginTime and clipEndTime are in seconds
    // filesrc is an absolute path, local or remote
    this.play = function(filesrc, clipBeginTime, clipEndTime, shouldForceReset) {
        src = filesrc;
        clipBegin = clipBeginTime;
        clipEnd = clipEndTime;
        forceReset = shouldForceReset;
        
        debugPrint("playing " + src + " from " + clipBegin + " to " + clipEnd);
        
        // make sure we haven't already created an element for this audio file
        if (elm == null || elm.getAttribute("src") != src) {
            loadData();
        }
        // the element is already loaded; just need to continue playing at the right point
        else {
            elm.playbackRate = rate;
            continueRender();
        }
    };
    
    this.isPlaying = function() {
        if (elm == null) {
            return false;
        }
        return !elm.paused;
    };
    
    this.resume = function() {
        if (elm != null) {
            elm.play();
        }
    };
    
    this.pause = function() {
        if (elm != null) {
            elm.pause();
        }
    };
    
    this.setNotifyOnPause = function(notifyOnPause) {
        elm.addEventListener("pause", function() {
            notifyOnPause();
        });
    };
    
    this.setNotifyOnPlay = function(notifyOnPlay) {
        elm.addEventListener("play", function() {
            notifyOnPlay();
        });
    };
    
    this.getCurrentTime = function() {
        if (elm != null) {
            return elm.currentTime;
        }
        return 0;
    };
    this.getCurrentSrc = function() {
        return src;
    };
    // volume ranges from 0 to 1.0
    this.setVolume = function(value) {
        if (value < 0) {
            elm.volume = 0;
        }
        else if (value > 1) {
            elm.volume = 1;
        }
        else {
            elm.volume = value;
        }
    };
    // reasonable rate values are from 0.5 (slow) to 2.5 (fast),
    // though no restrictions are hardcoded here
    this.setRate = function(value) {
        if (this.isPlaying()) {
            elm.playbackRate = value;
        }
        rate = value;  
    };
    this.getVolume = function() {
        return elm.volume;  
    };
    this.getRate = function() {
        return rate;
    };
    this.reset = function() {
        elm.setAttribute("src", "");
    };
    function loadData(){
        debugPrint("Loading file " + src);
        elm.setAttribute("src", src);
        
        // wait for 'canplay' before continuing
        elm.addEventListener("canplay", setThisTime);
        function setThisTime() {
            elm.removeEventListener("canplay", setThisTime);
            // TODO put something in here for remote files to make sure the file is buffered
        
            //if clipEnd is -1, it means the value was not specified
            // we handle unspecified clipBegin by setting it to 0 at parsetime
            if (clipEnd == -1 || clipEnd > elm.duration) {
                debugPrint("File is shorter than specified clipEnd time");
                clipEnd = elm.duration;
            }
            debugPrint("Audio data loaded");
            elm.playbackRate = rate;
            continueRender();        
        }
        
        elm.addEventListener("ended", ended);
        function ended() {
            elm.removeEventListener("ended", ended);
            debugPrint("Audio file ended.");
            // cancel the timer, if any
            if (intervalId != null) {
                clearInterval(intervalId);
            }
            if (notifyClipDone != null) {
                notifyClipDone();
            }
        }
    }
    
    function continueRender() {
        
        // if the current time is already somewhere within the clip that we want to play, then just let it keep playing
        if (forceReset == false && elm.currentTime > clipBegin && elm.currentTime < clipEnd) {
            startClipTimer();
            elm.play();    
        }
        else {
            elm.addEventListener("seeked", seeked);
            debugPrint("setting currentTime from " + elm.currentTime + " to " + clipBegin);
            elm.currentTime = clipBegin;
            function seeked() {
                elm.removeEventListener("seeked", seeked);
                startClipTimer();
                elm.play();
            }
        }
    }
    
    function startClipTimer() {
        
        // cancel the old timer, if any
        if (intervalId != null) {
            clearInterval(intervalId);
        }
        
        // we're using setInterval instead of monitoring the timeupdate event because timeupdate fires, at best, every 200ms, which messes up playback of short phrases.
        // 11ms seems to be chrome's finest allowed granularity for setInterval (and this is for when the tab is active; otherwise it fires about every second)
        intervalId = setInterval(function() {
            if (elm.currentTime >= clipEnd && clipEnd != -1) {
                debugPrint(elm.currentTime + " >= " + clipEnd);
                clearInterval(intervalId);
                debugPrint("clip done");
                if (notifyClipDone != null) {
                    notifyClipDone();
                }
            }
        }, 11);   
    }
    
    function debugPrint(str) {
        if (consoleTrace) {
            console.log("AudioClipPlayer: " + str);
        }
    }
};

// Description: Chooses a pagination strategy

// REFACTORING CANDIDATE: There is an issue here that is a bit hidden. Having this pagination strategy model attached to the 
//   epub makes sense in that each spine item within an epub can be either reflowable or fixed. As such, when navigating through
//   the epub, a decisions as to the type of pagination view must be made dynamically. However, at the moment, while it appears that
//   this is how the pagination strategy is set up, in actual fact, an entire fixed layout epub is rendered based on the type of spine item
//   found at the current spine_position. Since all the other spine items are then rendered assuming they are also fixed layout, the 
//   pagination strategy is never called again when navigating to the other (possibly reflowable) spine items. This will have to be addressed
//   at some point. 

Readium.Models.PaginationStrategySelector = Backbone.Model.extend({

	renderToLastPage: false,

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //	

	initialize: function() {

		this.model = this.get("book");
		this.zoomer = new Readium.Views.FixedLayoutBookZoomer();
	},

	// Description: Determine what the current spine item is and render it
	//   Updates which spine items have been rendered in an array of rendered spine items
	renderSpineItems: function(renderToLast, hashFragmentId) {
		var book = this.model;
		var that = this;
		var rendered_spine_positions = [];

		// clean up the old view if there is one
		if (this.v) {
			this.v.destruct();
		}

		// Spine items as found in the package document can have attributes that override global settings for the ebook. This 
		// requires checking/creating the correct pagination strategy for each spine item
		var spineItem = book.getCurrentSection();
		if (spineItem.isFixedLayout()) {

			this.v = new Readium.Views.FixedPaginationView({model: book, zoomer: this.zoomer});
		}
		// A scrolling epub
		else if (this.shouldScroll()) {

				this.v = new Readium.Views.ScrollingPaginationView({model: book, zoomer: this.zoomer});
		}
		// A reflowable epub
		else {

			this.v = new Readium.Views.ReflowablePaginationView({model: book, zoomer: this.zoomer});
		}

		this.rendered_spine_positions = this.v.render(!!renderToLast, hashFragmentId);
		return this.rendered_spine_positions;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //  

	shouldScroll: function() {
		var optionString = localStorage["READIUM_OPTIONS"];
		var options = (optionString && JSON.parse(optionString) ) || {"singleton": {}};
		return !options["singleton"]["paginate_everything"];
	}
});
Readium.Models.Trigger = function(domNode) {
	var $el = $(domNode);
	this.action 	= $el.attr("action");
	this.ref 		= $el.attr("ref");
	this.event 		= $el.attr("ev:event");
	this.observer 	= $el.attr("ev:observer");
	this.ref 		= $el.attr("ref");
};

Readium.Models.Trigger.prototype.subscribe = function(dom) {
	var selector = "#" + this.observer;
	var that = this;
	$(selector, dom).on(this.event, function() {
		that.execute(dom);
	});
};

Readium.Models.Trigger.prototype.execute = function(dom) {
	var $target = $( "#" + this.ref, dom);
	switch(this.action)
	{
	case "show":
	  $target.css("visibility", "visible");
	  break;
	case "hide":
	  $target.css("visibility", "hidden");
	  break;
	case "play":
	  $target[0].currentTime = 0;
	  $target[0].play();
	  break;
	case "pause":
	  $target[0].pause();
	  break;
	case "resume":
	  $target[0].play();
	  break;
	case "mute":
	  $target[0].muted = true;
	  break;
	case "unmute":
	  $target[0].muted = false;
	  break;
	default:
	  console.log("do not no how to handle trigger " + this.action);
	}
};
// Description: The base model for the set of different pagination view strategies: Reflowable, fixed layout and scrolling
// Rationale: The intention behind this model is to provide implementations for behaviour common to all the pagination 
//   strategies. 
// Notes: This model has a reference to the model for the epub currently being rendered, as well as a "pages" object that
//   contains data and behaviour related to the current set of rendered "pages."

Readium.Views.PaginationViewBase = Backbone.View.extend({

	// Description: All strategies are linked to the same dom element
	el: "#readium-book-view-el",

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {
		this.zoomer = options.zoomer;
		this.pages = new Readium.Models.ReadiumPagination({model : this.model});
		this.mediaOverlayController = this.model.get("media_overlay_controller");
        this.mediaOverlayController.setView(this);
        
		this.pages.on("change:current_page", this.showCurrentPages, this);

		this.model.on("change:font_size", this.setFontSize, this);
		this.model.on("change:two_up", this.pages.toggleTwoUp, this.pages);
        
        this.mediaOverlayController.on("change:mo_text_id", this.highlightText, this);
        this.mediaOverlayController.on("change:state", this.indicateMoIsPlaying, this);
        
		this.bindingTemplate = Handlebars.templates.binding_template;
        
        // used for media overlays
        this.flagMoRehighlight = false;
	},

    iframeLoadCallback: function(e) {
		
		this.applyBindings( $(e.srcElement).contents() );
		this.applySwitches( $(e.srcElement).contents() );
		this.addSwipeHandlers( $(e.srcElement).contents() );
        this.injectMathJax(e.srcElement);
        this.injectLinkHandler(e.srcElement);
        var trigs = this.parseTriggers(e.srcElement.contentDocument);
		this.applyTriggers(e.srcElement.contentDocument, trigs);
		$(e.srcElement).attr('title', Acc.page + ' - ' + Acc.title);
        
        // sometimes the MO highlight didn't work the first time because the contents weren't loaded
        if (this.flagMoRehighlight) {
            this.flagMoRehighlight = false;
    		this.highlightText();
        }
	},
	
    // Description: Activates a style set for the ePub, based on the currently selected theme. At present, 
    //   only the day-night alternate tags are available as an option. 
	activateEPubStyle: function(bookDom) {

	    var selector;
		
		// Apply night theme for the book; nothing will be applied if the ePub's style sheets do not contain a style
		// set with the 'night' tag
	    if (this.model.get("current_theme") === "night-theme") {

	    	selector = new Readium.Models.AlternateStyleTagSelector;
	    	bookDom = selector.activateAlternateStyleSet(["night"], bookDom);

	    }
	    else {

			selector = new Readium.Models.AlternateStyleTagSelector;
	    	bookDom = selector.activateAlternateStyleSet([""], bookDom);
	    }
	},

	// REFACTORING CANDIDATE: This method could use a better name. The purpose of this method is to make one or two 
	//   pages of an epub visible. "setUpMode" seems non-specific. 
	// Description: Changes the html to make either 1 or 2 pages visible in their iframes
	setUpMode: function() {
		var two_up = this.model.get("two_up");
		this.$el.toggleClass("two-up", two_up);
		this.$('#spine-divider').toggle(two_up);
	},

	// Description: Iterates through the list of rendered pages and displays those that 
	//   should be visible in the viewer.
	showCurrentPages: function() {
		var that = this;
		var two_up = this.model.get("two_up");
		this.$(".page-wrap").each(function(index) {
			if(!two_up) { 
				index += 1;
			}
			$(this).toggleClass("hidden-page", !that.pages.isPageVisible(index));
		});
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Sometimes views hang around in memory before
	//   the GC gets them. we need to remove all of the handlers
	//   that were registered on the model
	destruct: function() {
		this.pages.off("change:current_page", this.showCurrentPages);
		this.model.off("change:font_size", this.setFontSize);
        this.mediaOverlayController.off("change:mo_text_id", this.highlightText);
        this.mediaOverlayController.off("change:state", this.indicateMoIsPlaying);
		this.resetEl();
	},

	getBindings: function() {
		var packDoc = this.model.epub.getPackageDocument();
		var bindings = packDoc.get('bindings');
		return bindings.map(function(binding) {
			binding.selector = 'object[type="' + binding.media_type + '"]';
			binding.url = packDoc.getManifestItemById(binding.handler).get('href');
			binding.url = packDoc.resolveUri(binding.url);
			return binding;
		})
	},

	applyBindings: function(dom) {
		var that = this;
		var bindings = this.getBindings();
		var i = 0;
		for(var i = 0; i < bindings.length; i++) {
			$(bindings[i].selector, dom).each(function() {
				var params = [];
				var $el = $(this);
				var data = $el.attr('data');
				var url;
				params.push("src=" + that.model.packageDocument.resolveUri(data));
				params.push('type=' + bindings[i].media_type);
				url = bindings[i].url + "?" + params.join('&');
				var content = $(that.bindingTemplate({}));
				// must set src attr separately
				content.attr('src', url);
				$el.html(content);
			});
		}
	},

	applyTriggers: function(dom, triggers) {
		for(var i = 0 ; i < triggers.length; i++) {
			triggers[i].subscribe(dom);
		}
	},

	// Description: For reflowable content we only add what is in the body tag.
	// Lots of times the triggers are in the head of the dom
	parseTriggers: function(dom) {
		var triggers = [];
		$('trigger', dom).each(function() {
			

			triggers.push(new Readium.Models.Trigger(this) );
		});
		
		return triggers;
	},	

	// Description: Parse the epub "switch" tags and hide
	// cases that are not supported
	applySwitches: function(dom) {

		// helper method, returns true if a given case node
		// is supported, false otherwise
		var isSupported = function(caseNode) {

			var ns = caseNode.attributes["required-namespace"];
			if(!ns) {
				// the namespace was not specified, that should
				// never happen, we don't support it then
				console.log("Encountered a case statement with no required-namespace");
				return false;
			}
			// all the xmlns's that readium is known to support
			// TODO this is going to require maintanence
			var supportedNamespaces = ["http://www.w3.org/1998/Math/MathML"];
			return _.include(supportedNamespaces, ns);
		};

		$('switch', dom).each(function(ind) {
			
			// keep track of whether or now we found one
			var found = false;

			$('case', this).each(function() {

				if( !found && isSupported(this) ) {
					found = true; // we found the node, don't remove it
				}
				else {
					$(this).remove(); // remove the node from the dom
				}
			});

			if(found) {
				// if we found a supported case, remove the default
				$('default', this).remove();
			}
		})
	},

	addSwipeHandlers: function(dom) {
		var that = this;
		$(dom).on("swipeleft", function(e) {
			e.preventDefault();
			that.pages.goRight();
			
		});

		$(dom).on("swiperight", function(e) {
			e.preventDefault();
			that.pages.goLeft();
		});
	},

	// inject mathML parsing code into an iframe
    injectMathJax: function (iframe) {
    	var doc, script, head;
		doc = iframe.contentDocument;
		head = doc.getElementsByTagName("head")[0];
		// if the content doc is SVG there is no head, and thus
		// mathjax will not be required
		if(head) {
			script = doc.createElement("script");
			script.type = "text/javascript";
			script.src = MathJax.Hub.config.root+"/MathJax.js?config=readium-iframe";
			head.appendChild(script);
		}
    },

    injectLinkHandler: function(iframe) {
    	var that = this;
    	$('a', iframe.contentDocument).click(function(e) {
    		that.linkClickHandler(e)
    	});
    },

    resetEl: function() {
    	$('body').removeClass("apple-fixed-layout");
    	$("#readium-book-view-el").attr("style", "");
		this.$el.toggleClass("two-up", false);
		this.$('#spine-divider').toggle(false);
		this.zoomer.reset();

    	$('#page-wrap').css({
    		"position": "relative",
    		"right": "0px", 
    		"top": "0px",
    		"-webkit-transform": "scale(1.0) translate(0px, 0px)"
    	});
    }
});


Readium.Views.FixedPaginationView = Readium.Views.PaginationViewBase.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {

		// call the super ctor
		Readium.Views.PaginationViewBase.prototype.initialize.call(this, options);

		var spinePos = this.model.get("spine_position");
		this.model.on("FXL_goToPage", this.spinePositionChangeHandler, this);
		this.model.on("change:two_up", this.setUpMode, this);
		this.model.on("change:meta_size", this.setContainerSize, this);
	},

	render: function() {

		$('body').addClass('apple-fixed-layout');

		// wipe the html
		this.$('#container').html("");
		this.setContainerSize();
		this.setUpMode();

		var that = this;
		var pageNum = 1; // start from page 1
		var offset = this.findPrerenderStart();
		var rendered_spine_positions = [];
		var spine_position = this.model.get("spine_position");

		// Gets each page of the current pub and injects it into the page 
		// keeping track of what has been pre-rendered
		while ( this.shouldPreRender( this.model.getCurrentSection(offset) ) ) {

			this.addPage(this.model.getCurrentSection(offset), pageNum);
			rendered_spine_positions.push(spine_position + offset);
			pageNum += 1;
			offset += 1;
		}

		// set the page we should be on
		var page = rendered_spine_positions.indexOf(spine_position) + 1;
		this.pages.set("num_pages", pageNum - 1);
		this.pages.goToPage(page);

		setTimeout(function() {
			that.setContainerSize();
		}, 15);

		this.showCurrentPages();
		return rendered_spine_positions;
	},

	// get the body element for a page number
    getPageBody: function(pageNum) {
        var pageElm = $("#page-" + pageNum.toString() +" iframe");
        if (pageElm.length > 0) {
            pageElm = pageElm.contents()[0].documentElement;
            return $(pageElm).find("body")
        }
        else {
            return null;
        }
    },
    
    // override
    // used by media overlays
	indicateMoIsPlaying: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
        var isPlaying = this.mediaOverlayController.get("state") == "playing";
		moHelper.renderFixedMoPlaying(
			this.pages.get("current_page"),
            isPlaying,
			this
        );
	},
    
    // override
    // used by media overlays
	highlightText: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
        moHelper.renderFixedLayoutMoFragHighlight(
			this.pages.get("current_page"),
			this.mediaOverlayController.get("mo_text_id"),
			this
        );
	},
    
    // override
    // Description: return the set of all elements for this spine item that have an @id attribute.
    // used by media overlays
    getAllPageElementsWithId: function() {
        return $('body').find("[id]");
    },
    
    
	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// sometimes these views hang around in memory before
	// the GC's get them. we need to remove all of the handlers
	// that were registered on the model
	destruct: function() {

		// call the super constructor
		Readium.Views.PaginationViewBase.prototype.destruct.call(this);

		// remove any listeners registered on the model
		this.model.off("change:two_up", this.setUpMode);
		this.model.off("change:meta_size", this.setUpMode);		
	},

	// Description: Handles clicks of anchor tags by navigating to
	// the proper location in the epub spine, or opening
	// a new window for external links
	linkClickHandler: function(e) {
		e.preventDefault();

		var href;

		// Check for both href and xlink:href attribute and get value
		if (e.currentTarget.attributes["xlink:href"]) {

			href = e.currentTarget.attributes["xlink:href"].value;
		}
		else {

			href = e.currentTarget.attributes["href"].value;
		}

		// Resolve the relative path for the resource
		href = this.resolveRelativeURI(href);

		if (href.match(/^http(s)?:/)) {
			window.open(href);
		} 
		else {
			this.model.goToHref(href);
		}
	},

	// Rationale: For the purpose of looking up EPUB resources in the package document manifest, Readium expects that 
	//   all relative links be specified as relative to the package document URI (or absolute references). However, it is 
	//   valid XHTML for a link to another resource in the EPUB to be specfied relative to the current document's
	//   path, rather than to the package document. As such, URIs passed to Readium must be either absolute references or 
	//   relative to the package document. This method resolves URIs to conform to this condition. 
	resolveRelativeURI: function (rel_uri) {

		var sourceDocManifestHref;
		var sourceDocName;
		var pageSrc;

		// Get the name of the click source document
		sourceDocManifestHref = this.model.getCurrentSection().get("href");
		indexOfFilenameStart = sourceDocManifestHref.lastIndexOf('/') + 1;
		sourceDocName = sourceDocManifestHref.substr(indexOfFilenameStart, rel_uri.length);

		// Iterate through list of FXL pages. Look for the one that is visible and has the name
		$(".fixed-page-wrap").each(function () {

			var $currPage = $('.content-sandbox', this);

			// Get the name of the content document in the page iframe
			var currPageSrc = $currPage.attr("src");
			var pageDocNameStart = currPageSrc.lastIndexOf('/') + 1;
			var pageDocName = currPageSrc.substr(pageDocNameStart, currPageSrc.length);

			if (pageDocName === sourceDocName) {
				pageSrc = currPageSrc;
				return false;
			}
		});

		var relativeURI = new URI(rel_uri);

		// Get URI for resource currently loaded in the view's iframe
		var iframeDocURI = new URI(pageSrc);

		return relativeURI.resolve(iframeDocURI).toString();
	},

	spinePositionChangeHandler: function () {

		var pageNumber = this.model.get("spine_position") + 1;
		this.pages.goToPage(pageNumber);
	},

	// Description: Creates/gets an iFrame which contains a page view to represent a spine item and appends it to an 
	//   element that contains the content of the current ePub. Each of these spine item iframes is not necessarily displayed
	//   immediately. 
	addPage: function(spineItem, pageNum) {

		var that = this;
		var view = spineItem.getPageView();

		view.on("iframe_loaded", function() {
			this.iframeLoadCallback({srcElement: view.iframe()});
			that.applyKeydownHandler($(view.iframe()));
		}, this);

		var content = spineItem.getPageView().render().el;
		$(content).attr("id", "page-" + pageNum.toString());
		this.$('#container').append(content);

		this.showCurrentPages();

		return this;
	},

	setContainerSize: function() {
		
		var meta = this.model.get("meta_size");

		if (meta) {

			this.$el.width(meta.width * 2);
			this.$el.height(meta.height);
			this.zoomer.fitToBest();

			if (!this.zoomed) {

				this.zoomed = true;
				// setTimeout(function() {
				// 	$('#page-wrap').zoomAndScale(); //<= this was a little buggy last I checked but it is a super cool feature
				// }, 1)	
			}
		}
	},	

	findPrerenderStart: function() {
		
		var i = 0;
		while ( this.shouldPreRender( this.model.getCurrentSection(i) ) ) {
			i -= 1;
		}

		return i + 1; // sloppy fix for an off by one error
	},

	// Description: A spine item should pre-render if it is not undefined and should render as a fixed item
	shouldPreRender: function(spineItem) {
		return spineItem && spineItem.isFixedLayout(); 
	},

	// Description: For each fixed-page-wrap(per), if it is one of the current pages, toggle it as visible. If it is not
	//   toggle it as invisible.
	// Note: current_page is an array containing the page numbers (as of 25June2012, a maximum of two pages) of the 
	//   currently visible pages
	showCurrentPages: function() {
		var that = this;
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});

		this.$(".fixed-page-wrap").each(function(index) {
			$(this).toggle(that.pages.isPageVisible(index + 1));
		});

		// remove any artifact of MO highlighting from the current page(s)
        $.each(this.pages.get("current_page"), function(idx) {
            moHelper.removeActiveClass(that.getPageBody(this.toString()));
        });
	},

	setFontSize: function() {
		var size = this.model.get("font_size") / 10;
		$('#readium-content-container').css("font-size", size + "em");
		this.showCurrentPages();
	},

	applyKeydownHandler : function ($pageViewContainer) {

		var that = this;

		$pageViewContainer.contents().keydown(function (e) {

			if (e.which == 39) {
				that.model.paginator.v.pages.goRight();
			}
							
			if (e.which == 37) {
				that.model.paginator.v.pages.goLeft();
			}
		});
	}
});


Readium.Views.FixedPageView = Backbone.View.extend({

	className: "fixed-page-wrap",

	initialize: function() {
		this.template = Handlebars.templates.fixed_page_template;
		this.model.on("change", this.render, this);
	},

	destruct: function() {
		this.model.off("change", this.render);
	},

	render: function() {
		var that = this;
		var json = this.model.toJSON();
		this.$el.html( this.template( json ) );
		this.$el.addClass( this.model.getPageSpreadClass() );
		this.$('.content-sandbox').on("load", function() {
			that.trigger("iframe_loaded");
		});
		return this;
	},

	iframe: function() {
		return this.$('.content-sandbox')[0];
	}
});


Readium.Views.ImagePageView = Backbone.View.extend({

	className: "fixed-page-wrap",

	initialize: function() {
		this.template = Handlebars.templates.image_page_template;
		this.model.on("change", this.render, this);
	},

	render: function() {
		var that = this;
		var json = this.model.toJSON();
		this.$el.html( this.template( json ) );
		this.$el.addClass( this.model.getPageSpreadClass() );

		this.$('img').on("load", function() { that.setSize(); });
		

		return this;
	},

	setSize: function() {
		var $img = this.$('img');
		var width = $img.width();
		var height = $img.height();
		// temp this is a mess but it will do for now...
		if( width > 0) {
			this.model.set({meta_width: width, meta_height: height})
		}
		
	}

});

Readium.Views.ReflowablePaginationView = Readium.Views.PaginationViewBase.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {

		var that = this;

		// call the super ctor
		Readium.Views.PaginationViewBase.prototype.initialize.call(this, options);
		this.page_template = Handlebars.templates.reflowing_template;

		// make sure we have proper vendor prefixed props for when we need them
		this.stashModernizrPrefixedProps();

		// if this book does right to left pagination we need to set the
		// offset on the right
		if(this.model.epub.get("page_prog_dir") === "rtl") {
			this.offset_dir = "right";
		}
		else {
			this.offset_dir = "left";
		}

		this.pages.on("change:current_page", this.pageChangeHandler, this);
		this.model.on("change:toc_visible", this.windowSizeChangeHandler, this);
		this.model.on("repagination_event", this.windowSizeChangeHandler, this);
		this.model.on("change:current_theme", this.injectTheme, this);
		this.model.on("change:two_up", this.setUpMode, this);
		this.model.on("change:two_up", this.adjustIframeColumns, this);
		this.model.on("change:current_margin", this.marginCallback, this);
		this.model.on("save_position", this.savePosition, this);
	},

	render: function(goToLastPage, hashFragmentId) {
		var that = this;
		var json = this.model.getCurrentSection().toJSON();

		// make everything invisible to prevent flicker
		this.setUpMode();
		this.$('#container').html( this.page_template(json) );
		
		this.$('#readium-flowing-content').on("load", function(e) {
			// Important: Firefox doesn't recognize e.srcElement, so this needs to be checked for whenever it's required.
			if (!e.srcElement) e.srcElement = this;

			var lastPageElementId = that.injectCFIElements();
			that.adjustIframeColumns();
			that.iframeLoadCallback(e);
			that.setFontSize();
			that.injectTheme();
			that.setNumPages();
			that.applyKeydownHandler();

            // Rationale: The assumption here is that if a hash fragment is specified, it is the result of Readium 
			//   following a clicked linked, either an internal link, or a link from the table of contents. The intention
			//   to follow a link should supersede restoring the last-page position, as this should only be done for the 
			//   case where Readium is re-opening the book, from the library view. 
			if (hashFragmentId) {

				that.goToHashFragment(hashFragmentId);
			}
			else if (lastPageElementId) {

				that.goToHashFragment(lastPageElementId);
			}
			else {

				if (goToLastPage) {

					that.pages.goToLastPage();
				}
				else {

					that.pages.goToPage(1);
				}		
			}
            
            
		});
        
		return [this.model.get("spine_position")];
	},

    // Description: return the set of currently-visible elements on this page. 
    // if strict is true, the elements must be entirely within the page
    // if strict is false, then elements must be partially within the page
    // used by media overlays
    findVisiblePageElements: function() {

        var $elements = $(this.getBody()).find("[id]");
        var doc = $("#readium-flowing-content").contents()[0].documentElement;
        var doc_top = 0;
        var doc_left = 0;
        var doc_right = doc_left + $(doc).width();
        var doc_bottom = doc_top + $(doc).height();
        
        var visibleElms = this.filterElementsByPosition($elements, doc_top, doc_bottom, doc_left, doc_right);
        return visibleElms;
    },
    
    // override
    // used by media overlays
	indicateMoIsPlaying: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
        var isPlaying = this.mediaOverlayController.get("state") == "playing";
        moHelper.renderReflowableMoPlaying(
			this.model.get("current_theme"),
            isPlaying,
			this
		);
	},

    // override
    // used by media overlays
	highlightText: function () {
        var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
        moHelper.renderReflowableMoFragHighlight(
			this.model.get("current_theme"),
			this,
			this.mediaOverlayController.get("mo_text_id")
		);
	},
    
    // sometimes we have to rehighlight if the page contents weren't fully loaded the first time
    flagRehighlight: function() {
        this.flagMoRehighlight = true; // this is a property of PaginationViewBase
    },
    
    // override
    // Description: return the set of all elements for this spine item that have an @id attribute.
    // used by media overlays
    getAllPageElementsWithId: function() {
        return $(this.getBody()).find("[id]");
    },
    
    
	// Description: navigate to a url hash fragment by calculating the page of
	//   the corresponding elem and setting the page number on `this.model`
	//   as precondition the hash fragment should identify an element in the
	//   section rendered by this view
	goToHashFragment: function(hashFragmentId) {

		// this method is triggered in response to 
		var fragment = hashFragmentId;
		if(fragment) {
			var el = $("#" + fragment, this.getBody())[0];

			if(!el) {
				// couldn't find the el. just give up
                return;
			}

			// we get more precise results if we look at the first children
			while (el.children.length > 0) {
				el = el.children[0];
			}

			var page = this.getElemPageNumber(el);
            if (page > 0) {
                this.pages.goToPage(page);	
			}
		}
		// else false alarm no work to do
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Sometimes these views hang around in memory before
	//   the GC's get them. we need to remove all of the handlers
	//   that were registered on the model
	destruct: function() {
		
		this.pages.off("change:current_page", this.pageChangeHandler);
		this.model.off("change:toc_visible", this.windowSizeChangeHandler);
		this.model.off("repagination_event", this.windowSizeChangeHandler);
		this.model.off("change:current_theme", this.windowSizeChangeHandler);
		this.model.off("change:two_up", this.setUpMode);
		this.model.off("change:two_up", this.adjustIframeColumns);
		this.model.off("change:current_margin", this.marginCallback);
		// call the super destructor
		Readium.Views.PaginationViewBase.prototype.destruct.call(this);
	},

	// TODO: Extend this to be correct for right-to-left pagination
	findVisibleTextNode: function () {

        var documentLeft = 0;
        var documentRight;
        var columnGap;
        var columnWidth;
        var doc;
        var $elements;
        var $firstVisibleTextNode;

		// Rationale: The intention here is to get a list of all the text nodes in the document, after which we'll
		//   reduce this to the subset of text nodes that is visible on the page. We'll then select one text node
		//   for which we can create a character offset CFI. This CFI will then refer to a "last position" in the 
		//   EPUB, which can be used if the reader re-opens the EPUB.
		// REFACTORING CANDIDATE: The "audiError" check is a total hack to solve a problem for a particular epub. This 
		//   issue needs to be addressed.
		$elements = $("body", this.getBody()).find(":not(iframe)").contents().filter(function () {
			if (this.nodeType === 3 && !$(this).parent().hasClass("audiError")) {
				return true;
			} else {
				return false;
			}
		});

        doc = $("#readium-flowing-content").contents()[0].documentElement;

        if (this.model.get("two_up")) {
        	columnGap = parseInt($(doc).css("-webkit-column-gap").replace("px",""));
        	columnWidth = parseInt($(doc).css("-webkit-column-width").replace("px",""));
        	documentRight = documentLeft + columnGap + (columnWidth * 2);
        } 
        else {
        	documentRight = documentLeft + $(doc).width();
        }

        // Find the first visible text node 
        $.each($elements, function() {

        	var POSITION_ERROR_MARGIN = 5;
        	var $textNodeParent = $(this).parent();
        	var elementLeft = $textNodeParent.position().left;
        	var elementRight = elementLeft + $textNodeParent.width();
        	var nodeText;

        	// Correct for minor right and left position errors
        	elementLeft = Math.abs(elementLeft) < POSITION_ERROR_MARGIN ? 0 : elementLeft;
        	elementRight = Math.abs(elementRight - documentRight) < POSITION_ERROR_MARGIN ? documentRight : elementRight;

        	// Heuristic to find a text node with actual text
        	nodeText = this.nodeValue.replace(/\n/g, "");
        	nodeText = nodeText.replace(/ /g, "");

        	if (elementLeft <= documentRight 
        		&& elementRight >= documentLeft
        		&& nodeText.length > 10) { // 10 is so the text node is actually a text node with writing

        		$firstVisibleTextNode = $(this);

        		// Break the loop
        		return false;
        	}
        });

        return $firstVisibleTextNode;
	},

	// Currently for left-to-right pagination only
	findVisibleCharacterOffset : function($textNode) {

		var $parentNode;
		var elementTop;
		var elementBottom;
		var POSITION_ERROR_MARGIN = 5;
		var $document;
		var documentTop;
		var documentBottom;
		var percentOfTextOffPage;
		var characterOffset;

		// Get parent
		$parentNode = $textNode.parent();

		// get document
		$document = $($("#readium-flowing-content").contents()[0].documentElement);

		// Find percentage of visible node on page
		documentTop = $document.position().top;
		documentBottom = documentTop + $document.height();

		elementTop = $parentNode.offset().top;
		elementBottom = elementTop + $parentNode.height();

		// Element overlaps top
		if (elementTop < documentTop) {

			percentOfTextOffPage = Math.abs(elementTop - documentTop) / $parentNode.height();
			characterOffsetByPercent = Math.ceil(percentOfTextOffPage * $textNode[0].length);
			characterOffset = Math.ceil(0.5 * ($textNode[0].length - characterOffsetByPercent)) + characterOffsetByPercent;
		}
		else if (elementTop >= documentTop && elementTop <= documentBottom) {
			characterOffset = 1;
		}
		else if (elementTop < documentBottom) {
			characterOffset = 1;
		}

		return characterOffset;
	},
    
    // returns all the elements in the set that are inside the box
    // separated this function from the one above in order to debug it
    // set strict to false to include elements that are partially inside the box
    // used by media overlays
    filterElementsByPosition: function($elements, documentTop, documentBottom, documentLeft, documentRight) {
        
        var $visibleElms = $elements.filter(function(idx) {
            var elm_top = $(this).offset().top;
            var elm_left = $(this).offset().left;
            var elm_right = elm_left + $(this).width();
            var elm_bottom = elm_top + $(this).height();
            
            var is_ok_x = elm_left >= documentLeft && elm_right <= documentRight;
            var is_ok_y = elm_top >= documentTop && elm_bottom <= documentBottom;
            
            return is_ok_x && is_ok_y;
        });  

        return $visibleElms;
    },
    
    // Description: Handles clicks of anchor tags by navigating to
	//   the proper location in the epub spine, or opening
	//   a new window for external links
	linkClickHandler: function (e) {
		e.preventDefault();

		var href;

		// Check for both href and xlink:href attribute and get value
		if (e.currentTarget.attributes["xlink:href"]) {
			href = e.currentTarget.attributes["xlink:href"].value;
		}
		else {
			href = e.currentTarget.attributes["href"].value;
		}

		// Resolve the relative path for the requested resource.
		href = this.resolveRelativeURI(href);
		if (href.match(/^http(s)?:/)) {
			window.open(href);
		} 
		else {
			this.model.goToHref(href);
		}
	},

	// Rationale: For the purpose of looking up EPUB resources in the package document manifest, Readium expects that 
	//   all relative links be specified as relative to the package document URI (or absolute references). However, it is 
	//   valid XHTML for a link to another resource in the EPUB to be specfied relative to the current document's
	//   path, rather than to the package document. As such, URIs passed to Readium must be either absolute references or 
	//   relative to the package document. This method resolves URIs to conform to this condition. 
	resolveRelativeURI: function (rel_uri) {
		var relativeURI = new URI(rel_uri);

		// Get URI for resource currently loaded in the view's iframe
		var iframeDocURI = new URI($("#readium-flowing-content").attr("src"));

		return relativeURI.resolve(iframeDocURI).toString();
	},

	applyKeydownHandler : function () {

		var that = this;

		this.$("#readium-flowing-content").contents().keydown(function (e) {

			if (e.which == 39) {
				that.model.paginator.v.pages.goRight();
			}
							
			if (e.which == 37) {
				that.model.paginator.v.pages.goLeft();
			}
		});
	},

	// REFACTORING CANDIDATE: I think this is actually part of the public interface
    goToPage: function(page) {
        // check to make sure we're not already on that page
        if (this.model.get("current_page") != undefined && this.model.get("current_page").indexOf(page) != -1) {
            return;
        }
		var offset = this.calcPageOffset(page).toString() + "px";
		$(this.getBody()).css(this.offset_dir, "-" + offset);
		this.showContent();
        
        // when we change the page, we have to tell MO to update its position
        // if the display now contains a new page
        if (this.model.get("two_up") == false || 
            (this.model.get("two_up") && page % 2 === 1)) {
                this.mediaOverlayController.updatePlaybackForReflowPageChange();
        }
	},

	setFontSize: function() {
		var size = this.model.get("font_size") / 10;
		$(this.getBody()).css("font-size", size + "em");

		// the content size has changed so recalc the number of 
		// pages
		this.setNumPages();
	},

	// Description: we are using experimental styles so we need to 
	//   use modernizr to generate prefixes
	stashModernizrPrefixedProps: function() {
		var cssIfy = function(str) {
			return str.replace(/([A-Z])/g, function(str,m1){ 
				return '-' + m1.toLowerCase(); 
			}).replace(/^ms-/,'-ms-');
		};

		// ask modernizr for the vendor prefixed version
		this.columAxis =  Modernizr.prefixed('columnAxis') || 'columnAxis';
		this.columGap =  Modernizr.prefixed('columnGap') || 'columnGap';
		this.columWidth =  Modernizr.prefixed('columnWidth') || 'columnWidth';

		// we are interested in the css prefixed version
		this.cssColumAxis =  cssIfy(this.columAxis);
		this.cssColumGap =  cssIfy(this.columGap);
		this.cssColumWidth =  cssIfy(this.columWidth);
	},

	getBodyColumnCss: function() {
		var css = {};
		css[this.cssColumAxis] = "horizontal";
		css[this.cssColumGap] = this.gap_width.toString() + "px";
		css[this.cssColumWidth] = this.page_width.toString() + "px";
		css["padding"] = "0px";
		css["margin"] = "0px";
		css["position"] = "absolute";
		css["width"] = this.page_width.toString() + "px";
		css["height"] = this.frame_height.toString() + "px";
		return css;
	},

	injectCFIElements : function () {

		var that = this;
		var contentDocument;
		var epubCFIs;
		var lastPageElementId;

		// Get the content document (assumes a reflowable publication)
		contentDocument = $("#readium-flowing-content").contents()[0];

		// TODO: Could check to make sure the document returned from the iframe has the same name as the 
		//   content document specified by the href returned by the CFI.

		// Inject elements for all the CFIs that reference this content document
		epubCFIs = this.model.get("epubCFIs");
		_.each(epubCFIs, function (cfi, key) {

			if (cfi.contentDocSpinePos === that.model.get("spine_position")) {

				try {
					
					EPUBcfi.Interpreter.injectElement(
						key, 
						contentDocument, 
						cfi.payload,
						["cfi-marker", "audiError"],
	  					[],
	  					["MathJax_Message"]);

					if (cfi.type === "last-page") {
						lastPageElementId = $(cfi.payload).attr("id");
					}
				} 
				catch (e) {

					console.log("Could not inject CFI");
				}
			}
		});

		// This will be undefined unless there is a "last-page" element injected into the page
		return lastPageElementId;
	},

	// Save position in epub
	savePosition : function () {

		var $visibleTextNode;
		var existingCFI;
		var lastPageMarkerExists = false;
		var characterOffset;
		var contentDocumentIdref;
		var packageDocument;
		var generatedCFI;

		// Get first visible element with a text node 
		$visibleTextNode = this.findVisibleTextNode();

		// Check if a last page marker already exists on this page
		try {
			$.each($visibleTextNode.parent().contents(), function () {

				if ($(this).hasClass("last-page")) {
					lastPageMarkerExists = true;
					existingCFI = $(this).attr("data-last-page-cfi");

					// Break out of loop
					return false;
				}
			});
		}
		catch (e) {

			console.log("Could not generate CFI for non-text node as first visible element on page");

			// No need to execute the rest of the save position method if the first visible element is not a text node
			return;
		}

		// Re-add the CFI for the marker on this page and shortcut the method
		// REFACTORING CANDIDATE: This shortcut makes this method confusing, it needs to be refactored for simplicity
		if (lastPageMarkerExists) {

			this.model.addLastPageCFI(existingCFI, this.model.get("spine_position"));
			this.model.save();
			return; 
		}

		characterOffset = this.findVisibleCharacterOffset($visibleTextNode);

		// Get the content document idref
		contentDocumentIdref = this.model.getCurrentSection().get("idref");

		// Get the package document
		// REFACTORING CANDIDATE: This is a temporary approach for retrieving a document representation of the 
		//   package document. Probably best that the package model be able to return this representation of itself.
        $.ajax({

            type: "GET",
            url: this.model.epub.get("root_url"),
            dataType: "xml",
            async: false,
            success: function (response) {

                packageDocument = response;
            }
        });

		// Save the position marker
		generatedCFI = EPUBcfi.Generator.generateCharacterOffsetCFI(
			$visibleTextNode[0], 
			characterOffset, 
			contentDocumentIdref, 
			packageDocument, 
			["cfi-marker", "audiError"], 
			[], 
			["MathJax_Message"]);

		this.model.addLastPageCFI(
			generatedCFI, 
			this.model.get("spine_position"));

		// Save the last page marker been added
		this.model.save();
	},

	adjustIframeColumns: function() {
		var prop_dir = this.offset_dir;
		var $frame = this.$('#readium-flowing-content');
		var page;

		this.setFrameSize();
		this.frame_width = parseInt($frame.width(), 10);
		this.frame_height = parseInt($frame.height(), 10);
		this.gap_width = Math.floor(this.frame_width / 7);
		if(this.model.get("two_up")) {
			this.page_width = Math.floor((this.frame_width - this.gap_width) / 2);
		}
		else {
			this.page_width = this.frame_width;
		}

		// it is important for us to make sure there is no padding or
		// margin on the <html> elem, or it will mess with our column code
		$(this.getBody()).css( this.getBodyColumnCss() );

		// If the first page is offset, adjust the window to only show one page
		if (this.model.get("two_up")) {
			
			var firstPageIsOffset = this.model.getCurrentSection().firstPageOffset();
			var firstPageOffsetValue;

			// Rationale: A current page of [0, 1] indicates that the current display is synthetic, and that 
			//   only the first page should be showing in that display
			// REFACTORING CANDIDATE: This logic is similar to that in pageChangeHandler
			var onFirstPage = 
				this.pages.get("current_page")[0] === 0 &&
			    this.pages.get("current_page")[1] === 1 
			    ? true : false;

			if (firstPageIsOffset && onFirstPage) {

				if (this.model.epub.get("page_prog_dir") === "rtl") {

					firstPageOffset = -(2 * (this.page_width + this.gap_width));
					$frame.css("margin-left", firstPageOffset + "px");
				}
				// Left-to-right pagination
				else {

					firstPageOffset = this.page_width + (this.gap_width * 2);
					$frame.css("margin-left", firstPageOffset + "px");
				}

				page = 1;

			}
			else {

				$frame.css("margin-left", "0px");
				page = this.pages.get("current_page")[0];
			}
		}
		else {

			$frame.css("margin-left", "0px");
			page = this.pages.get("current_page")[0];
		}

		this.setNumPages();
		this.goToPage(page);
	},

	// This is now part of the public interface
	// Description: helper method to get the a reference to the documentElement
	// of the document in this strategy's iFrame.
	// TODO: this is a bad name for this function
	getBody: function() {
		return this.$('#readium-flowing-content').contents()[0].documentElement;
	},

	hideContent: function() {
		$("#flowing-wrapper").css("opacity", "0");
	},

	showContent: function() {
		$("#flowing-wrapper").css("opacity", "1");
	},

	calcPageOffset: function(page_num) {
		return (page_num - 1) * (this.page_width + this.gap_width);
	},

	// Rationale: on iOS frames are automatically expanded to fit the content dom
	// thus we cannot use relative size for the iframe and must set abs 
	// pixel size
	setFrameSize: function() {
		var width = this.getFrameWidth().toString() + "px";
		var height = this.getFrameHeight().toString() + "px";

		this.$('#readium-flowing-content').attr("width", width);
		this.$('#readium-flowing-content').attr("height", height);
		this.$('#readium-flowing-content').css("width", width);
		this.$('#readium-flowing-content').css("height", height);
	},

	getFrameWidth: function() {
		var width;
		var margin = this.model.get("current_margin");
		if (margin === 1) {
			this.model.get("two_up") ? (width = 0.95) : (width = 0.90);
		}
		else if (margin === 2) {
			this.model.get("two_up") ? (width = 0.89) : (width = 0.80);
		}
		else if (margin === 3) {
			this.model.get("two_up") ? (width = 0.83) : (width = 0.70);	
		}
		else if (margin === 4) {
			this.model.get("two_up") ? (width = 0.77) : (width = 0.60);	
		}
		else {
			this.model.get("two_up") ? (width = 0.70) : (width = 0.50);	
		}
		
		return Math.floor( $('#flowing-wrapper').width() * width );
	},

	getFrameHeight: function() {
		return $('#flowing-wrapper').height();
	},

	// Description: calculate the number of pages in the current section,
	//   based on section length : page size ratio
	calcNumPages: function() {

		var body, offset, width, num;
		
		// get a reference to the dom body
		body = this.getBody();

		// cache the current offset 
		offset = body.style[this.offset_dir];

		// set the offset to 0 so that all overflow is part of
		// the scroll width
		body.style[this.offset_dir] = "0px";

		// grab the scrollwidth => total content width
		width = this.getBody().scrollWidth;

		// reset the offset to its original value
		body.style[this.offset_dir] = offset;

		// perform calculation and return result...
		num = Math.floor( (width + this.gap_width) / (this.gap_width + this.page_width) );

		// in two up mode, always set to an even number of pages
		if( num % 2 === 0 && this.model.get("two_up")) {
			//num += 1;
		}
		return num;
	},

    getElemPageNumber: function(elem) {
		
		var $elem;
		var elemWasInvisible = false;
		var rects, shift;
		var elemRectWidth;

		// Rationale: Elements with an epub:type="pagebreak" attribute value are likely to be set as 
		//   display:none, as they indicate the end of a page in the corresponding physical version of a book. We need 
		//   the position of these elements to get the reflowable page number to set in the viewer. Therefore, 
		//   we check if the element has this epub:type value, set it visible, find its location and then set it to 
		//   display:none again. 
		// REFACTORING CANDIDATE: We might want to do this for any element with display:none. 
		$elem = $(elem);
		if ($elem.attr("epub:type") === "pagebreak" && !$elem.is(":visible")) {

			elemWasInvisible = true;
			$elem.show();
		}

		rects = elem.getClientRects();
		if(!rects || rects.length < 1) {
			// if there were no rects the elem had display none
			return -1;
		}

		shift = rects[0][this.offset_dir];

		// calculate to the center of the elem
		// Rationale: The -1 or +1 adjustment is to account for the case in which the target element for which the shift offset
		//   is calculated is at the edge of a page and has 0 width. In this case, if a minor arbitrary adjustment is not applied, 
		//   the calculated page number will be off by 1.   
		elemRectWidth = rects[0].left - rects[0].right;
		if (this.offset_dir === "right" && elemRectWidth === 0) {
			shift -= 1;
		}
		else if (this.offset_dir === "left" && elemRectWidth === 0) {
			shift += 1;
		} // Rationale: There shouldn't be any other case here. The explict second (if else) condition is for clarity.
		shift += Math.abs(elemRectWidth);
		
        // Re-hide the element if it was original set as display:none
        if (elemWasInvisible) {
            $elem.hide();
        }

		// `clientRects` are relative to the top left corner of the frame, but
		// for right to left we actually need to measure relative to right edge
		// of the frame
		if(this.offset_dir === "right") {
			// the right edge is exactly `this.page_width` pixels from the right 
			// edge
			shift = this.page_width - shift;
		}
		// less the amount we already shifted to get to cp
		shift -= parseInt(this.getBody().style[this.offset_dir], 10); 
		return Math.ceil( shift / (this.page_width + this.gap_width) );
	},

	// REFACTORING CANDIDATE: This might be part of the public interface
	getElemPageNumberById: function(elemId) {
        var doc = $("#readium-flowing-content").contents()[0].documentElement;
        // escape periods for jquery
        var elem = $(doc).find("#" + elemId.replace(".", "\\."));
        if (elem.length == 0) {
            return -1;
        }
        else {
            return this.getElemPageNumber(elem[0]);
        }
    },

	pageChangeHandler: function() {
        var that = this;
		this.hideContent();
		setTimeout(function() {
            
			var $reflowableIframe = that.$("#readium-flowing-content");
            if (that.model.get("two_up")) {
				// If the first page is offset, adjust the window to only show one page
				var firstPageIsOffset = that.model.getCurrentSection().firstPageOffset();
				var firstPageOffsetValue;

				// Rationale: A current page of [0, 1] indicates that the current display is synthetic, and that 
				//   only the first page should be showing in that display
				var onFirstPage = 
					that.pages.get("current_page")[0] === 0 &&
				    that.pages.get("current_page")[1] === 1 
				    ? true : false;

				if (firstPageIsOffset && onFirstPage) {

					if (that.model.epub.get("page_prog_dir") === "rtl") {

						firstPageOffset = -(2 * (that.page_width + that.gap_width));
						$reflowableIframe.css("margin-left", firstPageOffset + "px");
					}
					// Left-to-right pagination
					else {

						firstPageOffset = that.page_width + (that.gap_width * 2);
						$reflowableIframe.css("margin-left", firstPageOffset + "px");
					}
                    that.goToPage(1);
				}
				else {

					$reflowableIframe.css("margin-left", "0px");
                    that.goToPage(that.pages.get("current_page")[0]);
				}
			}
			else {

				$reflowableIframe.css("margin-left", "0px");
                that.goToPage(that.pages.get("current_page")[0]);
			}
            that.savePosition();

		}, 150);
	},

	windowSizeChangeHandler: function() {
		this.adjustIframeColumns();
		
		// Make sure we return to the correct position in the epub (This also requires clearing the hash fragment) on resize.
		this.goToHashFragment(this.model.get("hash_fragment"));
	},
    
	marginCallback: function() {
		this.adjustIframeColumns();
	},

	// Rationale: sadly this is just a reprint of what is already in the
	//   themes stylesheet. It isn't very DRY but the implementation is
	//   cleaner this way
	themes: {
		"default-theme": {
			"background-color": "white",
			"color": "black",
			"mo-color": "#777"
		},

		"vancouver-theme": {
			"background-color": "#DDD",
			"color": "#576b96",
			"mo-color": "#777"
		},

		"ballard-theme": {
			"background-color": "#576b96",
			"color": "#DDD",
			"mo-color": "#888"
		},

		"parchment-theme": {
			"background-color": "#f7f1cf",
			"color": "#774c27",
			"mo-color": "#eebb22"
		},

		"night-theme": {
			"background-color": "#141414",
			"color": "white",
			"mo-color": "#666"
		}
	},

	injectTheme: function() {
		var theme = this.model.get("current_theme");
		if(theme === "default") theme = "default-theme";
		$(this.getBody()).css({
			"color": this.themes[theme]["color"],
			"background-color": this.themes[theme]["background-color"]
		});
		
		// stop flicker due to application for alternate style sheets
		// just set content to be invisible
		$("#flowing-wrapper").css("visibility", "hidden");
		this.activateEPubStyle(this.getBody());

		// wait for new stylesheets to parse before setting back to visible
		setTimeout(function() {
			$("#flowing-wrapper").css("visibility", "visible");	
		}, 100);
	},

	setNumPages: function() {
		var num = this.calcNumPages();
		this.pages.set("num_pages", num);
	}
});
Readium.Views.ScrollingPaginationView = Readium.Views.PaginationViewBase.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {
		// call the super ctor
		Readium.Views.PaginationViewBase.prototype.initialize.call(this, options);
		this.page_template = Handlebars.templates.scrolling_page_template;
	},

	render: function() {
		var that = this;
		var json = this.model.getCurrentSection().toJSON();
		this.$('#container').html( this.page_template(json) );
		
		this.$('.content-sandbox').on("load", function(e) {
// Important: Firefox doesn't recognize e.srcElement, so this needs to be checked for whenever it's required.
if (!e.srcElement) e.srcElement = this;

			that.iframeLoadCallback(e);
		});

		return [this.model.get("spine_position")];
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: sometimes these views hang around in memory before
	//   the GC's get them. we need to remove all of the handlers
	//   that were registered on the model
	destruct: function() {
		// call the super destructor
		Readium.Views.PaginationViewBase.prototype.destruct.call(this);
	}
});
Readium.Views.ToolbarView = Backbone.View.extend({

	el: "#toolbar-el",

	initialize: function() {
		this.model.on("change:toolbar_visible", this.renderBarVisibility, this);
		this.model.on("change:full_screen", this.renderFullScreen, this);
		this.model.on("change:current_theme", this.renderThemeButton, this);
        this.model.on("change:spine_position", this.renderMoButtons, this);
        
        var moController = this.model.get("media_overlay_controller");
        moController.on("change:volume", this.renderVolumeButton, this);
        moController.on("change:rate", this.renderRateButton, this);  
	},

	render: function() {
		this.renderBarVisibility();
		this.renderFullScreen();
		this.renderThemeButton();
		this.renderTitle();
		return this;
	},

	renderBarVisibility: function() {
		var visible = this.model.get("toolbar_visible");
		this.$('#show-toolbar-button').toggle( !visible );
		this.$('#toolbar-title').toggle( !visible );
		this.$('#top-bar').toggle( visible );
		return this;
	},

	renderFullScreen: function() {
		var isFs = this.model.get("full_screen");
		this.$("#go-to-fs-ico").toggle( !isFs );
		this.$("#leave-fs-ico").toggle( isFs );
		$('#fs-toggle-btn').attr('title', isFs ? 'Fullscreen on' : 'Fullscreen off');
		$('#fsOT').html(isFs ? 'Fullscreen on' : 'Fullscreen off');
		return this;
	},

	renderThemeButton: function() {
		var isNight = this.model.get("current_theme") === "night-theme";
		this.$('#night-to-day-ico').toggle(isNight);
		this.$('#day-to-night-ico').toggle(!isNight);
		$('#nightmode-btn').attr('title', isNight ? 'Nightmode on' : 'Nightmode off');
		$('#nmOT').html(isNight ? 'Nightmode on' : 'Nightmode off');
		return this;
	},

	renderTitle: function() {
		var title = this.model.epub.get("title");
		this.$('#toolbar-title').html(title);
		return this;
	},
    
    renderMoButtons: function() {
        if (this.model.getCurrentSection().hasMediaOverlay()) {
            $("#play-mo-btn").show();
            $("#mo-volume-btn-group").show();
            $("#mo-rate-btn-group").show();
            $("#mo-volume-slider-OT").show();
            $("#mo-rate-slider-OT").show();
            this.renderVolumeButton();
            this.renderRateButton();
        }
        else {
            $("#play-mo-btn").hide();
            $("#mo-volume-btn-group").hide();
            $("#mo-rate-btn-group").hide();
            $("#mo-volume-slider-OT").hide();
            $("#mo-rate-slider-OT").hide();
        }
    },
    
    renderVolumeButton: function() {
        var moController = this.model.get("media_overlay_controller");
        var value = moController.get("volume");
        $("#mo-volume-slider").val(value);
        
        var isMuted = moController.get("volume") == 0;
        this.$('#mo-volume-btn').toggle(!isMuted);
    	this.$('#mo-volume-muted-btn').toggle(isMuted);
    },
    
    renderRateButton: function() {
        var moController = this.model.get("media_overlay_controller");
        var value = moController.get("rate");
        $("#mo-rate-slider").val(value);
    },
    
	events: {
		"click #hide-toolbar-button": "hide_toolbar",
		"click #show-toolbar-button": "show_toolbar",
		"click #fs-toggle-btn": "toggle_fs",
		"click #toggle-toc-btn": "toggle_toc",
		"click #nightmode-btn": "toggle_night_mode",
		"click #play-mo-btn": "play_mo",
        "change #mo-volume-slider": "set_mo_volume",
        "click #mo-volume-btn": "mute_mo",
        "click #mo-volume-muted-btn": "mute_mo",
        "change #mo-rate-slider": "set_mo_rate",
        "click #mo-rate-btn": "reset_mo_rate"
	},

	show_toolbar: function(e) {
		e.preventDefault();
		this.model.set("toolbar_visible", true);
	},

	hide_toolbar: function(e) {
		e.preventDefault();
		this.model.set("toolbar_visible", false);
	},

	toggle_fs: function(e) {
		e.preventDefault();
		this.model.toggleFullScreen();
	},

	toggle_toc: function(e) {
		e.preventDefault();
		this.model.toggleToc();
	},

	toggle_night_mode: function() {
		var current_theme = this.model.get("current_theme");
		if(current_theme === "night-theme") {
			this.model.set("current_theme", "default-theme");
		}
		else {
			this.model.set("current_theme", "night-theme");
		}
		this.model.save();
	},

    // toggle play/pause
	play_mo: function() {
        var moController = this.model.get("media_overlay_controller");
		if (moController.get("state") == "playing") {
            moController.pauseMo();
		}
		else {
			moController.playMo(true);
        }
	},
    
    set_mo_volume: function() {
        var slider = $("#mo-volume-slider");
        var value = parseFloat(slider.val()).toFixed(1); 
        var moController = this.model.get("media_overlay_controller");
        moController.set("volume", value);
        slider.attr("aria-valuenow", value);
    },
    
    mute_mo: function() {
        var moController = this.model.get("media_overlay_controller");
        // this function toggles between mute and unmute
        moController.mute();
    },
    
    set_mo_rate: function() {
        var slider = $("#mo-rate-slider");
        var value = parseFloat(slider.val()).toFixed(1); 
        var moController = this.model.get("media_overlay_controller");
        moController.set("rate", value);
        slider.attr("aria-valuenow", value);
    },
    
    reset_mo_rate: function() {
        var moController = this.model.get("media_overlay_controller");
        moController.resetRate();
    }
    
});
Readium.Views.TocViewBase = Backbone.View.extend({

	el: "#readium-toc",

	initialize: function() {
		this.model.on("change", this.render, this);
		this.model.on("change:visible", this.setVisibility, this);
	},

	events: {
		"click a": "handleClick",
		"click #close-toc-button": "closeToc"
	},

	setVisibility: function() {
		this.$el.toggle(this.model.get("visible"));
	},

	handleClick: function(e) {
		e.preventDefault();
		href = $(e.currentTarget).attr("href");
		this.model.handleLink(href);
	},

	handleSelect : function (e) {

		var href = e.val;
		this.model.handleLink(href);
	},

	closeToc: function(e) {
		e.preventDefault();
		this.model.hide();
	}
});


Readium.Views.NcxTocView = Readium.Views.TocViewBase.extend({ 

	initialize: function() {
		Readium.Views.TocViewBase.prototype.initialize.call(this);
		this.nav_template = Handlebars.templates.ncx_nav_template;
	},

	render: function() {

		var ol;

		this.setVisibility();

		// Construct html for the navPoints in the document		
		ol = this.addNavPointElements(this.model.get("navs"));

		this.$('#toc-body').html("<h2 tabindex='-1'>" + (this.model.get("title") || "Contents") + "</h2>")
		this.$('#toc-body').append(ol);
		this.$('#toc-body').append("<div id='toc-end-spacer'>");
		return this;
	},

	// Description: Constructs an html representation of NCX navPoints, based on an object of navPoint information
	// Rationale: This is a recursive method, as NCX navPoint elements can nest 0 or more of themselves as children
	addNavPointElements: function (jsonNavs) {

		var ol = $("<ol></ol>");
		var that = this;

		$.each(jsonNavs, function (navIndex) {

			var hasNavs;

			// Add the current navPoint element to the TOC html 
			ol.append( that.nav_template(jsonNavs[navIndex]) );

			// Check if the current navPoint has navPoints of its own
			hasNavs = jsonNavs[navIndex].navs.length > 0 ? true : false;
			if (hasNavs) {

				var li = $("<li></li>");
				li.append(that.addNavPointElements(jsonNavs[navIndex].navs));
				ol.append(li);
			}
		});

		return ol; 
	}
});

Readium.Views.XhtmlTocView = Readium.Views.TocViewBase.extend({ 

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	events : {

		"click a": "handleClick",
		"click #close-toc-button": "closeToc",
		"change #toc-body" : "handleSelect"
	},

	render: function() {
			
		this.$('#toc-body').html( this.model.get("body").html() );
		this.formatPageListNavigation();
		this.$('#toc-body').append("<div id='toc-end-spacer'>");
		return this;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	formatPageListNavigation : function () {

		var $navElements;
		var $pageListNavElement;
		var pageListData = [];

		// Search for a nav element with epub:type="page-list". A nav element of this type must not occur more than once.
		$navElements = this.$("nav");
		$pageListNavElement = $navElements.filter(function () {

			if ($(this).attr("epub:type") === 'page-list') {

				// Hide the standard XHTML page-list nav element, as we'll be displaying a select2 drop-down control for this.
				$(this).attr("id", "page-list-select");
				$(this).hide();
				return true;
			}
		});

		// Each nav element has a single ordered list of page numbers. Extract this data into an array so it can be 
		//   loaded in the page-list control
		// TODO: span elements can be used to create sub-headings. Implement functionality to account for this at some point.
		$.each($('a', $pageListNavElement), function () { 

			var $navTarget = $(this);
			pageListData.push({

				id : $navTarget.attr("href"),
				text : "Page-" + $navTarget.text()
			});
		});

		// Create the select2 control
		$("#page-list-select").select2({

			placeholder : "Select a page",
			data : pageListData
		});

		// the select2 adds no-op inline click handlers, but these are not allowed
		// by chromes content securty policy so just remove them
		this.$('[onclick]').removeAttr('onclick');
	}
});
Readium.Views.OptionsView = Backbone.View.extend({

	el: '#viewer-settings-modal',

	initialize: function() {
		this.model.on("change:current_theme", this.renderTheme, this);
		this.model.on("change:two_up", this.renderUpMode, this);
		this.model.on("change:current_margin", this.renderMarginRadio, this);
		this.model.on("change:font_size", this.renderFontSize, this);
		var that = this;
		Acc.rg = {
			theme: new Acc.RadioGroup('theme-radio-group', ' .' + this.model.get("current_theme"), function(el){
				var id = el.id;
				if(id === "default-theme-option" ) that.model.set("current_theme", "default-theme");
				if(id === "night-theme-option" ) that.model.set("current_theme", "night-theme");
				if(id === "parchment-theme-option" ) that.model.set("current_theme", "parchment-theme");
				if(id === "ballard-theme-option" ) that.model.set("current_theme", "ballard-theme");
				if(id === "vancouver-theme-option" ) that.model.set("current_theme", "vancouver-theme");
			}),

			format: new Acc.RadioGroup('two-up-options', this.model.get("two_up") ? ' #two-up-option' : ' #one-up-option', function(el){
				if (el.id == 'one-up-option')
					that.model.set("two_up", false);
				else if (el.id == 'two-up-option')
					that.model.set("two_up", true);
			}),

			margin: new Acc.RadioGroup('margin-radio-wrapper', ' #margin-option-' + this.model.get("current_margin"), function(el){
				var id = el.id,
				num = id[id.length - 1];
				if(num === "1" ) that.model.set("current_margin", 1);
				if(num === "2" ) that.model.set("current_margin", 2);
				if(num === "3" ) that.model.set("current_margin", 3);
				if(num === "4" ) that.model.set("current_margin", 4);
				if(num === "5" ) that.model.set("current_margin", 5);
			})
		};

		$('#options-btn').attr('aria-pressed', 'false');
		$('#viewer-settings-modal').on('shown', function(){
			$('#setting-header-font-size').focus();
			setTimeout( function() {
				$('#options-btn').attr('aria-pressed', 'true');
			}, 1);
		}).on('hidden', function(){
			setTimeout( function(){
				$('#options-btn').attr('aria-pressed', 'false').focus();
			}, 1);
		});
	},

	render: function() {
		this.renderTheme();
		this.renderUpMode();
		this.renderMarginRadio();
		this.renderFontSize();
		return this;
	},

	renderTheme: function() {
		this.$('#preview-text')[0].className = this.model.get("current_theme");
		return this;
	},

	renderUpMode: function() {
		var twoUp = this.model.get("two_up");
		this.$("#one-up-option").toggleClass("selected", !twoUp);
		this.$("#two-up-option").toggleClass("selected", twoUp);
		return this;
	},

	renderMarginRadio: function() {
		var id = "#margin-option-" + this.model.get("current_margin");
		this.$('.margin-radio').toggleClass("selected", false);
		this.$(id).toggleClass("selected", true);
		return this;
	},

	renderFontSize: function() {
		var val = this.model.get("font_size");
		var size = (val / 10).toString() + "em";

		// apply the size to the preview text area
		this.$('#preview-text').css("font-size", size);

		// set the value of the slider
		this.$("#font-size-input").val(val);
	},

	events: {
    	"click .theme-option": 			"selectTheme",
    	"click .margin-radio": 			"selectMargin",
    	"click #cancel-settings-but": 	"cancelSettings",
		"click #save-settings-but": 	"applySettings",
    	"change #font-size-input": 		"extractFontSize",
    	"click #one-up-option": 		"setOneUp",
		"click #two-up-option": 		"setTwoUp"
  	},

  	extractFontSize: function(e) {
		var val = $("#font-size-input").val();
		val = parseInt(val, 10);
		this.model.set("font_size", val);
	},

  	setOneUp: function(e) {
		if (Acc.rg && Acc.rg.format) Acc.rg.format.set('one-up-option');
		this.model.set("two_up", false);
		e.stopPropagation();
	},

	setTwoUp: function(e) {
		if (Acc.rg && Acc.rg.format) Acc.rg.format.set('two-up-option');
		this.model.set("two_up", true);
		e.stopPropagation();
	},

  	selectTheme: function(e) {
  		var id = e.srcElement ? e.srcElement.id : '';
		if(id && e.srcElement && Acc.rg && Acc.rg.theme && e.srcElement != Acc.rg.theme.selected) Acc.rg.theme.set(id);
  		if(id === "default-theme-option" ) this.model.set("current_theme", "default-theme");
		if(id === "night-theme-option" ) this.model.set("current_theme", "night-theme");
		if(id === "parchment-theme-option" ) this.model.set("current_theme", "parchment-theme");
		if(id === "ballard-theme-option" ) this.model.set("current_theme", "ballard-theme");
		if(id === "vancouver-theme-option" ) this.model.set("current_theme", "vancouver-theme");
		e.stopPropagation();
  	},

  	selectMargin: function(e) {
  		var id = e.srcElement.id;
		if (e.srcElement && Acc.rg && Acc.rg.margin && e.srcElement != Acc.rg.margin.selected) Acc.rg.margin.set(id);
  		var num = id[id.length - 1];
  		if(num === "1" ) this.model.set("current_margin", 1);
		if(num === "2" ) this.model.set("current_margin", 2);
		if(num === "3" ) this.model.set("current_margin", 3);
		if(num === "4" ) this.model.set("current_margin", 4);
		if(num === "5" ) this.model.set("current_margin", 5);
		e.stopPropagation();
  	},

  	cancelSettings: function(e) {
  		this.$el.modal('hide');
  		this.model.resetOptions();
		$('#options-btn').focus();
  	},

  	applySettings: function(e) {
  		this.model.applyOptions();
  		this.$el.modal('hide');
		$('#options-btn').focus();
  	}


});
// Fixed layout books may have pages that are bigger of smaller than allowed 
// by the viewport. Thus we need to scale the book holding `div` in order to
// if the book to the screen.
Readium.Views.FixedLayoutBookZoomer = Backbone.View.extend({

	el: "#readium-right-content",

	// total amount of space to leave around the pages after calling
	// `fitToWidth` / `fitToHeight`
	horizontalPad: 30,
	verticalPad: 30,

	initialize: function() {
		this.zoomingModel = new Readium.Models.FixedLayoutBookZoomingModel();
	},

	/* ------------------------------------------------------------------------------------ */
  	//  "PUBLIC" METHODS (THE API)                                                          //
  	/* ------------------------------------------------------------------------------------ */

	// apply the current transformations held in this views `BookZoomingModel` to
	// the `el`
	render: function() {
		this.$("#page-wrap").css(this.zoomingModel.getCSSProperties());
		return this;
	},

	// remove any tranformations that have been applied to this `el`
	reset: function() {
		this.zoomingModel.setDefaults();
		this.render();
	},

	// apply the minimum scalar transormation to the div wrapping this books pages
	// in order to have all content displayed 
	fitToBest: function() {
		var widthScale = this.fitToWidthScale();
		var heightScale = this.fitToHeightScale();

		if(widthScale < heightScale) {
			this.applyScale(widthScale);
		}
		else {
			this.applyScale(heightScale);
		}
	},

	// apply transformations that fit the books pages as best as possible linearly
	fitToWidth: function() {
		var scale = this.fitToWidthScale();
		this.applyScale(scale);
	},

	// apply transformations that fit the books pages as best as possible veritcally
	fitToHeight: function() {
		var scale = this.fitToHeightScale();
		this.applyScale(scale);
	},

	
	/* ------------------------------------------------------------------------------------ */
	//  "PRIVATE" HELPERS                                                                   //
	/* ------------------------------------------------------------------------------------ */

	fitToWidthScale: function() {
		return (this.containerWidth() - this.horizontalPad) / this.bookWidth();
	},

	fitToHeightScale: function() {
		return (this.containerHeight() - this.verticalPad) / this.bookHeight();
	},

	applyScale: function(scale) {
		this.zoomingModel.set("scale", scale);
		this.zoomingModel.set("leftShift", this.leftShift(scale));
		this.zoomingModel.set("topShift", this.verticalPad / 2);
		this.render();
	},

	// calculate the amount of left shift required to center the book's pages
	// after applying a given scale transormation
	leftShift: function(scale) {
		var width = this.containerWidth();
		return (width - (this.bookWidth() * scale)) / 2;
	},

	containerWidth: function() {
		return this.$el.width();
	},

	containerHeight: function() {
		return this.$el.height() ;
	},

	bookWidth: function() {
		return this.$("#page-wrap").width();
	},

	bookHeight: function() {
		return this.$("#page-wrap").height();
	}

});


Readium.Models.FixedLayoutBookZoomingModel = Backbone.Model.extend({

	initialize: function() {

		// get the browser vendor prefixed attrs one time, rather than
		// every time we render
		this.styleAttrs = this.getModernizedAttrs();

	},

	defaults: {
		scale: 1,
		leftShift: 0,
		topShift: 0
	},

	setDefaults: function() {
		this.set(this.defaults);
	},

	getModernizedAttrs: function() {
		var attrs = {};
		attrs.transform = this.modernizrCssPrefix("transform");
		attrs.transformOrigin = this.modernizrCssPrefix("transformOrigin");
		return attrs;
	},

	modernizrCssPrefix: function(attr) {
		var str = Modernizr.prefixed(attr);
		return str.replace(/([A-Z])/g, function(str, m1){ 
			return '-' + m1.toLowerCase(); 
		}).replace(/^ms-/,'-ms-');
	},


	getCSSProperties: function() {
		var css = {};
		css[this.styleAttrs.transform] = this.getTransformString();
		css[this.styleAttrs.transformOrigin] = "0 0";
		return css;
	},

	getTransformString: function() {

		str  = "";
		str += "translate(" + this.get("leftShift") + "px, " + this.get("topShift") + "px) ";
		str += "scale(" + this.get("scale").toString() + ")";
		return str;
	}

});
// REFACTORING CANDIDATE: Parts of this model are making calls to the current view through the epubController->paginator->view->etc., 
//   that is a lot of indirection. Perhaps epubController shouldn't be at the centre of this model anymore.

Readium.Views.ViewerApplicationView = Backbone.View.extend({
	el: 'body',

	uiVisible: false,

	initialize: function() {
		
		this.model.on("change:full_screen", this.toggleFullscreen, this);

		this.model.on("change:current_theme", this.renderTheme, this);
		this.model.on("change:toolbar_visible", this.renderPageButtons, this);
		this.model.on("change:toc_visible", this.renderTocVisible, this);

		this.optionsPresenter = new Readium.Models.OptionsPresenter({
			book: this.model
		});
		this.optionsView = new Readium.Views.OptionsView({model: this.optionsPresenter});
		this.optionsView.render();

		// the top bar
		this.toolbar = new Readium.Views.ToolbarView({model: _epubController});
		this.toolbar.render();

		// the table of contents
		this.model.on("change:has_toc", this.init_toc, this);

		this.addGlobalEventHandlers();

$('#bar-logo').attr('aria-pressed', 'false');
$('#readium-info').on('shown', function(){
$('#version-info').focus();
setTimeout(function(){
$('#bar-logo').attr('aria-pressed', 'true');
}, 1);
})
.on('hidden', function(){
setTimeout(function(){
$('#bar-logo').attr('aria-pressed', 'false').focus();
}, 1);
});

Acc.title = this.model.get('title') + ', by ' + this.model.get('author');

	},

	toggleFullscreen: function() {
		if(this.model.get("full_screen")) {
			document.documentElement.webkitRequestFullScreen();	
		}
		else {
			document.webkitCancelFullScreen();				
		}
	},

	addGlobalEventHandlers: function() {
		var book = this.model;
		var that = this;
		window.onresize = function(event) {
			book.trigger("repagination_event");
		}

		$(document).keydown(function(e) {
            // right arrow
            if(e.which == 39) {
				that.model.paginator.v.pages.goRight();
			}
			
            // left arrow	
			if(e.which == 37) {
				that.model.paginator.v.pages.goLeft();
			}
            
            // Control over media overlays rate and volume
            // keyboard shortcuts improve slider accessibility
                        
            // F7
            if (e.which == 118 && !e.shiftKey) {
                that.model.get("media_overlay_controller").increaseVolume();
            }
            
            // Shift + F7
            if (e.which == 118 && e.shiftKey) {
                that.model.get("media_overlay_controller").decreaseVolume();
            }
            
            // F9
            if (e.which == 120 && !e.shiftKey) {
                that.model.get("media_overlay_controller").increaseRate();
            }
            
            // Shift + F9
            if (e.which == 120 && e.shiftKey) {
                that.model.get("media_overlay_controller").decreaseRate();
            }            
		});

		$("#readium-book-view-el").on("swipeleft", function(e) {
			e.preventDefault();
			that.model.paginator.v.pages.goRight();
			
		});

		$("#readium-book-view-el").on("swiperight", function(e) {
			e.preventDefault();
			that.model.paginator.v.pages.goLeft();
		});
	},

	render: function() {
		// right now we dont do anything but 
		// convention is to return this from render
		this.renderTheme();
		this.renderPageButtons();
		this.renderTocVisible();
		return this; 
	},

	renderPageButtons: function() {
		var vis = this.model.get("toolbar_visible");
		this.$("#prev-page-button").toggle(vis);
		this.$("#next-page-button").toggle(vis);
		return this;
	},

	renderTheme: function() {
		var theme = this.model.get("current_theme");
		this.$el.toggleClass("default-theme", "default-theme" === theme);
		this.$el.toggleClass("night-theme", "night-theme" === theme);
		this.$el.toggleClass("parchment-theme", "parchment-theme" === theme);
		this.$el.toggleClass("ballard-theme", "ballard-theme" === theme);
		this.$el.toggleClass("vancouver-theme", "vancouver-theme" === theme);

		this.$("#readium-book-view-el").toggleClass("default-theme", "default-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("night-theme", "night-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("parchment-theme", "parchment-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("ballard-theme", "ballard-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("vancouver-theme", "vancouver-theme" === theme);
	},

	renderTocVisible: function() {
var vis = this.model.get("toc_visible");
$('#toggle-toc-btn').attr('aria-pressed', vis ? 'true' : 'false');
		this.$el.toggleClass("show-readium-toc", vis);
if (vis) setTimeout(function(){
$('#readium-toc').find('h1, h2').first()
.attr('tabindex', '-1').focus();
}, 500);
else $('#toggle-toc-btn').focus();
		return this;
	},

	init_toc: function() {
		if( this.model.get("has_toc") ) {
			var toc_item = this.model.getToc();			
			this.toc = toc_item.TocView();
			toc_item.fetch();

		}
	},	
	
	events: {
		"click #prev-page-button": 	function() { 
			this.model.paginator.v.pages.goLeft();
		},
		"click #next-page-button": 	function() { 
			this.model.paginator.v.pages.goRight();
		}
  	}
});
// This is the router used by the web served version of readium
// This router is used in the book view of the chrome extension build of readium
Readium.Routers.ViewerRouter = Backbone.Router.extend({

	routes: {
		"viewer.html?book=:key": "openBook",
		"*splat": "splat_handler"
	},

	openBook: function(key) {

		// look up the book by its key in the global array or library data
		var book_data = _.find(window.ReadiumLibraryData, function(obj) {
			return obj.key === key;
		});

		if(book_data) {
			// initialze the viewer for that book
			window._epub = new Readium.Models.EPUB(book_data);
			window._epubController = new Readium.Models.EPUBController(_.extend({epub : window._epub}, book_data));
			window._applicationView = new Readium.Views.ViewerApplicationView({
				model: window._epubController
			});
			window._applicationView.render();
		}
		else {
			// did not find the book in our library
			alert("The book you requested does not exist");
		}

	},

	splat_handler: function(splat) {
		console.log(splat)
	}

});
// Description: This model is responsible for the read-only attributes and content of an epub. 
// Rationale: This is designed as a model to represent the state of an epub as it is maintained by the Readium application.
//   As Readium does not have any authoring capabilities (a saved epub is not modified), this model essentially represents the 
//   epub in a read-only fashion (although this is not enforced).

Readium.Models.EPUB = Backbone.Model.extend({

	defaults: {
    	"can_two_up": true
  	},

  	// ------------------------------------------------------------------------------------ //
  	//  "PUBLIC" METHODS (THE API)                                                          //
  	// ------------------------------------------------------------------------------------ //

	initialize: function() {

		// capture context for use in callback functions
		var that = this;

		// intantiate a [`PackageDocument`](/docs/packageDocument.html)
		this.packageDocument = new Readium.Models.PackageDocument({ 
			book : this, 
			file_path : this.get("package_doc_path") 
			});
	},

	getPackageDocument: function () {

		return this.packageDocument;
	},

  	toJSON: function() {

  		// only save attrs that should be persisted:
  		return {
			"apple_fixed": this.get("apple_fixed"),
			"author": this.get("author"),
			"cover_href": this.get("cover_href"),
			"created_at": this.get("created_at"),
			"description": this.get("description"),
			"epub_version": this.get("epub_version"),
			"fixed_layout": this.get("fixed_layout"),
			"id": this.get("id"),
			"key": this.get("key"),
			"language": this.get("language"),
			"layout": this.get("layout"),
			"modified_date": this.get("modified_date"),
			"ncx": this.get("ncx"),
			"open_to_spread": this.get("open_to_spread"),
			"orientation": this.get("orientation"),
			"package_doc_path": this.get("package_doc_path"),
			"page_prog_dir": this.get("page_prog_dir"),
			"paginate_backwards": this.get("paginate_backwards"),
			"pubdate": this.get("pubdate"),
			"publisher": this.get("publisher"),
			"rights": this.get("rights"),
			"spread": this.get("spread"),
			"src_url": this.get("src_url"),
			"title": this.get("title")
		};
	},

	resolvePath: function(path) {
		return this.packageDocument.resolvePath(path);
	},

	// is this book set to fixed layout at the meta-data level
	isFixedLayout: function() {
		return this.get("fixed_layout") || this.get("apple_fixed");
	}
});
// Description: This model is responsible determining page numbers to display for both reflowable and fixed layout pubs.
// Rationale: This model exists to abstract and encapsulate the logic for determining which pages numbers should be
//   dispalyed in the viewer. The logic for this is reasonably complex, as there a number of different factors that must be
//   taken into account in various cases. These include: The type of the pub (reflowable or fixed layout), the page progression direction, 
//   the reading order of pages, the number of pages displayed on the screen and author preferences 
//   for the location of pages (left/right/centre). 

Readium.Models.PageNumberDisplayLogic = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {},

    // Description: This method determines the page numbers to display, given a single page number to "go to"
    // Arguments (
    //   gotoPageNumber (integer): The page number to "go to"
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
    //   pageProgDirection ("rtl" or "ltr): The page progression direction
    //	)
	// REFACTORING CANDIDATE: This might be better named as getPageNumsToDisplay; the "goto" is confusing; also some
	//   deep nesting here that could be refactored for clarity.
	getGotoPageNumsToDisplay: function(gotoPageNumber, twoUp, isFixedLayout, pageProgDirection, firstPageOffset) {

		if (twoUp) {
			
			// Fixed layout page
			if (isFixedLayout) {

				if (pageProgDirection === "rtl") {

					if (this.displayedPageIsLeft(gotoPageNumber)) {

						if (this.displayedPageIsRight(gotoPageNumber - 1)) {
							return [gotoPageNumber - 1, gotoPageNumber];
						}
						else {
							return [gotoPageNumber];
						}
					}
					else if (this.displayedPageIsRight(gotoPageNumber)) {

						if (this.displayedPageIsLeft(gotoPageNumber + 1)) {
							return [gotoPageNumber, gotoPageNumber + 1];	
						}
						else {
							return [gotoPageNumber];
						}
					}
					// A center page
					else {
						return [gotoPageNumber];
					}
				}
				// Left-to-right page progression
				else {

					if (this.displayedPageIsLeft(gotoPageNumber)) {

						if (this.displayedPageIsRight(gotoPageNumber + 1)) {
							return [gotoPageNumber, gotoPageNumber + 1];
						}
						else {
							return [gotoPageNumber];
						}
					}
					else if (this.displayedPageIsRight(gotoPageNumber)) {

						if (this.displayedPageIsLeft(gotoPageNumber - 1)) {
							return [gotoPageNumber - 1, gotoPageNumber];
						}
						else {
							return [gotoPageNumber];
						}
					}
					// A center page
					else {
						return [gotoPageNumber];
					}
				}
			}
			// This is a reflowable page
			else {

				if (firstPageOffset) {

					if (gotoPageNumber % 2 === 1) {
						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else {
						return [gotoPageNumber, gotoPageNumber + 1];
					}
				}
				else {
					// in reflowable format, we want this config always:
					// ODD_PAGE |spine| EVEN_PAGE
					if (gotoPageNumber % 2 === 1) {
						return [gotoPageNumber, gotoPageNumber + 1];	
					} 
					else {
						return [gotoPageNumber - 1, gotoPageNumber];
					}
				}	
			}
		}
		else {	
			return [gotoPageNumber];
		}
	},

    // Description: Get the pages numbers to display when moving in reverse reading order
    // Arguments (
    //   prevPageNumberToDisplay (integer): The page to move to; this page must be one of the displayed pages
    //   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
    //   pageProgDirection ("rtl" or "ltr): The page progression direction    	
    //	)
	getPrevPageNumsToDisplay: function (prevPageNumberToDisplay, isFixedLayout, pageProgDirection) {

		// If fixed layout
		if (isFixedLayout) {

			if (pageProgDirection === "rtl") {

				// If the first page is a left page in rtl progression, only one page 
				// can be displayed, even in two-up mode
				if (this.displayedPageIsLeft(prevPageNumberToDisplay) && 
					this.displayedPageIsRight(prevPageNumberToDisplay - 1)) {

					return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
				}
				else {

					return [prevPageNumberToDisplay];
				}
			}
			// Left-to-right progresion
			else {

				if (this.displayedPageIsRight(prevPageNumberToDisplay) &&
					this.displayedPageIsLeft(prevPageNumberToDisplay - 1)) {

					return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
				}
				else {

					return [prevPageNumberToDisplay];
				}
			}
		}
		// A reflowable text
		else {

			return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
		}
	},

	// Description: Get the pages to display when moving in reading order
    // Arguments (
    //   nextPageNumberToDisplay (integer): The page to move to; this page must be one of the displayed pages
    //   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
    //   pageProgDirection ("rtl" or "ltr): The page progression direction    	
    //	)
	getNextPageNumsToDisplay: function (nextPageNumberToDisplay, isFixedLayout, pageProgDirection) {

		// If fixed layout
		if (isFixedLayout) {

			if (pageProgDirection === "rtl") {

				// If the first page is a left page in rtl progression, only one page 
				// can be displayed, even in two-up mode
				if (this.displayedPageIsRight(nextPageNumberToDisplay) &&
					this.displayedPageIsLeft(nextPageNumberToDisplay + 1)) {

					return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
				}
				else {

					return [nextPageNumberToDisplay];
				}
			}
			else {

				if (this.displayedPageIsLeft(nextPageNumberToDisplay) && 
					this.displayedPageIsRight(nextPageNumberToDisplay + 1)) {

					return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
				}
				else {

					return [nextPageNumberToDisplay];
				}
			}
		}
		// Reflowable section
		else {

			return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
		}
	},

	// Description: This method determines which page numbers to display when switching
	//   between a single page and side-by-side page views and vice versa.
	// Arguments (
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   displayedPageNumbers (array of integers): An array of page numbers that are currently displayed	
	//   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
	//   pageProgDirection ("rtl" or "ltr): The page progression direction
	//	)
	// Notes: Authors can specify a fixed layout page as a "center" page, which prevents more than one page
	//   being displayed. This case is not handled yet.
	getPageNumbersForTwoUp: function(twoUp, displayedPageNumbers, pageProgDirection, isFixedLayout, firstPageOffset) {

		var displayed = displayedPageNumbers;
		var twoPagesDisplayed = displayed.length === 2 ? true : false;
		var newPages = [];

		// Two pages are currently displayed; find the single page number to display
		if (twoPagesDisplayed) {

			// Rationale: I think this check is a bit of a hack, for the case in which a set of pages is [0, 1]. Pages are
			//   1-indexed, so the "0" in the 0 index position of the array is not valid.
			if (displayed[0] === 0) {
				
				newPages[0] = 1;
			} 
			else {
				
				newPages[0] = displayed[0];
			}
		}
		// A single reflowable page is currently displayed; find two pages to display
		else if (!isFixedLayout) {

			if (firstPageOffset) {

				if (displayed[0] % 2 === 1) {
					
					newPages[0] = displayed[0] - 1;
					newPages[1] = displayed[0];
				}
				else {
					
					newPages[0] = displayed[0];
					newPages[1] = displayed[0] + 1;
				}				
			}
			else {

				if (displayed[0] % 2 === 1) {
					
					newPages[0] = displayed[0];
					newPages[1] = displayed[0] + 1;
				}
				else {
					
					newPages[0] = displayed[0] - 1;
					newPages[1] = displayed[0];
				}
			}
		}
		// A single fixed layout page is displayed
		else {

			// page progression is right-to-left
			if (pageProgDirection === "rtl") {

				// and the previous one is right, then display both, otherwise, just display one
				if (this.displayedPageIsLeft(displayed[0])) {
					
					if (this.displayedPageIsRight(displayed[0] - 1)) {

						newPages[0] = displayed[0] - 1;
						newPages[1] = displayed[0];
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// if the next page is left, display both, otherwise, just display one
				else if (this.displayedPageIsRight(displayed[0])) {
					
					if (this.displayedPageIsLeft(displayed[0] + 1)) {
						
						newPages[0] = displayed[0];
						newPages[1] = displayed[0] + 1;
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// It is a center page
				else {

					newPages[0] = displayed[0];
				}
			}
			// page progression is left-to-right
			else {

				// If next page is a right page, display both, otherwise just display this one
				if (this.displayedPageIsLeft(displayed[0])) {
					
					if (this.displayedPageIsRight(displayed[0] + 1)) {
						
						newPages[0] = displayed[0];
						newPages[1] = displayed[0] + 1;
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				else if (this.displayedPageIsRight(displayed[0])) {
					
					if (this.displayedPageIsLeft(displayed[0] - 1)) {
						
						newPages[0] = displayed[0] - 1;
						newPages[1] = displayed[0];
					}
					else {

						newPages[0] = displayed[0];
					}
				}
				// It is a center page
				else {

					newPages[0] = displayed[0];
				}
			}
		}

		return newPages;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: The `displayedPageIs...` methods determine if a fixed layout page is right, left or center.
	//
	// Rationale: This is not an ideal approach, as we're pulling properties directly out of the dom, rather than
	//   out of our models. The rationale is that as of Readium 0.4.1, the page-spread-* value
	//   is not maintained in the model hierarchy accessible from an ebook object. An alternative
	//   would be to infer the left/right/center value from model attributes on ebook, or other objects in
	//   ebook's object hierarchy. However, this would duplicate the logic that exists elsewhere for determining right/left/center
	//   for a page, which is probably worse than pulling out of the dom. This approach also avoids having to convert
	//   from the page number (based on what is rendered on the screen) to spine index. 
	displayedPageIsRight: function (displayedPageNum) {

		return $("#page-" + displayedPageNum).hasClass("right_page") ? true : false;
	},

	displayedPageIsLeft: function (displayedPageNum) {

		return $("#page-" + displayedPageNum).hasClass("left_page") ? true : false;
	},

	displayedPageIsCenter: function (displayedPageNum) {

		return $("#page-" + displayedPageNum).hasClass("center_page") ? true : false;
	}
});

Readium.Models.ReadiumPagination = Backbone.Model.extend({ 

	defaults: {
		"num_pages" : 0
	},

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {

		this.epubController = this.get("model");

		// REFACTORING CANDIDATE: This is not ideal as it muddies the difference between the spine index position and 
		//   the page numbers that result from pagination. 
		this.set("current_page", [this.epubController.get("spine_position") + 1]);

		// Instantiate an object responsible for deciding which pages to display
		this.pageNumberDisplayLogic = new Readium.Models.PageNumberDisplayLogic();
		
		// if content reflows and the number of pages in the section changes
		// we need to adjust the the current page
		// Probably a memory leak here, should add a destructor
		this.on("change:num_pages", this.adjustCurrentPage, this);

	},

	// Description: This method determines which page numbers to display when switching
	//   between a single page and side-by-side page views and vice versa.
	toggleTwoUp: function() {

		if (this.epubController.epub.get("can_two_up")) {

			var newPages = this.pageNumberDisplayLogic.getPageNumbersForTwoUp (
				this.epubController.get("two_up"), 
				this.get("current_page"),
				this.epubController.epub.get("page_prog_dir"),
				this.epubController.getCurrentSection().isFixedLayout(),
				this.epubController.getCurrentSection().firstPageOffset()
				);

			this.set({current_page: newPages});
		}	
	},

	// REFACTORING CANDIDATE: This needs to be investigated, but I bet if the prevPage and nextPage methods were 
	//   called directly (goRight and goLeft were removed), the new page number display logic would account for the 
	//   page progression direction and that all this logic could be simplified in both this model and the 
	//   PageNumberDisplayLogic model
	// 
	// Description: turn pages in the rightward direction
	//   ie progression direction is dependent on 
	//   page progression dir
	goRight: function() {
		if (this.epubController.epub.get("page_prog_dir") === "rtl") {
			this.prevPage();
		}
		else {
			this.nextPage();	
		}
	},

	// Description: Turn pages in the leftward direction
	//   ie progression direction is dependent on 
	//   page progression dir
	goLeft: function() {
		if (this.epubController.epub.get("page_prog_dir") === "rtl") {
			this.nextPage();
		}
		else {
			this.prevPage();	
		}
	},

	goToPage: function(gotoPageNumber) {

		var pagesToGoto = this.pageNumberDisplayLogic.getGotoPageNumsToDisplay(
							gotoPageNumber,
							this.epubController.get("two_up"),
							this.epubController.getCurrentSection().isFixedLayout(),
							this.epubController.epub.get("page_prog_dir"),
							this.epubController.getCurrentSection().firstPageOffset()
							);
		this.set("current_page", pagesToGoto);
	},

	// Description: Return true if the pageNum argument is a currently visible 
	//   page. Return false if it is not; which will occur if it cannot be found in 
	//   the array.
	isPageVisible: function(pageNum) {
		return this.get("current_page").indexOf(pageNum) !== -1;
	},

	// REFACTORING CANDIDATE: prevPage and nextPage are public but not sure it should be; it's called from the navwidget and viewer.js.
	//   Additionally the logic in this method, as well as that in nextPage(), could be refactored to more clearly represent that 
	//   multiple different cases involved in switching pages.
	prevPage: function() {

		var curr_pg = this.get("current_page");
		var lastPage = curr_pg[0] - 1;

		// Clear the hash fragment if the user has decided to navigate away from it
		this.epubController.set("hash_fragment", undefined);

		if (curr_pg[0] <= 1) {

			this.epubController.goToPrevSection();
		}
		// REFACTORING CANDIDATE: The pagination/spine position relationship is still muddied. As a result, 
		//   the assumption that a single content document (spine element) is rendered in every scrolling view must be
		//   enforced here with this scrolling view specific check condition. 
		else if (this.epubController.paginator.shouldScroll() &&
			     !this.epubController.getCurrentSection().isFixedLayout()) {

			this.epubController.goToPrevSection();
		}
		// Single page navigation
		else if (!this.epubController.get("two_up")){

			this.set("current_page", [lastPage]);

			// Reset spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {
				var pos = this.epubController.get("rendered_spine_items")[lastPage - 1];
				this.epubController.set("spine_position", pos);
			}
		}
		// Move to previous page with two side-by-side pages
		else {

			var pagesToDisplay = this.pageNumberDisplayLogic.getPrevPageNumsToDisplay(
								lastPage,
								this.epubController.getCurrentSection().isFixedLayout(),
								this.epubController.epub.get("page_prog_dir")
								);
			this.set("current_page", pagesToDisplay);

			// Reset spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {
				var ind = (lastPage > 1 ? lastPage - 2 : 0);
				var pos = this.epubController.get("rendered_spine_items")[ind];
				this.epubController.set("spine_position", pos);
			}
		}
        
        // when we change the page, we have to tell MO about it
        this.epubController.get("media_overlay_controller").userChangedPage();
	},

	nextPage: function() {

		var curr_pg = this.get("current_page");
		var firstPage = curr_pg[curr_pg.length - 1] + 1;

		// Clear the hash fragment if the user has decided to navigate away from it
		this.epubController.set("hash_fragment", undefined);

		if (curr_pg[curr_pg.length - 1] >= this.get("num_pages")) {

			this.epubController.goToNextSection();
		}
		else if (!this.epubController.get("two_up")) {

			this.set("current_page", [firstPage]);

			// Reset the spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {

				var pos = this.epubController.get("rendered_spine_items")[firstPage - 1];
				this.epubController.set("spine_position", pos);
			}
		}
		// Two pages are being displayed
		else {

			var pagesToDisplay = this.pageNumberDisplayLogic.getNextPageNumsToDisplay(
								firstPage,
								this.epubController.getCurrentSection().isFixedLayout(),
								this.epubController.epub.get("page_prog_dir")
								);
			this.set("current_page", pagesToDisplay);

			// Reset the spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {

				var pos = this.epubController.get("rendered_spine_items")[firstPage - 1];
				this.epubController.set("spine_position", pos);
			}
		}
        // when we change the page, we have to tell MO about it
        this.epubController.get("media_overlay_controller").userChangedPage();
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	adjustCurrentPage: function() {
		var cp = this.get("current_page");
		var num = this.get("num_pages");

		if (cp[cp.length - 1] > num) {
			this.goToLastPage();
		}

Acc.page = '#' + cp;

	},	

	// REFACTORING CANDIDATE: this is strange in that it does not seem to account for 
	//   possibly crossing over a section boundary
	goToLastPage: function() {
		var page = this.get("num_pages");
		this.goToPage(page);
	}
});
(function() {
  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};
templates['binding_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  


  return "<iframe scrolling=\"no\" \n		frameborder=\"0\" \n		marginwidth=\"0\" \n		marginheight=\"0\" \n		width=\"100%\" \n		height=\"100%\" \n		class='binding-sandbox'>\n</iframe>";});
templates['extracting_item_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<h5>";
  foundHelper = helpers.log_message;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.log_message; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "</h5>\n<div class=\"progress progress-striped progress-success active \">	\n		<div role=\"status\" aria-live=\"assertive\" aria-relevant=\"all\" class=\"bar\" style=\"width: ";
  foundHelper = helpers.progress;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.progress; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "%;\"></div>\n</div>";
  return buffer;});
templates['fixed_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"fixed-page-margin\">\n	<iframe scrolling=\"no\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"";
  foundHelper = helpers.width;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.width; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "px\" \n			height=\"";
  foundHelper = helpers.height;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.height; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "px\" \n			src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\"\n			title=\"";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\"\n			class='content-sandbox'>\n	</iframe>\n</div>";
  return buffer;});
templates['image_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"fixed-page-margin\">\n	<img src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\" alt=\"\" />\n</div>";
  return buffer;});
templates['library_item_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<div class='info-wrap'>\n	<div class='caption book-info'>\n		<h2 class='green info-item title'>";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "</h2>\n		<div class='info-item author'>";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.author;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='info-item epub-version'>ePUB ";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.epub_version;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>		\n	</div>\n	\n	<img class='cover-image read' src='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.cover_href;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' width='150' height='220' alt='Open ePUB ";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "'>\n	\n	<a href=\"#details-modal-";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\" class=\"info-icon\" aria-pressed=\"true\" data-toggle=\"modal\" role=\"button\">\n		<img class='info-icon pull-right' src='/images/library/info-icon.png' height=\"39px\" width=\"39px\" alt='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + " information'>\n	</a>\n</div>\n\n<div class=\"caption buttons\">\n	<a href=\"#todo\" class=\"btn read\" data-book='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' role='button'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_read", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_read", {hash:{}});
  buffer += escapeExpression(stack1) + "</a>\n	<a href=\"#details-modal-";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\" aria-pressed=\"true\" class=\"btn details\" data-toggle=\"modal\" role=\"button\">\n		";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_details", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_details", {hash:{}});
  buffer += escapeExpression(stack1) + "\n	</a>\n</div>\n\n<div id='details-modal-";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' class='modal fade details-modal'>\n<div class=\"offscreenText\"> Details Start </div>\n	<div class=\"pull-left modal-cover-wrap\">\n		<img class='details-cover-image' src='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.cover_href;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' width='150' height='220' alt='ePUB cover'>\n		<div class=\"caption modal-buttons\">\n			<a href=\"#\" class=\"btn read\" data-book='<%= data.key %>' role='button'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_read", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_read", {hash:{}});
  buffer += escapeExpression(stack1) + "</a>\n			<a class=\"btn btn-danger delete pull-right\" role='button'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_delete", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_delete", {hash:{}});
  buffer += escapeExpression(stack1) + "</a>\n		</div>\n	</div>\n	<div class='caption modal-book-info'>\n		<h3 class='green modal-title'>";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "</h3>\n		<div class='modal-detail gap'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_author", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_author", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.author;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_publisher", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_publisher", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.publisher;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_pub_date", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_pub_date", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.pubdate;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_modified_date", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_modified_date", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.modified_date;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail gap'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_id", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_id", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.id;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail green'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_epub_version", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_epub_version", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.epub_version;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_created_at", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_created_at", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.created_at;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n	</div>\n	<div class='modal-detail source'>\n	<span class='green' style=\"padding-right: 10px\">";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_source", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_source", {hash:{}});
  buffer += escapeExpression(stack1) + "</span>\n		";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.src_url;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "\n	</div>\n<div class=\"offscreenText\"> Details End </div>\n</div>			";
  return buffer;});
templates['library_items_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div id='empty-message'>\n	<p id='empty-message-text' class='green'>\n		";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_add_items", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_add_items", {hash:{}});
  buffer += escapeExpression(stack1) + "\n	</p>\n	<img id='empty-arrow' src='/images/library/empty_library_arrow.png' alt='Try adding an ePUB' />\n</div>";
  return buffer;});
templates['ncx_nav_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<li class=\"nav-elem\">\n	<a href=\"";
  foundHelper = helpers.href;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.href; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\">";
  foundHelper = helpers.text;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "</a>\n</li>";
  return buffer;});
templates['reflowing_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"flowing-wrapper\">\n	<iframe scrolling=\"no\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"50%\" \n			height=\"100%\" \n			title=\"";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\"\n			src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\"\n			id=\"readium-flowing-content\">\n	</iframe>\n</div>";
  return buffer;});
templates['scrolling_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"scrolling-content\" class=\"scrolling-page-wrap\">\n	<div class=\"scrolling-page-margin\">\n\n		<iframe scrolling=\"yes\" \n				frameborder=\"0\" \n				marginwidth=\"0\" \n				marginheight=\"0\" \n				width=\"100%\" \n				height=\"100%\" \n				title=\"";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\"\n				src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\"\n				class='content-sandbox'>\n		</iframe>\n	</div>\n</div>";
  return buffer;});
})();
// Description: This model is the primary integration layer between media overlays and the rest of Readium
// It tracks which MO is playing, and controls what happens to playback when a page turns or an href gets loaded

Readium.Models.MediaOverlayController = Backbone.Model.extend({

	defaults: {
        "state": "unavailable", // "playing", "paused", "not_started", "unavailable"
		"mo_text_id": null, // the current MO text fragment identifier
        "rate": 1.0, // the playback rate
        "volume": 1.0 // the volume
	},

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {

        // the current media overlay
        this.mo = null;
        
        // for mute/unmute
        this.savedVolume = 0;
        
        // the node to start playback at
        this.targetNode = null;
        
        // the current spine item
        this.currentSpineItem = null;
        
        // flag that MO is processing a text src
        this.isProcessingTextSrc = false;
        
        // flag that the user changed the page
        this.flagUserPageChange = false;
        
        // flag that the user's position was restored
        this.flagRestoredPosition = false;
        
        // readium epub controller, set as a constructor option
		this.epubController = this.get("epubController");
		
        // readium reflowable pagination view
        this.view = null;
        
        this.on("change:rate", this.rateChanged, this);
        this.on("change:volume", this.volumeChanged, this);  
        
        this.epubController.on("change:spine_position", this.handleSpineChanged, this);   
        
        // print debug statements
        this.consoleTrace = false;   
	},
    
    setView: function(view) {
        this.view = view;
    },
    
    // hooked up to the 'play/pause' button
	playMo: function(forcePosition) {
        if (this.currentSpineItem == null || !this.currentSpineItem.hasMediaOverlay()) {
            this.mo = null;
            this.set("state", "unavailable");
            this.debugPrint("No overlay available for this spine item.");
            return;
        }
        
        this.debugPrint("playMo");
        
        // just verify that we have the correct MO loaded
        // except when forcePosition is false -- then the MO was purposely set 
        // to something different than our current spine item, because the user navigated there,
        // and Readium will listen to MO regarding text display URLs
        if (forcePosition && this.currentSpineItem.getMediaOverlay() != this.mo) {
            this.mo = this.currentSpineItem.getMediaOverlay();
            this.set("state", "not_started");
        }
        if (this.mo == null) {
            return;
        }
        this.mo.setVolume(this.get("volume"));
        this.mo.setRate(this.get("rate"));
        this.mo.off(); // just to be safe
        this.mo.on("change:current_text_src", this.handleMoTextSrcChanged, this);
		this.mo.on("change:is_document_done", this.handleMoDocumentDoneChanged, this);
        
        // if we are processing a new page caused either by the user going to prev/next page
        // or by the restored position that gets loaded initially
        // there's a reason why this type of action is dealt with in 2 places: here and also mid-playback (see
        // updatePlaybackForReflowPageChange() ). By the time the user presses play, enough screen refreshing has
        // taken place that we can be more certain that the visible elements are the correct ones.
        if (!this.currentSpineItem.isFixedLayout() && (this.flagUserPageChange || this.flagRestoredPosition)) {
            this.flagUserPageChange = false;
            this.flagRestoredPosition = false;
            var visibleElms = this.view.findVisiblePageElements();
            this.targetNode= this.findFirstOnPageReflow(visibleElms);
            this.set("state", "not_started");
        }
        
        if (this.get("state") == "paused") {
            this.set("state", "playing");
            this.resumeMo();
        }
        else {
            this.mo.reset();
            this.set("state", "playing");
            var target = this.targetNode;
            this.targetNode = null;
            this.mo.startPlayback(target);            
        }
	},

    // hooked up to the 'play/pause' button
	pauseMo: function() {
        if (this.mo) {
            this.set("state", "paused");
            this.mo.off();
			this.mo.pause();
		}
	},
    
    // hooked up to the 'mute/unmute' button
    mute: function() {
        if (this.mo) {
            // unmute
            if (this.mo.getVolume() == 0) {
                // if the last-used volume was already at 0, restore it to a quiet level
                if (this.savedVolume == 0) {
                    this.savedVolume = .1;
                }
                this.set("volume", this.savedVolume);
                
            }
            // mute
            else {
                this.savedVolume = this.mo.getVolume();
                this.set("volume", 0);
            }
        }
    },
    
    // hooked up to the volume slider
    volumeChanged: function() {
        if (this.mo) {
            this.mo.setVolume(this.get("volume"));
        }
    },
    
    // hooked up to the rate slider
    rateChanged: function() {
        if (this.mo) {
            this.mo.setRate(this.get("rate"));
        }
    },
    
    increaseVolume: function() {
        var curr = this.get("volume");
        if (curr >= 1.0) {
            return;
        }
        if (curr + 0.1 >= 1.0) {
            this.set("volume", 1.0);
        }
        else {
            this.set("volume", curr + 0.1);
        }
    },
    
    decreaseVolume: function() {
        var curr = this.get("volume");
        if (curr <= 0) {
            return;
        }
        if (curr - 0.1 < 0) {
            this.set("volume", 0);
        }
        else {
            this.set("volume", curr - 0.1);
        }
        
    },
    
    increaseRate: function() {
        var curr = this.get("rate");
        if (curr >= 2.5) {
            return;
        }
        if (curr + 0.1 >= 2.5) {
            this.set("rate", 2.5);
        }
        else {
            this.set("rate", curr + 0.1);
        }
    },
    
    decreaseRate: function() {
        var curr = this.get("rate");
        if (curr <= 0.5) {
            return;
        }
        if (curr - 0.1 <= 0.5) {
            this.set("rate", 0.5);
        }
        else {
            this.set("rate", curr - 0.1);
        }
    },
    
    resetRate: function() {
        this.set("rate", 1.0);
    },
    
    // move to a specific point in the book
    // this could be the start of a section or bookmark etc
    goToHref: function(href) {
        // if we are in the middle of processing our own src, ignore it
        if (this.isProcessingTextSrc) {
            return;
        }
        
        this.debugPrint("goToHref");
        var wasPlaying = this.get("state") == "playing";
        if (wasPlaying) {
            this.pauseMo();
        }
            
        var splitUrl = href.match(/([^#]*)(?:#(.*))?/);
        var spinePos = this.epubController.packageDocument.spineIndexFromHref(splitUrl[1]);
        var spineItem = this.epubController.packageDocument.getSpineItem(spinePos);
            
        if (spineItem.hasMediaOverlay()) {
            this.mo = spineItem.getMediaOverlay();
            this.mo.reset();
            this.set("state", "not_started");
            // find the target node for the URI
            this.targetNode = this.findTarget(spineItem, splitUrl[2]);
            // if MO was playing, then stop and restart at this point
            if (wasPlaying) {
                this.playMo(false);
            }
        }
    },
    
    // called by the reflowable page view when the page changes
    // applies only during playback
    updatePlaybackForReflowPageChange: function() {
        // just to be safe: ignore fxl
        if (this.currentSpineItem.isFixedLayout()) {
            return;
        }
        
        // we only care about this if we are in the middle of playback
        // this is safer because readium might call this function several times
        if (this.get("state") == "playing" && 
            (this.flagUserPageChange || this.flagRestoredPosition)) {
            
            var visibleElms = this.view.findVisiblePageElements();
            
            // make sure there are actually elements on the page
            // if not, we can leave the flagged variables as-is, and 
            // this function will get called again by reflowable pagination view
            if (visibleElms.length > 0) {
                this.debugPrint("updatePlaybackForReflowPageChange");
                this.pauseMo();
            
                this.flagUserPageChange = false;
                this.flagRestoredPosition = false;
                this.set("state", "not_started");
                
                // make sure we're on the right spine item
                if (this.currentSpineItem.hasMediaOverlay()) {
                    if (this.mo != this.currentSpineItem.getMediaOverlay()) {
                        this.mo = this.currentSpineItem.getMediaOverlay();
                    }
                    this.mo.reset();
                    this.targetNode = this.findFirstOnPageReflow(visibleElms);  
                    this.set("mo_text_id", null);
                    this.playMo(true);
                }
                else {
                    this.mo = null;
                    this.set("mo_text_id", null);
                    this.set("state", "unavailable");
                }
            }
        }
    },
    
    // called by the page view when the user used "go to (prev/next) page"
    // if this flag is set, MO will respond to page refresh events
    // this function is really only useful for reflowable content
    userChangedPage: function() {
        this.flagUserPageChange = true;   
    },
    
    restoredPosition: function() {
        this.flagRestoredPosition = true;
    },
    
    // ------------------------------------------------------------------------------------ //
	//  "PRIVATE" METHODS                                                                   //
	// ------------------------------------------------------------------------------------ //
    resumeMo: function() {
        this.set("mo_text_id", null); // clear it so that any listeners re-hear the event
        this.handleMoTextSrcChanged();
        this.mo.resume();
    },
    
    handleMoTextSrcChanged: function() {
        this.debugPrint("handleMoTextSrcChanged " + this.mo.get("current_text_src"));
        this.isProcessingTextSrc = true;
        var textSrc = this.mo.get("current_text_src");
        if (textSrc == null) {
            this.set("mo_text_id", null);
            return;
        }
        
        this.epubController.goToHref(textSrc);
        var frag = "";
        if (textSrc.indexOf("#") != -1 && textSrc.indexOf("#") < textSrc.length -1) {
            frag = textSrc.substr(textSrc.indexOf("#")+1);
        }
        this.set("mo_text_id", frag);
        this.isProcessingTextSrc = false;
    },
    
    // caveat: this gets called when is_document_done changes, so we need to check if the document is indeed done
    handleMoDocumentDoneChanged: function() {
        if (this.mo != null && this.mo != undefined) {
            if (this.mo.get("is_document_done") == false) {
                return;
            }
        }
        this.debugPrint("handleMoDocumentDoneChanged");
        this.pauseMo();
        
        // advance the spine position
        if (this.epubController.hasNextSection()) {
            this.epubController.goToNextSection();
            this.playMo(true);
        }
    },
    
    // this acts as page change handler for fxl content
    handleSpineChanged: function() {
        // sometimes the spine changed event fires but the spine didn't actually change
        if (this.epubController.getCurrentSection() == this.currentSpineItem) {
            return;
        }
        this.currentSpineItem = this.epubController.getCurrentSection();
        
        if (!this.currentSpineItem.isFixedLayout()) {
            return;
        }
        
        var wasPlaying = this.get("state") == "playing";    
        if (wasPlaying) {
            this.pauseMo();
        }
          
        // make sure we're on the right spine item
        if (this.currentSpineItem.hasMediaOverlay()) {
            if (this.mo != this.currentSpineItem.getMediaOverlay()) {
                this.mo = this.currentSpineItem.getMediaOverlay();
            }
        }
        else {
            this.mo = null;
            this.set("mo_text_id", null);
            this.set("state", "unavailable");
        }
        
        if (this.mo == null) {
            return;
        }
        this.mo.reset();
        this.targetNode = this.findFirstOnPageFxl();
        this.set("state", "not_started");
        if (wasPlaying) {
            this.playMo(true);
        }
    },
    
    // find the MO starting point closest to targetId
    findTarget: function(spineItem, targetId) {
        
        if (targetId == null || targetId == undefined || targetId == "" ||
            spineItem == null) {
            return null;
        }
        // two issues here:
        // 1. MO might not have a corresponding <text> pointing to #fragId
        // In this case, we have to find the next-closest
        //
        // 2. we have to look at all elements, not just the currently visible ones. the pages get refreshed a few times
        // and the target element might not be displayed until the second time around. however, we need to find what the
        // most reasonable MO target is and can't risk coming up with nothing (because then MO starts at the top)
        
        var mo = spineItem.getMediaOverlay();
        var docHref = this.epubController.packageDocument.resolveUri(spineItem.get("href"));
        var startHref = docHref + "#" + targetId;
        var node = null;
        $.ajax({
            url: docHref,
            async: false,
            success: function(data, status, jqXHR) {
                var allElms = $(data).find("[id]");
                var foundStart = false; 
                for (var i = 0; i<allElms.length; i++) {
                    var id = $(allElms[i]).attr("id");
                    var src = docHref + "#" + id;
                    if (src == startHref) {
                        foundStart = true;
                    }
                    // once we found our starting point in the set, start looking at MO nodes
                    if (foundStart) {
                        node = mo.findNodeByTextSrc(src);
                        if (node) {
                            break;
                        }
                    }
                }
            }
        });
        return node;
    },
    
    // find the MO element for the first visible page element with an MO <text> equivalent
    findFirstOnPageReflow: function(visibleElms) {
        // this is only useful for reflowable content
        if (this.currentSpineItem.isFixedLayout()) {
            return null;
        }
        
        if (visibleElms.length == 0) {
            this.debugPrint("No visible page elements");
            return null;
        }
        
        var docHref = this.currentSpineItem.resolveUri(this.currentSpineItem.get("href"));
        var node = null;
        for (var i = 0; i<visibleElms.length; i++) {
            var id = $(visibleElms[i]).attr("id");
            var src = docHref + "#" + id;
            
            node = this.mo.findNodeByTextSrc(src);
            if (node) {
                break;
            }
        }
        return node;
    },
    
    // find the MO element for the first element in the current spine item with an MO equivalent
    findFirstOnPageFxl: function() {
        var docHref = this.currentSpineItem.resolveUri(this.currentSpineItem.get("href"));
        var mo = this.currentSpineItem.getMediaOverlay();
        
        $.ajax({
            url: docHref,
            async: false,
            success: function(data, status, jqXHR) {
                var allElms = $(data).find("[id]");
                for (var i = 0; i<allElms.length; i++) {
                    var id = $(allElms[i]).attr("id");
                    var src = docHref + "#" + id;
                    node = mo.findNodeByTextSrc(src);
                    if (node) {
                        break;
                    }
                }
            }
        });
        return node;
    },
    
    debugPrint: function(msg) {
        if (this.consoleTrace) {
            console.log("MO: " + msg);
        }
    }
});
// Description: This model provides helper methods related to Media Overlay functionality required by the fixed and reflowable views.
// Rationale: While these helpers could be included on the view objects themselves, this model was created to encapsulate view functionality
//   related to the display of media overlays for three reasons: First, the requirements for media overlays are expected to grow, which
//   would have produced larger and larger view models (by code size). Second, the primary responsibility of the pagination views is to paginate epub content
//   and provide an interface for accessing rendered content; adding MO methods to those objects would have clouded the abstraction. Third, MO
//   is the primary responsiblity of one contributor. Encapsulating MO view functionality in this model makes it easier for contributors to 
//   focus on their areas of responsibility. 

// REFACTORING CANDIDATE: The interfaces for the methods here are not particularly tight. In some cases, entire views are being 
//   passed to the methods. It would be better if the interfaces were built around something consistent; the page body being passed, 
//   etc. 
//   Interaction with the "pagination" could be improved too. It would be ideal to encorporate the concept of the "currently rendered
//   pages" into the methods here; this would use the ReadiumPagination model, which abstracts this concept. Currently, these methods
//   are working through the backbone views, but essentially using the DOM.

Readium.Models.MediaOverlayViewHelper = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {
		this.epubController = this.get("epubController");
	},

    // active class comes from the package document metadata
    // authors can specify the class name they want to have applied to 
    // active MO text fragments
    addActiveClass: function(fragElm) {
        var activeClass = this.getActiveClass();
        fragElm.toggleClass(activeClass, true);
    },

    removeActiveClass: function(body) {
        if (body != null && body != undefined) {   
            var activeClass = this.getActiveClass();
            var lastFrag = $(body).find("." + activeClass);
            lastFrag.toggleClass(activeClass, false);
            return lastFrag;
        }
        return null;
    },
    
    // we're not using themes for fixed layout, so just apply the active class name to the
    // current MO fragment, so that any authored styles will be applied.
    renderFixedLayoutMoFragHighlight: function(currentPages, currentMOFrag, fixedLayoutView) {
        var that = this;

        $.each(currentPages, function(idx) {
           var body = fixedLayoutView.getPageBody(this);
           that.removeActiveClass(body);
        }); 
        
		if(currentMOFrag) {
    		$.each(currentPages, function(idx) {
                var body = fixedLayoutView.getPageBody(this);
                // escape periods for jquery
                var newFrag = $(body).find("#" + currentMOFrag.replace(".", "\\."));
                if (newFrag.length > 0) {
                	that.addActiveClass(newFrag);	
                } 
           });
		}
	},

	renderFixedMoPlaying: function(currentPages, MOIsPlaying, fixedLayoutView) {
        var that = this;
        // if we are using the author's style for highlighting, then just clear it if we are not playing
        if (this.authorActiveClassExists()) {
            if (!MOIsPlaying) {
        		// get rid of the last highlight
                $.each(currentPages, function(idx) {
                   var body = fixedLayoutView.getPageBody(this);
                   that.removeActiveClass(body);
                }); 
            }
        }
	},
    

    // highlight the text
	renderReflowableMoFragHighlight: function(currentTheme, reflowableView, currentMOFrag) {
        if (currentTheme === "default") {
			currentTheme = "default-theme";
		}
        // get rid of the last highlight
		var body = reflowableView.getBody();
        var lastFrag = this.removeActiveClass(body);
        
        // if the author did not define an active class themselves
        if (this.authorActiveClassExists() == false) {
            if (lastFrag) {
                $(lastFrag).css("color", "");
            }
        }
        if (currentMOFrag) {
            // add active class to the new MO fragment
            // escape periods for jquery
            var newFrag = $(body).find("#" + currentMOFrag.replace(".", "\\."));
            if (newFrag.length > 0) {
                this.addActiveClass(newFrag);
                if (this.authorActiveClassExists() == false) {
                    $(newFrag).css("color", reflowableView.themes[currentTheme]["color"]);   
                }
            }
            // If the element corresponding to currentMOFrag wasn't found, it might be because the document hasn't 
            // completely loaded yet. Flag the view for re-highlighting.
            // Example of where this helps: load Moby Dick, start playback in Ch 1, go to Ch 2 from Toc, back to Ch 1, back to Ch 2. 
            // the highlight for the first phrase of the spine item isn't consistent without this rehighlighting function.
            else {
                reflowableView.flagRehighlight();
            }
		}
	},	
    

	// reflowable pagination uses default readium themes, which include a 'fade' effect on the inactive MO text
	renderReflowableMoPlaying: function(currentTheme, MOIsPlaying, reflowableView) {
		
        // if we are using the author's default style for highlighting, then just clear it if we are not playing
        if (this.authorActiveClassExists()) {
            if (!MOIsPlaying) {
        		// get rid of the last highlight
        		var body = reflowableView.getBody();
                var lastFrag = this.removeActiveClass(body);
            }
        }
        else {
    		if (currentTheme === "default") { 
    			currentTheme = "default-theme";
    		}
        
    		var body = reflowableView.getBody();
            if (MOIsPlaying) {
                // change the color of the body text so it looks inactive compared to the MO fragment that is playing
    			$(body).css("color", reflowableView.themes[currentTheme]["mo-color"]);
    		}
    		else {
                // reset the color of the text to the theme default
    			$(body).css("color", reflowableView.themes[currentTheme]["color"]);	

                // remove style info from the last MO fragment
                var lastFrag = this.removeActiveClass(reflowableView.getBody());
                if (lastFrag) {
                    $(lastFrag).css("color", "");
                }
    		}
        }
		
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

    getActiveClass: function() {
        var activeClass = this.epubController.packageDocument.get("metadata").active_class;
        if (activeClass == "") {
            // we need an active class value to use, whether the author specified it or not
            activeClass = "-readium-epub-media-overlay-active";
        }
        return activeClass;
    },
    
    // did the author supply an active-class metdata value
    authorActiveClassExists: function() {
        var activeClass = this.epubController.packageDocument.get("metadata").active_class;
        return activeClass == "" ? false : true;
    }
});
(function(window){

window.Acc = {
detailed: [],
title: '',
page: '',
RadioGroup: function(radioGroupObjId, defaultRadioValSelector, callback) {
var rgo = $('#' + radioGroupObjId).get(0),
track = {}, that = this,
select = function(index, force) {
$('#' + rgo.id + ' > *').attr( {
tabindex : '-1',
'aria-selected' : 'false',
'aria-checked' : 'false'
});
$(that.childNodes[index]).attr( {
tabindex : '0',
'aria-selected' : 'true',
'aria-checked' : 'true'
});
if (force) $(that.childNodes[index]).focus();
that.selected = that.childNodes[index];
that.index = index;
if (callback && typeof callback === 'function') callback(that.childNodes[index], that.childNodes);
};
that.childNodes = $('#' + rgo.id + ' > *').each(function(i, o) {
track[o.id] = i;
track.max = i + 1;
$(o).attr( {
tabindex : '-1',
'aria-selected' : 'false',
'aria-checked' : 'false',
'aria-posinset' : track.max
});
}).get();
$('#' + rgo.id + ' > *').attr('aria-setsize', track.max)
.bind( {
click: function(ev) {
if (this != that.selected) select(track[this.id]);
},
keydown : function(ev) {
var k = ev.which || ev.keyCode;
if (k == 37 || k == 38) {
if (that.index > 0)
select(that.index - 1, true);
else
select(track.max - 1, true);
}
else if (k == 39 || k == 40) {
if (that.index < (track.max - 1))
select(that.index + 1, true);
else
select(0, true);
ev.stopPropagation();
}
}
});
that.set = function(id) {
select(track[id]);
};
select(track[$('#' + radioGroupObjId + defaultRadioValSelector).get(0).id]);
}
};

})(window);
/*
 * Readium i18n functions
 *
 */

var elems = document.getElementsByTagName("span");
for (var i = 0; i<elems.length; i++) {
        if (elems[i].id == null) {
                continue;
        }
        if (elems[i].id.indexOf("i18n_html_", 0) == 0) {
                var msg = chrome.i18n.getMessage(elems[i].id);
                if (msg != "") {
                        elems[i].innerHTML = msg;
                }
        } else if (elems[i].id.indexOf("i18n_", 0) == 0) {
                var msg = chrome.i18n.getMessage(elems[i].id);
                if (msg != "") {
                        elems[i].innerText = msg;
                }
        }
}

var titles = document.getElementsByTagName("title");
for (var i = 0; i<titles.length; i++) {
        if (titles[i].id == null) {
                continue;
        }
        if (titles[i].id.indexOf("i18n_html_", 0) == 0) {
                var msg = chrome.i18n.getMessage(titles[i].id);
                if (msg != "") {
                        titles[i].innerHTML = msg;
                }
        } else if (titles[i].id.indexOf("i18n_", 0) == 0) {
                var msg = chrome.i18n.getMessage(titles[i].id);
                if (msg != "") {
                        titles[i].innerText = msg;
                }
        }
}
(function(global) {
    
    var EPUBcfi = {};

    EPUBcfi.Parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "fragment": parse_fragment,
        "path": parse_path,
        "local_path": parse_local_path,
        "indexStep": parse_indexStep,
        "indirectionStep": parse_indirectionStep,
        "terminus": parse_terminus,
        "idAssertion": parse_idAssertion,
        "textLocationAssertion": parse_textLocationAssertion,
        "parameter": parse_parameter,
        "csv": parse_csv,
        "valueNoSpace": parse_valueNoSpace,
        "value": parse_value,
        "escapedSpecialChars": parse_escapedSpecialChars,
        "number": parse_number,
        "integer": parse_integer,
        "space": parse_space,
        "circumflex": parse_circumflex,
        "doubleQuote": parse_doubleQuote,
        "squareBracket": parse_squareBracket,
        "parentheses": parse_parentheses,
        "comma": parse_comma,
        "semicolon": parse_semicolon,
        "equal": parse_equal,
        "character": parse_character
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "fragment";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_fragment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "epubcfi(") {
          result0 = "epubcfi(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"epubcfi(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, pathVal) { 
                
                return { type:"CFIAST", cfiString:pathVal }; 
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal) { 
        
                return { type:"cfiString", path:stepVal, localPath:localPathVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_local_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_indexStep();
        if (result1 === null) {
          result1 = parse_indirectionStep();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_indexStep();
            if (result1 === null) {
              result1 = parse_indirectionStep();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_terminus();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, localPathStepVal, termStepVal) { 
        
                return { steps:localPathStepVal, termStep:termStepVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indexStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indexStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indirectionStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "!/") {
          result0 = "!/";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indirectionStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_terminus() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_textLocationAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, textOffsetValue, textLocAssertVal) { 
        
                return { type:"textTerminus", offsetValue:textOffsetValue, textAssertion:textLocAssertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_idAssertion() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_value();
        if (result0 !== null) {
          result0 = (function(offset, idVal) { 
        
                return idVal; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_textLocationAssertion() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_csv();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_parameter();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, csvVal, paramVal) { 
        
                return { type:"textLocationAssertion", csv:csvVal, parameter:paramVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parameter() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_valueNoSpace();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 61) {
              result2 = "=";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_valueNoSpace();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, paramLHSVal, paramRHSVal) { 
        
                return { type:"parameter", LHSValue:paramLHSVal, RHSValue:paramRHSVal }; 
            })(pos0, result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_csv() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_value();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_value();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preAssertionVal, postAssertionVal) { 
        
                return { type:"csv", preAssertion:preAssertionVal, postAssertion:postAssertionVal }; 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_valueNoSpace() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
          if (result1 === null) {
            result1 = parse_space();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
              if (result1 === null) {
                result1 = parse_space();
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_escapedSpecialChars() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_circumflex();
        if (result0 !== null) {
          result1 = parse_circumflex();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_circumflex();
          if (result0 !== null) {
            result1 = parse_squareBracket();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            result0 = parse_circumflex();
            if (result0 !== null) {
              result1 = parse_parentheses();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              result0 = parse_circumflex();
              if (result0 !== null) {
                result1 = parse_comma();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                result0 = parse_circumflex();
                if (result0 !== null) {
                  result1 = parse_semicolon();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  result0 = parse_circumflex();
                  if (result0 !== null) {
                    result1 = parse_equal();
                    if (result1 !== null) {
                      result0 = [result0, result1];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, escSpecCharVal) { 
                
                return escSpecCharVal[1]; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        if (/^[1-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-9]");
          }
        }
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            pos2 = pos;
            result2 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result2 !== null) {
              if (/^[1-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, intPartVal, fracPartVal) { 
        
                return intPartVal.join('') + "." + fracPartVal.join(''); 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_integer() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 === null) {
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, integerVal) { 
        
                if (integerVal === "0") { 
                  return "0";
                } 
                else { 
                  return integerVal[0].concat(integerVal[1].join(''));
                }
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_space() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_circumflex() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 94) {
          result0 = "^";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"^\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "^"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuote() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return '"'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_squareBracket() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, bracketVal) { return bracketVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parentheses() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, paraVal) { return paraVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comma() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_equal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_character() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 === null) {
          if (/^[A-Z]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Z]");
            }
          }
          if (result0 === null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 45) {
                result0 = "-";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, charVal) { return charVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
 

    // Description: This model contains the implementation for "instructions" included in the EPUB CFI domain specific language (DSL). 
//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). 
//   This object contains a set of functions that implement each of the executable instructions in the AST. 

EPUBcfi.CFIInstructions = {

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	// Description: Follows a step
	// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING
	//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been 
	//   excluded.
	// REFACTORING CANDIDATE: This should be called "followIndexStep"
	getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		// Find the jquery index for the current node
		var $targetNode;
		if (CFIStepValue % 2 == 0) {

			$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}
		else {

			$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}

		return $targetNode;
	},

	// Description: This instruction executes an indirection step, where a resource is retrieved using a 
	//   link contained on a attribute of the target element. The attribute that contains the link differs
	//   depending on the target. 
	// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to 
	//   the cross origin security policy
	followIndirectionStep : function (CFIStepValue, $currNode, $packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

		var that = this;
		var $contentDocument; 
		var $blacklistExcluded;
		var $startElement;
		var $targetNode;

		// TODO: This check must be expanded to all the different types of indirection step
		// Only expects iframes, at the moment
		if ($currNode === undefined || !$currNode.is("iframe")) {

			throw EPUBcfi.NodeTypeError($currNode, "expected an iframe element");
		}

		// Check node type; only iframe indirection is handled, at the moment
		if ($currNode.is("iframe")) {

			// Get content
			$contentDocument = $currNode.contents();

			// Go to the first XHTML element, which will be the first child of the top-level document object
			$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);
			$startElement = $($blacklistExcluded[0]);

			// Follow an index step
			$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return that shit!
			return $targetNode; 
		}

		// TODO: Other types of indirection
		// TODO: $targetNode.is("embed")) : src
		// TODO: ($targetNode.is("object")) : data
		// TODO: ($targetNode.is("image") || $targetNode.is("xlink:href")) : xlink:href
	},

	// Description: Injects an element at the specified text node
	// Arguments: a cfi text termination string, a jquery object to the current node
	textTermination : function ($currNode, textOffset, elementToInject) {

		// Get the first node, this should be a text node
		if ($currNode === undefined) {

			throw EPUBcfi.NodeTypeError($currNode, "expected a terminating node, or node list");
		} 
		else if ($currNode.length === 0) {

			throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "no nodes found for termination condition");
		}

		$currNode = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);
		return $currNode;
	},

	// Description: Checks that the id assertion for the node target matches that on 
	//   the found node. 
	targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {

		if ($foundNode.attr("id") === idAssertion) {

			return true;
		}
		else {

			return false;
		}
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer
	elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var $targetNode;
		var $blacklistExcluded;
		var numElements;
		var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;

		$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);
		numElements = $blacklistExcluded.length;

		if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {

			throw EPUBcfi.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, "");
		}

	    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);
		return $targetNode;
	},

	retrieveItemRefHref : function ($itemRefElement, $packageDocument) {

		return $("#" + $itemRefElement.attr("idref"), $packageDocument).attr("href");
	},

	indexOutOfRange : function (targetIndex, numChildElements) {

		return (targetIndex > numChildElements - 1) ? true : false;
	},

	// Rationale: In order to inject an element into a specific position, access to the parent object 
	//   is required. This is obtained with the jquery parent() method. An alternative would be to 
	//   pass in the parent with a filtered list containing only children that are part of the target text node.
	injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {

		var nodeNum;
		var currNodeLength;
		var currTextPosition = 0;
		var nodeOffset;
		var originalText;
		var $injectedNode;
		var $newTextNode;
		// The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)
		for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {

			if ($textNodeList[nodeNum].nodeType === 3) {

				currNodeMaxIndex = ($textNodeList[nodeNum].nodeValue.length - 1) + currTextPosition;
				nodeOffset = textOffset - currTextPosition;

				if (currNodeMaxIndex >= textOffset) {

					// This node is going to be split and the components re-inserted
					originalText = $textNodeList[nodeNum].nodeValue;	

					// Before part
				 	$textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);

					// Injected element
					$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));

					// After part
					$newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));
					$($newTextNode).insertAfter($injectedNode);

					return $textNodeList.parent();
				}
				else {

					currTextPosition = currTextPosition + currNodeMaxIndex;
				}
			}
		}

		throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "The offset exceeded the length of the text");
	},

	// Description: This method finds a target text node and then injects an element into the appropriate node
	// Arguments: A step value that is an odd integer. A current node with a set of child elements.
	// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to 
	//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that
	//   the set of nodes that compromised the original target text node are inferred and returned.
	// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, 
	//   element nodes (maybe), or possibly a mix. 
	// REFACTORING CANDIDATE: This method is pretty long. Worth investigating to see if it can be refactored into something clearer.
	inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {
		
		var $elementsWithoutMarkers;
		var currTextNodePosition;
		var logicalTargetPosition;
		var nodeNum;
		var $targetTextNodeList;

		// Remove any cfi marker elements from the set of elements. 
		// Rationale: A filtering function is used, as simply using a class selector with jquery appears to 
		//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.
		$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

		// Convert CFIStepValue to logical index; assumes odd integer for the step value
		logicalTargetPosition = (parseInt(CFIStepValue) + 1) / 2;

		// Set text node position counter
		currTextNodePosition = 1;
		$targetTextNodeList = $elementsWithoutMarkers.filter(
			function () {

				if (currTextNodePosition === logicalTargetPosition) {

					// If it's a text node
					if (this.nodeType === 3) {
						return true; 
					}
					// Any other type of node, move onto the next text node
					else {
						currTextNodePosition++; 
						return false;
					}
				}
				// In this case, don't return any elements
				else {

					// If its the last child and it's not a text node, there are no text nodes after it
					// and the currTextNodePosition shouldn't be incremented
					if (this.nodeType !== 3 && this !== $elementsWithoutMarkers.lastChild) {
						currTextNodePosition++;
					}

					return false;
				}
			}
		);

		// The filtering above should have counted the number of "logical" text nodes; this can be used to 
		// detect out of range errors
		if ($targetTextNodeList.length === 0) {

			throw EPUBcfi.OutOfRangeError(logicalTargetPosition, currTextNodePosition - 1, "Index out of range");
		}

		// return the text node list
		return $targetTextNodeList;
	},

	applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {

        var $filteredElements;

        $filteredElements = $elements.filter(
            function () {

                var $currElement = $(this);
                var includeInList = true;

                if (classBlacklist) {

                	// Filter each element with the class type
                	$.each(classBlacklist, function (index, value) {

	                    if ($currElement.hasClass(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
                	});
                }

                if (elementBlacklist) {
                	
	                // For each type of element
	                $.each(elementBlacklist, function (index, value) {

	                    if ($currElement.is(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

				if (idBlacklist) {
                	
	                // For each type of element
	                $.each(idBlacklist, function (index, value) {

	                    if ($currElement.attr("id") === value) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

                return includeInList;
            }
        );

        return $filteredElements;
    }
};




    // Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter
//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will
//   represent the position or area in the EPUB referenced by a CFI.
// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the
//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a
//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps 
//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references
//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is 
//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to 
//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. 
// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. 
//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. 
// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. 
//   Whoops. There shouldn't be any interference, however, I think this should be changed. 

EPUBcfi.Interpreter = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Find the content document referenced by the spine item. This should be the spine item 
    //   referenced by the first indirection step in the CFI.
    // Rationale: This method is a part of the API so that the reading system can "interact" the content document 
    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with 
    //   the reading system, as it stands now. 
    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // Decode for URI/IRI escape characters
        var $packageDocument = $(packageDocument);
        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

        // Check node type; throw error if wrong type
        if (CFIAST === undefined || CFIAST.type !== "CFIAST") { 

            throw EPUBcfi.NodeTypeError(CFIAST, "expected CFI AST root node");
        }

        var $packageElement = $($("package", $packageDocument)[0]);

        // Interpet the path node (the package document step)
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the local_path node, which is a set of steps and and a terminus condition
        var stepNum = 0;
        var nextStepNode;
        for (stepNum = 0 ; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, $packageDocument, classBlacklist, elementBlacklist, idBlacklist);
            }

            // Found the content document href referenced by the spine item 
            if ($currElement.is("itemref")) {

                return EPUBcfi.CFIInstructions.retrieveItemRefHref($currElement, $packageDocument);
            }
        }

        // TODO: If you get to here, an itemref element was never found - a runtime error. The cfi is misspecified or 
        //   the package document is messed up.
    },

    // Description: Inject an arbirtary html element into a position in a content document referenced by a CFI
    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

        // Find the first indirection step in the local path; follow it like a regular step, as the content document it 
        //   references is already loaded and has been passed to this method
        var stepNum = 0;
        var nextStepNode;
        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indirectionStep") {

                // This is now assuming that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
                nextStepNode.type = "indexStep";
                // Getting the html element and creating a jquery object for it; excluding cfiMarkers
                $currElement = this.interpretIndexStepNode(nextStepNode, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);
                stepNum++ // Increment the step num as this will be passed as the starting point for continuing interpretation
                break;
            }
        }

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, stepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented
        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);

        // Return the element that was injected into
        return $currElement;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    interpretLocalPath : function (cfiStringNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        var stepNum = startStepNum;
        var nextStepNode;
        for (stepNum; stepNum <= cfiStringNode.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = cfiStringNode.localPath.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, $packageDocument, classBlacklist, elementBlacklist, idBlacklist);
            }
        }

        return $currElement;
    },

    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indexStepNode === undefined || indexStepNode.type !== "indexStep") {

            throw EPUBcfi.NodeTypeError(indexStepNode, "expected index step node");
        }

        // Index step
        var $stepTarget = EPUBcfi.CFIInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Check the id assertion, if it exists
        if (indexStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, $packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indirectionStepNode === undefined || indirectionStepNode.type !== "indirectionStep") {

            throw EPUBcfi.NodeTypeError(indirectionStepNode, "expected indirection step node");
        }

        // Indirection step
        var $stepTarget = EPUBcfi.CFIInstructions.followIndirectionStep(
            indirectionStepNode.stepLength, 
            $currElement,
            $packageDocument, 
            classBlacklist, 
            elementBlacklist);

        // Check the id assertion, if it exists
        if (indirectionStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {

        if (terminusNode === undefined || terminusNode.type !== "textTerminus") {

            throw EPUBcfi.NodeTypeError(terminusNode, "expected text terminus node");
        }

        var $elementInjectedInto = EPUBcfi.CFIInstructions.textTermination(
            $currElement, 
            terminusNode.offsetValue, 
            elementToInject);

        return $elementInjectedInto;
    }
};

    // Description: This is a set of runtime errors that the CFI interpreter can throw. 
// Rationale: These error types extend the basic javascript error object so error things like the stack trace are 
//   included with the runtime errors. 

// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, 
//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors
//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.
EPUBcfi.NodeTypeError = function (node, message) {

    function NodeTypeError () {

        this.node = node;
    }

    NodeTypeError.prototype = new Error(message);
    NodeTypeError.constructor = NodeTypeError;

    return new NodeTypeError();
};

// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.
EPUBcfi.OutOfRangeError = function (targetIndex, maxIndex, message) {

    function OutOfRangeError () {

        this.targetIndex = targetIndex;
        this.maxIndex = maxIndex;
    }

    OutOfRangeError.prototype = new Error(message);
    OutOfRangeError.constructor = OutOfRangeError()

    return new OutOfRangeError();
};

// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors
//   that can occur with the various terminus conditions, it'll make more sense to revisit this. 
EPUBcfi.TerminusError = function (terminusType, terminusCondition, message) {

    function TerminusError () {

        this.terminusType = terminusType;
        this.terminusCondition = terminusCondition;
    }

    TerminusError.prototype = new Error(message);
    TerminusError.constructor = TerminusError();

    return new TerminusError();
};

EPUBcfi.CFIAssertionError = function (expectedAssertion, targetElementAssertion, message) {

    function CFIAssertionError () {

        this.expectedAssertion = expectedAssertion;
        this.targetElementAssertion = targetElementAssertion;
    }

    CFIAssertionError.prototype = new Error(message);
    CFIAssertionError.constructor = CFIAssertionError();

    return new CFIAssertionError();
};


    EPUBcfi.Generator = {

    // Description: Generates a character offset CFI 
    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the 
    //   content document that contains the text node, the package document for this EPUB.
    generateCharacterOffsetCFI : function (startTextNode, characterOffset, contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // ------------------------------------------------------------------------------------ //
        //  "PUBLIC" METHODS (THE API)                                                          //
        // ------------------------------------------------------------------------------------ //

        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        // Check that the text node to start from IS a text node
        if (!startTextNode) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        } else if (startTextNode.nodeType != 3) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        }

        // Check that the character offset is within a valid range for the text node supplied
        if (characterOffset < 0) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, 0, "Character offset cannot be less than 0");
        }
        else if (characterOffset > startTextNode.nodeValue.length) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, "character offset cannot be greater than the length of the text node");
        }

        // Check that the idref for the content document has been provided
        if (!contentDocumentName) {
            throw new Error("The idref for the content document, as found in the spine, must be supplied");
        }

        // Check that the package document is non-empty and contains an itemref element for the supplied idref
        if (!packageDocument) {
            throw new Error("A package document must be supplied to generate a CFI");
        }
        else if ($($("itemref[idref='" + contentDocumentName + "']", packageDocument)[0]).length === 0) {
            throw new Error("The idref of the content document could not be found in the spine");
        }

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startTextNode), characterOffset, "html", classBlacklist, elementBlacklist, idBlacklist);

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFI = this.createCFIElementSteps($itemRefStartNode, characterOffset, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Return the CFI wrapped with "epubcfi()"
        return "epubcfi(" + packageDocCFI + contentDocCFI + ")";
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    // Description: Creates a CFI terminating step, to a text node, with a character offset
    // Arguments:
    // Rationale:
    // Notes:
    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods
    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var CFIIndex;
        var indexOfTextNode;
        var preAssertion;
        var preAssertionStartIndex;
        var textLength;
        var postAssertion;
        var postAssertionEndIndex;

        // Find text node position in the set of child elements, ignoring any blacklisted elements 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node index in the parent list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var indexOfFirstInSequence;
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this 
                        //   node is a standard one sandwiched between two element nodes. 
                        if (prevNodeWasTextNode) {
                            indexOfTextNode = indexOfFirstInSequence;
                        }
                        else {
                            indexOfTextNode = index;
                        }
                        
                        // Break out of .each loop
                        return false; 
                    }

                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point
                    prevNodeWasTextNode = true;
                    if (!indexOfFirstInSequence) {
                        indexOfFirstInSequence = index;
                    }
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                    indexOfFirstInSequence = undefined;
                }
            }
        );

        // Convert the text node index to a CFI odd-integer representation
        CFIIndex = (indexOfTextNode * 2) + 1;

        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has
        //   been temporarily removed. 

        // Add pre- and post- text assertions
        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;
        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);

        // textLength = $startTextNode[0].nodeValue.length;
        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;
        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);

        // Gotta infer the correct character offset, as well

        // Return the constructed CFI text node step
        return "/" + CFIIndex + ":" + characterOffset;
         // + "[" + preAssertion + "," + postAssertion + "]";
    },

    // Description: A set of adjacent text nodes can be inferred to have been a single text node in the original document. As such, 
    //   if the character offset is specified for one of the adjacent text nodes, the true offset for the original node must be
    //   inferred.
    findOriginalTextNodeCharOffset : function ($startTextNode, specifiedCharacterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var textLength;
        
        // Find text node position in the set of child elements, ignoring any cfi markers 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node number in the list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var originalCharOffset = -1; // So the character offset is a 0-based index; we'll be adding lengths of text nodes to this number
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        if (prevNodeWasTextNode) {
                            originalCharOffset = originalCharOffset + specifiedCharacterOffset;
                        }
                        else {
                            originalCharOffset = specifiedCharacterOffset;
                        }

                        return false; // Break out of .each loop
                    }
                    else {

                        originalCharOffset = originalCharOffset + this.length;
                    }

                    // save this index as the first in sequence of adjacent text nodes, if not set
                    prevNodeWasTextNode = true;
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                }
            }
        );

        return originalCharOffset;
    },

    // REFACTORING CANDIDATE: Consider putting the handling of the starting text node into the body of the 
    //   generateCharacterOffsetCfi() method; this way the characterOffset argument could be removed, which 
    //   would clarify the abstraction
    createCFIElementSteps : function ($currNode, characterOffset, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {

        var textNodeStep;
        var $blacklistExcluded;
        var $parentNode;
        var currNodePosition;
        var CFIPosition;
        var idAssertion;
        var elementStep; 

        if ($currNode[0].nodeType === 3) {

            textNodeStep = this.createCFITextNodeStep($currNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);
            return this.createCFIElementSteps($currNode.parent(), characterOffset, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + textNodeStep; 
        }

        // Find position of current node in parent list
        $blacklistExcluded = EPUBcfi.CFIInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);
        $.each($blacklistExcluded, 
            function (index, value) {

                if (this === $currNode[0]) {

                    currNodePosition = index;

                    // Break loop
                    return false;
                }
        });

        // Convert position to the CFI even-integer representation
        CFIPosition = (currNodePosition + 1) * 2;

        // Create CFI step with id assertion, if the element has an id
        if ($currNode.attr("id")) {
            elementStep = "/" + CFIPosition + "[" + $currNode.attr("id") + "]";
        }
        else {
            elementStep = "/" + CFIPosition;
        }

        // If a parent is an html element return the (last) step for this content document, otherwise, continue
        $parentNode = $currNode.parent();
        if ($parentNode.is(topLevelElement)) {
            
            // If the top level node is a type from which an indirection step, add an indirection step character (!)
            // REFACTORING CANDIDATE: It is possible that this should be changed to if (topLevelElement = 'package') do
            //   not return an indirection character. Every other type of top-level element may require an indirection
            //   step to navigate to, thus requiring that ! is always prepended. 
            if (topLevelElement === 'html') {
                return "!" + elementStep;
            }
            else {
                return elementStep;
            }
        }
        else {
            return this.createCFIElementSteps($parentNode, characterOffset, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;
        }
    }
};

    if (global.EPUBcfi) {

        throw new Error('The EPUB cfi library has already been defined');
    }
    else {

        global.EPUBcfi = EPUBcfi;
    }
}) (typeof window === 'undefined' ? this : window);
/*
Copyright 2012 Igor Vaynberg
 
Version: 3.2 Timestamp: Mon Sep 10 10:38:04 PDT 2012

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in
compliance with the License. You may obtain a copy of the License in the LICENSE file, or at:

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
*/
(function(e){"undefined"==typeof e.fn.each2&&e.fn.extend({each2:function(g){for(var i=e([0]),m=-1,s=this.length;++m<s&&(i.context=i[0]=this[m])&&!1!==g.call(i[0],m,i););return this}})})(jQuery);
(function(e,g){function i(a,b){var c=0,d=b.length,j;if("undefined"===typeof a)return-1;if(a.constructor===String)for(;c<d;c+=1){if(0===a.localeCompare(b[c]))return c}else for(;c<d;c+=1)if(j=b[c],j.constructor===String){if(0===j.localeCompare(a))return c}else if(j===a)return c;return-1}function m(a,b){return a===b?!0:a===g||b===g||null===a||null===b?!1:a.constructor===String?0===a.localeCompare(b):b.constructor===String?0===b.localeCompare(a):!1}function s(a,b){var c,d,j;if(null===a||1>a.length)return[];
c=a.split(b);d=0;for(j=c.length;d<j;d+=1)c[d]=e.trim(c[d]);return c}function A(a,b,c){var c=c||g,d;return function(){var j=arguments;window.clearTimeout(d);d=window.setTimeout(function(){b.apply(c,j)},a)}}function l(a){a.preventDefault();a.stopPropagation()}function B(a,b,c){var d=a.toUpperCase().indexOf(b.toUpperCase()),b=b.length;0>d?c.push(a):(c.push(a.substring(0,d)),c.push("<span class='select2-match'>"),c.push(a.substring(d,d+b)),c.push("</span>"),c.push(a.substring(d+b,a.length)))}function C(a){var b,
c=0,d=null,j=a.quietMillis||100;return function(h){window.clearTimeout(b);b=window.setTimeout(function(){var b=c+=1,j=a.data,n=a.transport||e.ajax,f=a.traditional||!1,g=a.type||"GET",j=j.call(this,h.term,h.page,h.context);null!==d&&d.abort();d=n.call(null,{url:a.url,dataType:a.dataType,data:j,type:g,traditional:f,success:function(d){b<c||(d=a.results(d,h.page),h.callback(d))}})},j)}}function D(a){var b=a,c,d=function(a){return""+a.text};e.isArray(b)||(d=b.text,e.isFunction(d)||(c=b.text,d=function(a){return a[c]}),
b=b.results);return function(a){var c=a.term,f={results:[]},k;if(c==="")a.callback({results:b});else{k=function(b,f){var g,t,b=b[0];if(b.children){g={};for(t in b)b.hasOwnProperty(t)&&(g[t]=b[t]);g.children=[];e(b.children).each2(function(a,b){k(b,g.children)});g.children.length&&f.push(g)}else a.matcher(c,d(b))&&f.push(b)};e(b).each2(function(a,b){k(b,f.results)});a.callback(f)}}}function E(a){return e.isFunction(a)?a:function(b){var c=b.term,d={results:[]};e(a).each(function(){var a=this.text!==
g,e=a?this.text:this;if(""===c||b.matcher(c,e))d.results.push(a?this:{id:this,text:this})});b.callback(d)}}function u(a){if(e.isFunction(a))return!0;if(!a)return!1;throw Error("formatterName must be a function or a falsy value");}function v(a){return e.isFunction(a)?a():a}function F(a){var b=0;e.each(a,function(a,d){d.children?b+=F(d.children):b++});return b}function H(a,b,c,d){var e=a,h=!1,f,k,n,o;if(!d.createSearchChoice||!d.tokenSeparators||1>d.tokenSeparators.length)return g;for(;;){h=-1;k=0;
for(n=d.tokenSeparators.length;k<n&&!(o=d.tokenSeparators[k],h=a.indexOf(o),0<=h);k++);if(0>h)break;f=a.substring(0,h);a=a.substring(h+o.length);if(0<f.length&&(f=d.createSearchChoice(f,b),f!==g&&null!==f&&d.id(f)!==g&&null!==d.id(f))){h=!1;k=0;for(n=b.length;k<n;k++)if(m(d.id(f),d.id(b[k]))){h=!0;break}h||c(f)}}if(0!=e.localeCompare(a))return a}function x(a,b){var c=function(){};c.prototype=new a;c.prototype.constructor=c;c.prototype.parent=a.prototype;c.prototype=e.extend(c.prototype,b);return c}
if(window.Select2===g){var f,w,y,z,G,q;f={TAB:9,ENTER:13,ESC:27,SPACE:32,LEFT:37,UP:38,RIGHT:39,DOWN:40,SHIFT:16,CTRL:17,ALT:18,PAGE_UP:33,PAGE_DOWN:34,HOME:36,END:35,BACKSPACE:8,DELETE:46,isArrow:function(a){a=a.which?a.which:a;switch(a){case f.LEFT:case f.RIGHT:case f.UP:case f.DOWN:return!0}return!1},isControl:function(a){switch(a.which){case f.SHIFT:case f.CTRL:case f.ALT:return!0}return a.metaKey?!0:!1},isFunctionKey:function(a){a=a.which?a.which:a;return 112<=a&&123>=a}};var I=1;G=function(){return I++};
e(document).delegate("body","mousemove",function(a){e.data(document,"select2-lastpos",{x:a.pageX,y:a.pageY})});e(document).ready(function(){e(document).delegate("body","mousedown touchend",function(a){var b=e(a.target).closest("div.select2-container").get(0),c;b?e(document).find("div.select2-container-active").each(function(){this!==b&&e(this).data("select2").blur()}):(b=e(a.target).closest("div.select2-drop").get(0),e(document).find("div.select2-drop-active").each(function(){this!==b&&e(this).data("select2").blur()}));
b=e(a.target);c=b.attr("for");"LABEL"===a.target.tagName&&(c&&0<c.length)&&(b=e("#"+c),b=b.data("select2"),b!==g&&(b.focus(),a.preventDefault()))})});w=x(Object,{bind:function(a){var b=this;return function(){a.apply(b,arguments)}},init:function(a){var b,c;this.opts=a=this.prepareOpts(a);this.id=a.id;a.element.data("select2")!==g&&null!==a.element.data("select2")&&this.destroy();this.enabled=!0;this.container=this.createContainer();this.containerId="s2id_"+(a.element.attr("id")||"autogen"+G());this.containerSelector=
"#"+this.containerId.replace(/([;&,\.\+\*\~':"\!\^#$%@\[\]\(\)=>\|])/g,"\\$1");this.container.attr("id",this.containerId);var d=!1,j;this.body=function(){!1===d&&(j=a.element.closest("body"),d=!0);return j};a.element.attr("class")!==g&&this.container.addClass(a.element.attr("class").replace(/validate\[[\S ]+] ?/,""));this.container.css(v(a.containerCss));this.container.addClass(v(a.containerCssClass));this.opts.element.data("select2",this).hide().before(this.container);this.container.data("select2",
this);this.dropdown=this.container.find(".select2-drop");this.dropdown.addClass(v(a.dropdownCssClass));this.dropdown.data("select2",this);this.results=b=this.container.find(".select2-results");this.search=c=this.container.find("input.select2-input");c.attr("tabIndex",this.opts.element.attr("tabIndex"));this.resultsPage=0;this.context=null;this.initContainer();this.initContainerWidth();this.results.bind("mousemove",function(a){var b=e.data(document,"select2-lastpos");(b===g||b.x!==a.pageX||b.y!==a.pageY)&&
e(a.target).trigger("mousemove-filtered",a)});this.dropdown.delegate(".select2-results","mousemove-filtered",this.bind(this.highlightUnderEvent));var h=this.results,f=A(80,function(a){h.trigger("scroll-debounced",a)});h.bind("scroll",function(a){0<=i(a.target,h.get())&&f(a)});this.dropdown.delegate(".select2-results","scroll-debounced",this.bind(this.loadMoreIfNeeded));e.fn.mousewheel&&b.mousewheel(function(a,c,d,e){c=b.scrollTop();0<e&&0>=c-e?(b.scrollTop(0),l(a)):0>e&&b.get(0).scrollHeight-b.scrollTop()+
e<=b.height()&&(b.scrollTop(b.get(0).scrollHeight-b.height()),l(a))});c.bind("keydown",function(){e.data(c,"keyup-change-value")===g&&e.data(c,"keyup-change-value",c.val())});c.bind("keyup",function(){var a=e.data(c,"keyup-change-value");a!==g&&c.val()!==a&&(e.removeData(c,"keyup-change-value"),c.trigger("keyup-change"))});c.bind("keyup-change",this.bind(this.updateResults));c.bind("focus",function(){c.addClass("select2-focused");" "===c.val()&&c.val("")});c.bind("blur",function(){c.removeClass("select2-focused")});
this.dropdown.delegate(".select2-results","mouseup",this.bind(function(a){0<e(a.target).closest(".select2-result-selectable:not(.select2-disabled)").length?(this.highlightUnderEvent(a),this.selectHighlighted(a)):this.focusSearch();l(a)}));this.dropdown.bind("click mouseup mousedown",function(a){a.stopPropagation()});e.isFunction(this.opts.initSelection)&&(this.initSelection(),this.monitorSource());(a.element.is(":disabled")||a.element.is("[readonly='readonly']"))&&this.disable()},destroy:function(){var a=
this.opts.element.data("select2");a!==g&&(a.container.remove(),a.dropdown.remove(),a.opts.element.removeData("select2").unbind(".select2").show())},prepareOpts:function(a){var b,c,d;b=a.element;"select"===b.get(0).tagName.toLowerCase()&&(this.select=c=a.element);c&&e.each("id multiple ajax query createSearchChoice initSelection data tags".split(" "),function(){if(this in a)throw Error("Option '"+this+"' is not allowed for Select2 when attached to a <select> element.");});a=e.extend({},{populateResults:function(b,
c,d){var f,n=this.opts.id,o=this;f=function(b,c,j){var h,l,i,m,r,p,q;h=0;for(l=b.length;h<l;h=h+1){i=b[h];m=n(i)!==g;r=i.children&&i.children.length>0;p=e("<li></li>");p.addClass("select2-results-dept-"+j);p.addClass("select2-result");p.addClass(m?"select2-result-selectable":"select2-result-unselectable");r&&p.addClass("select2-result-with-children");p.addClass(o.opts.formatResultCssClass(i));m=e("<div></div>");m.addClass("select2-result-label");q=a.formatResult(i,m,d);q!==g&&m.html(o.opts.escapeMarkup(q));
p.append(m);if(r){r=e("<ul></ul>");r.addClass("select2-result-sub");f(i.children,r,j+1);p.append(r)}p.data("select2-data",i);c.append(p)}};f(c,b,0)}},e.fn.select2.defaults,a);"function"!==typeof a.id&&(d=a.id,a.id=function(a){return a[d]});if(c)a.query=this.bind(function(a){var c={results:[],more:false},d=a.term,f,n,o;o=function(b,c){var e;if(b.is("option"))a.matcher(d,b.text(),b)&&c.push({id:b.attr("value"),text:b.text(),element:b.get(),css:b.attr("class")});else if(b.is("optgroup")){e={text:b.attr("label"),
children:[],element:b.get(),css:b.attr("class")};b.children().each2(function(a,b){o(b,e.children)});e.children.length>0&&c.push(e)}};f=b.children();if(this.getPlaceholder()!==g&&f.length>0){n=f[0];e(n).text()===""&&(f=f.not(n))}f.each2(function(a,b){o(b,c.results)});a.callback(c)}),a.id=function(a){return a.id},a.formatResultCssClass=function(a){return a.css};else if(!("query"in a))if("ajax"in a){if((c=a.element.data("ajax-url"))&&0<c.length)a.ajax.url=c;a.query=C(a.ajax)}else"data"in a?a.query=D(a.data):
"tags"in a&&(a.query=E(a.tags),a.createSearchChoice=function(a){return{id:a,text:a}},a.initSelection=function(b,c){var d=[];e(s(b.val(),a.separator)).each(function(){var b=this,c=this,j=a.tags;e.isFunction(j)&&(j=j());e(j).each(function(){if(m(this.id,b)){c=this.text;return false}});d.push({id:b,text:c})});c(d)});if("function"!==typeof a.query)throw"query function not defined for Select2 "+a.element.attr("id");return a},monitorSource:function(){this.opts.element.bind("change.select2",this.bind(function(){!0!==
this.opts.element.data("select2-change-triggered")&&this.initSelection()}))},triggerChange:function(a){a=a||{};a=e.extend({},a,{type:"change",val:this.val()});this.opts.element.data("select2-change-triggered",!0);this.opts.element.trigger(a);this.opts.element.data("select2-change-triggered",!1);this.opts.element.click();this.opts.blurOnChange&&this.opts.element.blur()},enable:function(){this.enabled||(this.enabled=!0,this.container.removeClass("select2-container-disabled"))},disable:function(){this.enabled&&
(this.close(),this.enabled=!1,this.container.addClass("select2-container-disabled"))},opened:function(){return this.container.hasClass("select2-dropdown-open")},positionDropdown:function(){var a=this.container.offset(),b=this.container.outerHeight(),c=this.container.outerWidth(),d=this.dropdown.outerHeight(),j=e(window).scrollTop()+document.documentElement.clientHeight,b=a.top+b,f=a.left,j=b+d<=j,g=a.top-d>=this.body().scrollTop(),k=this.dropdown.hasClass("select2-drop-above"),n;"static"!==this.body().css("position")&&
(n=this.body().offset(),b-=n.top,f-=n.left);k?(k=!0,!g&&j&&(k=!1)):(k=!1,!j&&g&&(k=!0));k?(b=a.top-d,this.container.addClass("select2-drop-above"),this.dropdown.addClass("select2-drop-above")):(this.container.removeClass("select2-drop-above"),this.dropdown.removeClass("select2-drop-above"));a=e.extend({top:b,left:f,width:c},v(this.opts.dropdownCss));this.dropdown.css(a)},shouldOpen:function(){var a;if(this.opened())return!1;a=e.Event("open");this.opts.element.trigger(a);return!a.isDefaultPrevented()},
clearDropdownAlignmentPreference:function(){this.container.removeClass("select2-drop-above");this.dropdown.removeClass("select2-drop-above")},open:function(){if(!this.shouldOpen())return!1;window.setTimeout(this.bind(this.opening),1);return!0},opening:function(){var a=this.containerId,b=this.containerSelector,c="scroll."+a,d="resize."+a;this.container.parents().each(function(){e(this).bind(c,function(){var a=e(b);0==a.length&&e(this).unbind(c);a.select2("close")})});e(window).bind(d,function(){var a=
e(b);0==a.length&&e(window).unbind(d);a.select2("close")});this.clearDropdownAlignmentPreference();" "===this.search.val()&&this.search.val("");this.container.addClass("select2-dropdown-open").addClass("select2-container-active");this.updateResults(!0);this.dropdown[0]!==this.body().children().last()[0]&&this.dropdown.detach().appendTo(this.body());this.dropdown.show();this.positionDropdown();this.dropdown.addClass("select2-drop-active");this.ensureHighlightVisible();this.focusSearch()},close:function(){if(this.opened()){var a=
this;this.container.parents().each(function(){e(this).unbind("scroll."+a.containerId)});e(window).unbind("resize."+this.containerId);this.clearDropdownAlignmentPreference();this.dropdown.hide();this.container.removeClass("select2-dropdown-open").removeClass("select2-container-active");this.results.empty();this.clearSearch();this.opts.element.trigger(e.Event("close"))}},clearSearch:function(){},ensureHighlightVisible:function(){var a=this.results,b,c,d,f;c=this.highlight();0>c||(0==c?a.scrollTop(0):
(b=a.find(".select2-result-selectable"),d=e(b[c]),f=d.offset().top+d.outerHeight(),c===b.length-1&&(b=a.find("li.select2-more-results"),0<b.length&&(f=b.offset().top+b.outerHeight())),b=a.offset().top+a.outerHeight(),f>b&&a.scrollTop(a.scrollTop()+(f-b)),d=d.offset().top-a.offset().top,0>d&&a.scrollTop(a.scrollTop()+d)))},moveHighlight:function(a){for(var b=this.results.find(".select2-result-selectable"),c=this.highlight();-1<c&&c<b.length;){var c=c+a,d=e(b[c]);if(d.hasClass("select2-result-selectable")&&
!d.hasClass("select2-disabled")){this.highlight(c);break}}},highlight:function(a){var b=this.results.find(".select2-result-selectable").not(".select2-disabled");if(0===arguments.length)return i(b.filter(".select2-highlighted")[0],b.get());a>=b.length&&(a=b.length-1);0>a&&(a=0);b.removeClass("select2-highlighted");e(b[a]).addClass("select2-highlighted");this.ensureHighlightVisible()},countSelectableResults:function(){return this.results.find(".select2-result-selectable").not(".select2-disabled").length},
highlightUnderEvent:function(a){a=e(a.target).closest(".select2-result-selectable");if(0<a.length&&!a.is(".select2-highlighted")){var b=this.results.find(".select2-result-selectable");this.highlight(b.index(a))}else 0==a.length&&this.results.find(".select2-highlighted").removeClass("select2-highlighted")},loadMoreIfNeeded:function(){var a=this.results,b=a.find("li.select2-more-results"),c,d=this.resultsPage+1,e=this,f=this.search.val(),g=this.context;0!==b.length&&(c=b.offset().top-a.offset().top-
a.height(),0>=c&&(b.addClass("select2-active"),this.opts.query({term:f,page:d,context:g,matcher:this.opts.matcher,callback:this.bind(function(c){e.opened()&&(e.opts.populateResults.call(this,a,c.results,{term:f,page:d,context:g}),!0===c.more?(b.detach().appendTo(a).text(e.opts.formatLoadMore(d+1)),window.setTimeout(function(){e.loadMoreIfNeeded()},10)):b.remove(),e.positionDropdown(),e.resultsPage=d)})})))},tokenize:function(){},updateResults:function(a){function b(){f.scrollTop(0);d.removeClass("select2-active");
k.positionDropdown()}function c(a){f.html(k.opts.escapeMarkup(a));b()}var d=this.search,f=this.results,h=this.opts,i,k=this;if(!(!0!==a&&(!1===this.showSearchInput||!this.opened()))){d.addClass("select2-active");if(1<=h.maximumSelectionSize&&(i=this.data(),e.isArray(i)&&i.length>=h.maximumSelectionSize&&u(h.formatSelectionTooBig,"formatSelectionTooBig"))){c("<li class='select2-selection-limit'>"+h.formatSelectionTooBig(h.maximumSelectionSize)+"</li>");return}d.val().length<h.minimumInputLength&&u(h.formatInputTooShort,
"formatInputTooShort")?c("<li class='select2-no-results'>"+h.formatInputTooShort(d.val(),h.minimumInputLength)+"</li>"):(c("<li class='select2-searching'>"+h.formatSearching()+"</li>"),i=this.tokenize(),i!=g&&null!=i&&d.val(i),this.resultsPage=1,h.query({term:d.val(),page:this.resultsPage,context:null,matcher:h.matcher,callback:this.bind(function(i){var l;this.opened()&&((this.context=i.context===g?null:i.context,this.opts.createSearchChoice&&""!==d.val()&&(l=this.opts.createSearchChoice.call(null,
d.val(),i.results),l!==g&&null!==l&&k.id(l)!==g&&null!==k.id(l)&&0===e(i.results).filter(function(){return m(k.id(this),k.id(l))}).length&&i.results.unshift(l)),0===i.results.length&&u(h.formatNoMatches,"formatNoMatches"))?c("<li class='select2-no-results'>"+h.formatNoMatches(d.val())+"</li>"):(f.empty(),k.opts.populateResults.call(this,f,i.results,{term:d.val(),page:this.resultsPage,context:null}),!0===i.more&&u(h.formatLoadMore,"formatLoadMore")&&(f.append("<li class='select2-more-results'>"+k.opts.escapeMarkup(h.formatLoadMore(this.resultsPage))+
"</li>"),window.setTimeout(function(){k.loadMoreIfNeeded()},10)),this.postprocessResults(i,a),b()))})}))}},cancel:function(){this.close()},blur:function(){this.close();this.container.removeClass("select2-container-active");this.dropdown.removeClass("select2-drop-active");this.search[0]===document.activeElement&&this.search.blur();this.clearSearch();this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus")},focusSearch:function(){this.search.show();this.search.focus();
window.setTimeout(this.bind(function(){this.search.show();this.search.focus();this.search.val(this.search.val())}),10)},selectHighlighted:function(){var a=this.highlight(),b=this.results.find(".select2-highlighted").not(".select2-disabled"),c=b.closest(".select2-result-selectable").data("select2-data");c&&(b.addClass("select2-disabled"),this.highlight(a),this.onSelect(c))},getPlaceholder:function(){return this.opts.element.attr("placeholder")||this.opts.element.attr("data-placeholder")||this.opts.element.data("placeholder")||
this.opts.placeholder},initContainerWidth:function(){var a=function(){var a,c,d,f;if("off"===this.opts.width)return null;if("element"===this.opts.width)return 0===this.opts.element.outerWidth()?"auto":this.opts.element.outerWidth()+"px";if("copy"===this.opts.width||"resolve"===this.opts.width){a=this.opts.element.attr("style");if(a!==g){a=a.split(";");d=0;for(f=a.length;d<f;d+=1)if(c=a[d].replace(/\s/g,"").match(/width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/),null!==c&&1<=c.length)return c[1]}return"resolve"===
this.opts.width?(a=this.opts.element.css("width"),0<a.indexOf("%")?a:0===this.opts.element.outerWidth()?"auto":this.opts.element.outerWidth()+"px"):null}return e.isFunction(this.opts.width)?this.opts.width():this.opts.width}.call(this);null!==a&&this.container.attr("style","width: "+a)}});y=x(w,{createContainer:function(){return e("<div></div>",{"class":"select2-container"}).html("    <a href='#' onclick='return false;' class='select2-choice'>   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>   <div><b></b></div></a>    <div class='select2-drop select2-offscreen'>   <div class='select2-search'>       <input type='text' autocomplete='off' class='select2-input'/>   </div>   <ul class='select2-results'>   </ul></div>")},
opening:function(){this.search.show();this.parent.opening.apply(this,arguments);this.dropdown.removeClass("select2-offscreen")},close:function(){this.opened()&&(this.parent.close.apply(this,arguments),this.dropdown.removeAttr("style").addClass("select2-offscreen").insertAfter(this.selection).show())},focus:function(){this.close();this.selection.focus()},isFocused:function(){return this.selection[0]===document.activeElement},cancel:function(){this.parent.cancel.apply(this,arguments);this.selection.focus()},
initContainer:function(){var a,b=this.dropdown;this.selection=a=this.container.find(".select2-choice");this.search.bind("keydown",this.bind(function(a){if(this.enabled)if(a.which===f.PAGE_UP||a.which===f.PAGE_DOWN)l(a);else if(this.opened())switch(a.which){case f.UP:case f.DOWN:this.moveHighlight(a.which===f.UP?-1:1);l(a);break;case f.TAB:case f.ENTER:this.selectHighlighted();l(a);break;case f.ESC:this.cancel(a),l(a)}else a.which===f.TAB||f.isControl(a)||f.isFunctionKey(a)||a.which===f.ESC||!1===
this.opts.openOnEnter&&a.which===f.ENTER||this.open()}));this.search.bind("focus",this.bind(function(){this.selection.attr("tabIndex","-1")}));this.search.bind("blur",this.bind(function(){this.opened()||this.container.removeClass("select2-container-active");window.setTimeout(this.bind(function(){this.selection.attr("tabIndex",this.opts.element.attr("tabIndex"))}),10)}));a.bind("mousedown",this.bind(function(){this.opened()?(this.close(),this.selection.focus()):this.enabled&&this.open()}));b.bind("mousedown",
this.bind(function(){this.search.focus()}));a.bind("focus",this.bind(function(){this.container.addClass("select2-container-active");this.search.attr("tabIndex","-1")}));a.bind("blur",this.bind(function(){this.opened()||this.container.removeClass("select2-container-active");window.setTimeout(this.bind(function(){this.search.attr("tabIndex",this.opts.element.attr("tabIndex"))}),10)}));a.bind("keydown",this.bind(function(a){if(this.enabled)if(a.which===f.PAGE_UP||a.which===f.PAGE_DOWN)l(a);else if(!(a.which===
f.TAB||f.isControl(a)||f.isFunctionKey(a)||a.which===f.ESC)&&!(!1===this.opts.openOnEnter&&a.which===f.ENTER))if(a.which==f.DELETE)this.opts.allowClear&&this.clear();else{this.open();if(a.which!==f.ENTER&&!(48>a.which)){var b=String.fromCharCode(a.which).toLowerCase();a.shiftKey&&(b=b.toUpperCase());this.search.focus();this.search.val(b)}l(a)}}));a.delegate("abbr","mousedown",this.bind(function(a){this.enabled&&(this.clear(),l(a),this.close(),this.triggerChange(),this.selection.focus())}));this.setPlaceholder();
this.search.bind("focus",this.bind(function(){this.container.addClass("select2-container-active")}))},clear:function(){this.opts.element.val("");this.selection.find("span").empty();this.selection.removeData("select2-data");this.setPlaceholder()},initSelection:function(){if(""===this.opts.element.val())this.close(),this.setPlaceholder();else{var a=this;this.opts.initSelection.call(null,this.opts.element,function(b){b!==g&&null!==b&&(a.updateSelection(b),a.close(),a.setPlaceholder())})}},prepareOpts:function(){var a=
this.parent.prepareOpts.apply(this,arguments);"select"===a.element.get(0).tagName.toLowerCase()&&(a.initSelection=function(a,c){var d=a.find(":selected");e.isFunction(c)&&c({id:d.attr("value"),text:d.text()})});return a},setPlaceholder:function(){var a=this.getPlaceholder();""===this.opts.element.val()&&a!==g&&!(this.select&&""!==this.select.find("option:first").text())&&(this.selection.find("span").html(this.opts.escapeMarkup(a)),this.selection.addClass("select2-default"),this.selection.find("abbr").hide())},
postprocessResults:function(a,b){var c=0,d=this,f=!0;this.results.find(".select2-result-selectable").each2(function(a,b){if(m(d.id(b.data("select2-data")),d.opts.element.val()))return c=a,!1});this.highlight(c);!0===b&&(f=this.showSearchInput=F(a.results)>=this.opts.minimumResultsForSearch,this.dropdown.find(".select2-search")[f?"removeClass":"addClass"]("select2-search-hidden"),e(this.dropdown,this.container)[f?"addClass":"removeClass"]("select2-with-searchbox"))},onSelect:function(a){var b=this.opts.element.val();
this.opts.element.val(this.id(a));this.updateSelection(a);this.close();this.selection.focus();m(b,this.id(a))||this.triggerChange()},updateSelection:function(a){var b=this.selection.find("span");this.selection.data("select2-data",a);b.empty();a=this.opts.formatSelection(a,b);a!==g&&b.append(this.opts.escapeMarkup(a));this.selection.removeClass("select2-default");this.opts.allowClear&&this.getPlaceholder()!==g&&this.selection.find("abbr").show()},val:function(){var a,b=null,c=this;if(0===arguments.length)return this.opts.element.val();
a=arguments[0];if(this.select)this.select.val(a).find(":selected").each2(function(a,c){b={id:c.attr("value"),text:c.text()};return!1}),this.updateSelection(b),this.setPlaceholder();else{if(this.opts.initSelection===g)throw Error("cannot call val() if initSelection() is not defined");a?(this.opts.element.val(a),this.opts.initSelection(this.opts.element,function(a){c.opts.element.val(!a?"":c.id(a));c.updateSelection(a);c.setPlaceholder()})):this.clear()}},clearSearch:function(){this.search.val("")},
data:function(a){var b;if(0===arguments.length)return b=this.selection.data("select2-data"),b==g&&(b=null),b;!a||""===a?this.clear():(this.opts.element.val(!a?"":this.id(a)),this.updateSelection(a))}});z=x(w,{createContainer:function(){return e("<div></div>",{"class":"select2-container select2-container-multi"}).html("    <ul class='select2-choices'>  <li class='select2-search-field'>    <input type='text' autocomplete='off' class='select2-input'>  </li></ul><div class='select2-drop select2-drop-multi' style='display:none;'>   <ul class='select2-results'>   </ul></div>")},
prepareOpts:function(){var a=this.parent.prepareOpts.apply(this,arguments);"select"===a.element.get(0).tagName.toLowerCase()&&(a.initSelection=function(a,c){var d=[];a.find(":selected").each2(function(a,b){d.push({id:b.attr("value"),text:b.text()})});e.isFunction(c)&&c(d)});return a},initContainer:function(){var a;this.searchContainer=this.container.find(".select2-search-field");this.selection=a=this.container.find(".select2-choices");this.search.bind("keydown",this.bind(function(b){if(this.enabled){if(b.which===
f.BACKSPACE&&""===this.search.val()){this.close();var c;c=a.find(".select2-search-choice-focus");if(0<c.length){this.unselect(c.first());this.search.width(10);l(b);return}c=a.find(".select2-search-choice");0<c.length&&c.last().addClass("select2-search-choice-focus")}else a.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");if(this.opened())switch(b.which){case f.UP:case f.DOWN:this.moveHighlight(b.which===f.UP?-1:1);l(b);return;case f.ENTER:case f.TAB:this.selectHighlighted();
l(b);return;case f.ESC:this.cancel(b);l(b);return}if(!(b.which===f.TAB||f.isControl(b)||f.isFunctionKey(b)||b.which===f.BACKSPACE||b.which===f.ESC)&&!(!1===this.opts.openOnEnter&&b.which===f.ENTER))this.open(),(b.which===f.PAGE_UP||b.which===f.PAGE_DOWN)&&l(b)}}));this.search.bind("keyup",this.bind(this.resizeSearch));this.search.bind("blur",this.bind(function(a){this.container.removeClass("select2-container-active");this.search.removeClass("select2-focused");this.clearSearch();a.stopImmediatePropagation()}));
this.container.delegate(".select2-choices","mousedown",this.bind(function(a){this.enabled&&!(0<e(a.target).closest(".select2-search-choice").length)&&(this.clearPlaceholder(),this.open(),this.focusSearch(),a.preventDefault())}));this.container.delegate(".select2-choices","focus",this.bind(function(){this.enabled&&(this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"),this.clearPlaceholder())}));this.clearSearch()},enable:function(){this.enabled||(this.parent.enable.apply(this,
arguments),this.search.removeAttr("disabled"))},disable:function(){this.enabled&&(this.parent.disable.apply(this,arguments),this.search.attr("disabled",!0))},initSelection:function(){""===this.opts.element.val()&&(this.updateSelection([]),this.close(),this.clearSearch());if(this.select||""!==this.opts.element.val()){var a=this;this.opts.initSelection.call(null,this.opts.element,function(b){if(b!==g&&b!==null){a.updateSelection(b);a.close();a.clearSearch()}})}},clearSearch:function(){var a=this.getPlaceholder();
a!==g&&0===this.getVal().length&&!1===this.search.hasClass("select2-focused")?(this.search.val(a).addClass("select2-default"),this.resizeSearch()):this.search.val(" ").width(10)},clearPlaceholder:function(){this.search.hasClass("select2-default")?this.search.val("").removeClass("select2-default"):" "===this.search.val()&&this.search.val("")},opening:function(){this.parent.opening.apply(this,arguments);this.clearPlaceholder();this.resizeSearch();this.focusSearch()},close:function(){this.opened()&&
this.parent.close.apply(this,arguments)},focus:function(){this.close();this.search.focus()},isFocused:function(){return this.search.hasClass("select2-focused")},updateSelection:function(a){var b=[],c=[],d=this;e(a).each(function(){0>i(d.id(this),b)&&(b.push(d.id(this)),c.push(this))});a=c;this.selection.find(".select2-search-choice").remove();e(a).each(function(){d.addSelectedChoice(this)});d.postprocessResults()},tokenize:function(){var a=this.search.val(),a=this.opts.tokenizer(a,this.data(),this.bind(this.onSelect),
this.opts);null!=a&&a!=g&&(this.search.val(a),0<a.length&&this.open())},onSelect:function(a){this.addSelectedChoice(a);this.select&&this.postprocessResults();this.opts.closeOnSelect?(this.close(),this.search.width(10)):0<this.countSelectableResults()?(this.search.width(10),this.resizeSearch(),this.positionDropdown()):this.close();this.triggerChange({added:a});this.focusSearch()},cancel:function(){this.close();this.focusSearch()},addSelectedChoice:function(a){var b=e("<li class='select2-search-choice'>    <div></div>    <a href='#' onclick='return false;' class='select2-search-choice-close' tabindex='-1'></a></li>"),
c=this.id(a),d=this.getVal(),f;f=this.opts.formatSelection(a,b);b.find("div").replaceWith("<div>"+this.opts.escapeMarkup(f)+"</div>");b.find(".select2-search-choice-close").bind("mousedown",l).bind("click dblclick",this.bind(function(a){this.enabled&&(e(a.target).closest(".select2-search-choice").fadeOut("fast",this.bind(function(){this.unselect(e(a.target));this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");this.close();this.focusSearch()})).dequeue(),
l(a))})).bind("focus",this.bind(function(){this.enabled&&(this.container.addClass("select2-container-active"),this.dropdown.addClass("select2-drop-active"))}));b.data("select2-data",a);b.insertBefore(this.searchContainer);d.push(c);this.setVal(d)},unselect:function(a){var b=this.getVal(),c,d,a=a.closest(".select2-search-choice");if(0===a.length)throw"Invalid argument: "+a+". Must be .select2-search-choice";c=a.data("select2-data");d=i(this.id(c),b);0<=d&&(b.splice(d,1),this.setVal(b),this.select&&
this.postprocessResults());a.remove();this.triggerChange({removed:c})},postprocessResults:function(){var a=this.getVal(),b=this.results.find(".select2-result-selectable"),c=this.results.find(".select2-result-with-children"),d=this;b.each2(function(b,c){var e=d.id(c.data("select2-data"));0<=i(e,a)?c.addClass("select2-disabled").removeClass("select2-result-selectable"):c.removeClass("select2-disabled").addClass("select2-result-selectable")});c.each2(function(a,b){0==b.find(".select2-result-selectable").length?
b.addClass("select2-disabled"):b.removeClass("select2-disabled")});b.each2(function(a,b){if(!b.hasClass("select2-disabled")&&b.hasClass("select2-result-selectable"))return d.highlight(0),!1})},resizeSearch:function(){var a,b,c,d,f=this.search.outerWidth()-this.search.width();a=this.search;q||(c=a[0].currentStyle||window.getComputedStyle(a[0],null),q=e("<div></div>").css({position:"absolute",left:"-10000px",top:"-10000px",display:"none",fontSize:c.fontSize,fontFamily:c.fontFamily,fontStyle:c.fontStyle,
fontWeight:c.fontWeight,letterSpacing:c.letterSpacing,textTransform:c.textTransform,whiteSpace:"nowrap"}),e("body").append(q));q.text(a.val());a=q.width()+10;b=this.search.offset().left;c=this.selection.width();d=this.selection.offset().left;b=c-(b-d)-f;b<a&&(b=c-f);40>b&&(b=c-f);this.search.width(b)},getVal:function(){var a;if(this.select)return a=this.select.val(),null===a?[]:a;a=this.opts.element.val();return s(a,this.opts.separator)},setVal:function(a){var b;this.select?this.select.val(a):(b=
[],e(a).each(function(){0>i(this,b)&&b.push(this)}),this.opts.element.val(0===b.length?"":b.join(this.opts.separator)))},val:function(){var a,b=[],c=this;if(0===arguments.length)return this.getVal();if(a=arguments[0])if(this.setVal(a),this.select)this.select.find(":selected").each(function(){b.push({id:e(this).attr("value"),text:e(this).text()})}),this.updateSelection(b);else{if(this.opts.initSelection===g)throw Error("val() cannot be called if initSelection() is not defined");this.opts.initSelection(this.opts.element,
function(a){var b=e(a).map(c.id);c.setVal(b);c.updateSelection(a);c.clearSearch()})}else this.opts.element.val(""),this.updateSelection([]);this.clearSearch()},onSortStart:function(){if(this.select)throw Error("Sorting of elements is not supported when attached to <select>. Attach to <input type='hidden'/> instead.");this.search.width(0);this.searchContainer.hide()},onSortEnd:function(){var a=[],b=this;this.searchContainer.show();this.searchContainer.appendTo(this.searchContainer.parent());this.resizeSearch();
this.selection.find(".select2-search-choice").each(function(){a.push(b.opts.id(e(this).data("select2-data")))});this.setVal(a);this.triggerChange()},data:function(a){var b=this,c;if(0===arguments.length)return this.selection.find(".select2-search-choice").map(function(){return e(this).data("select2-data")}).get();a||(a=[]);c=e.map(a,function(a){return b.opts.id(a)});this.setVal(c);this.updateSelection(a);this.clearSearch()}});e.fn.select2=function(){var a=Array.prototype.slice.call(arguments,0),b,
c,d,f,h="val destroy opened open close focus isFocused container onSortStart onSortEnd enable disable positionDropdown data".split(" ");this.each(function(){if(0===a.length||"object"===typeof a[0])b=0===a.length?{}:e.extend({},a[0]),b.element=e(this),"select"===b.element.get(0).tagName.toLowerCase()?f=b.element.attr("multiple"):(f=b.multiple||!1,"tags"in b&&(b.multiple=f=!0)),c=f?new z:new y,c.init(b);else if("string"===typeof a[0]){if(0>i(a[0],h))throw"Unknown method: "+a[0];d=g;c=e(this).data("select2");
if(c!==g&&(d="container"===a[0]?c.container:c[a[0]].apply(c,a.slice(1)),d!==g))return!1}else throw"Invalid arguments to select2 plugin: "+a;});return d===g?this:d};e.fn.select2.defaults={width:"copy",closeOnSelect:!0,openOnEnter:!0,containerCss:{},dropdownCss:{},containerCssClass:"",dropdownCssClass:"",formatResult:function(a,b,c){b=[];B(a.text,c.term,b);return b.join("")},formatSelection:function(a){return a?a.text:g},formatResultCssClass:function(){return g},formatNoMatches:function(){return"No matches found"},
formatInputTooShort:function(a,b){return"Please enter "+(b-a.length)+" more characters"},formatSelectionTooBig:function(a){return"You can only select "+a+" item"+(1==a?"":"s")},formatLoadMore:function(){return"Loading more results..."},formatSearching:function(){return"Searching..."},minimumResultsForSearch:0,minimumInputLength:0,maximumSelectionSize:0,id:function(a){return a.id},matcher:function(a,b){return 0<=b.toUpperCase().indexOf(a.toUpperCase())},separator:",",tokenSeparators:[],tokenizer:H,
escapeMarkup:function(a){return a&&"string"===typeof a?a.replace(/&/g,"&amp;"):a},blurOnChange:!1};window.Select2={query:{ajax:C,local:D,tags:E},util:{debounce:A,markMatch:B},"class":{"abstract":w,single:y,multi:z}}}})(jQuery);
