// save us one ajax call that we will always have to make
// this can also be grabbed by navigating to /epub_content/metadata.json
window.ReadiumLibraryData = [
	{
		"fixed_layout":false,
		"open_to_spread":false,
		"cover_href":"/images/library/missing-cover-image.png",
		"created_at":"2012-03-27T19:22:01.521Z",
		"updated_at":"2012-03-27T19:23:38.309Z",
		"key":"1",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/1/EPUB/package.opf",
		"id":"code.google.com.epub-samples.linear-algebra",
		"epub_version":"3.0",
		"title":"A First Course in Linear Algebra",
		"author":"Robert A. Beezer",
		"publisher":"",
		"description":"",
		"rights":"This work is shared with the public using the GNU Free Documentation License, Version 1.2.",
		"language":"en",
		"pubdate":"",
		"modified_date":"2012-03-05T12:47:00Z",
		"layout":"",
		"spread":"",
		"orientation":"",
		"ncx":""
	},
	{
		"fixed_layout":false,
		"open_to_spread":false,
		"cover_href":"/epub_content/2/EPUB/images/portrait.jpg",
		"created_at":"2012-03-27T19:24:45.543Z",
		"updated_at":"2012-03-27T19:25:00.094Z",
		"key":"2",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/2/EPUB/cole.opf",
		"id":"code.google.com.epub-samples.cole-voyage-of-life",
		"epub_version":"3.0",
		"title":"Thomas Cole - The Voyage of Life",
		"author":"Jesse Dylan",
		"publisher":"",
		"description":"",
		"rights":"This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.",
		"language":"en-US",
		"pubdate":"",
		"modified_date":"2012-03-20T11:37:00Z",
		"layout":"",
		"spread":"",
		"orientation":"",
		"ncx":""
	},{
		"fixed_layout":false,
		"open_to_spread":false,
		"cover_href":"/epub_content/3/EPUB/wasteland-cover.jpg",
		"created_at":"2012-03-27T19:25:40.235Z",
		"updated_at":"2012-03-27T19:26:06.326Z",
		"key":"3",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/3/EPUB/wasteland.opf",
		"id":"code.google.com.epub-samples.wasteland-basic","epub_version":"3.0",
		"title":"The Waste Land","author":"T.S. Eliot",
		"publisher":"",
		"description":"",
		"rights":"This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"language":"en-US",
		"pubdate":"2011-09-01",
		"modified_date":"2012-01-18T12:47:00Z",
		"layout":"",
		"spread":"",
		"orientation":"",
		"ncx":"ncx"
	},{
		"fixed_layout":true,
		"open_to_spread":false,
		"cover_href":"/epub_content/4/EPUB/Image/cover.jpg",
		"created_at":"2012-03-28T18:24:18.450Z",
		"updated_at":"2012-03-28T18:25:32.553Z",
		"key":"4",
		"src_url":"http://code.google.com/p/epub-samples/downloads/list",
		"package_doc_path":"/epub_content/4/EPUB/package.opf",
		"id":"urn:uuid:d5803940-647f-11e1-ad77-0002a5d5c51b",
		"epub_version":"3.0",
		"title":"Page Blanche","author":"Boulet",
		"publisher":"éditions Delcourt",
		"description":"",
		"rights":"This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"language":"fr",
		"pubdate":"2012-01-18",
		"modified_date":"2012-03-06T12:00:00Z",
		"layout":"pre-paginated",
		"spread":"auto",
		"orientation":"auto",
		"ncx":""
	}, {
		"author": "Mary Webb",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-04-10T21:47:53.353Z",
		"description": "",
		"epub_version": "2.0",
		"fixed_layout": false,
		"id": "urn:uuid:ADDB2B4D-BA43-4DE9-8BAB-CF8759C8F843",
		"key": "3921047c34132ab12338059f09bbf5c8",
		"language": "en-gb",
		"layout": "",
		"modified_date": "",
		"ncx": "ncx",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/5/OPS/content.opf",
		"pubdate": "2002",
		"publisher": "epubBooks (www.epubbooks.com)",
		"rights": "↵            Provided for free by epubBooks.com. Not for commercial use.↵            This EPUB eBook is released under a Creative Commons (BY-NC-ND/3.0) Licence.↵            Source text and images are in the Public Domain.↵      ",
		"spread": "",
		"src_url": "webb-precious-bane.epub",
		"title": "Precious Bane",
		"updated_at": "2012-04-10T21:48:57.267Z"
	}, {
		"apple_fixed": false,
		"author": "EPUB 3 Working Group",
		"cover_href": "/epub_content/epub30_spec/EPUB/img/epub_logo_color.jpg",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.epub30-spec",
		"key": "epub30_spec",
		"language": "en",
		"layout": "",
		"modified_date": "2012-02-27T16:38:35Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/epub30_spec/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "EPUB 3.0 Specification",
		"updated_at": "2012-06-15T00:06:37.334Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "http://www.aozora.gr.jp/cards/000148/card776.html",
		"key": "kusamakura",
		"language": "ja-jp",
		"layout": "",
		"modified_date": "2012-04-24T00:00:00Z",
		"ncx": "ncxtoc",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/kusamakura/OPS/package.opf",
		"page_prog_dir": "rtl",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "草枕",
		"updated_at": "2012-06-15T00:06:55.212Z"
	}, {
		"apple_fixed": false,
		"author": "Herman Melville",
		"cover_href": "/epub_content/moby_dick/OPS/images/9780316000000.jpg",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.moby-dick-basic",
		"key": "moby_dick",
		"language": "en-US",
		"layout": "",
		"modified_date": "2012-01-18T12:47:00Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/moby_dick/OPS/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "Harper & Brothers, Publishers",
		"rights": "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Moby-Dick",
		"updated_at": "2012-06-15T00:07:21.516Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/epub_content/trees/EPUB/cover.jpg",
		"created_at": "2012-06-15T00:05:56.371Z",
		"description": "Test of canvas element and CSS3 multi-column layout",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.trees",
		"key": "trees",
		"language": "en",
		"layout": "",
		"modified_date": "2012-04-05T12:47:00Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/trees/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Trees",
		"updated_at": "2012-06-15T00:07:49.803Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-06-15T00:08:27.336Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": true,
		"id": "urn:uuid:A649F639-6C1F-1014-8CC3-F813564D7508",
		"key": "haruko",
		"language": "ja-jp",
		"layout": "pre-paginated",
		"modified_date": "2012-05-24T00:00:00Z",
		"ncx": "ncxtoc",
		"open_to_spread": false,
		"orientation": "portrait",
		"package_doc_path": "/epub_content/haruko/OPS/package.opf",
		"page_prog_dir": "rtl",
		"paginate_backwards": false,
		"pubdate": "",
		"publisher": "",
		"rights": "",
		"spread": "landscape",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "ハルコさんの彼氏",
		"updated_at": "2012-06-15T00:08:36.776Z"
	}, {
		"apple_fixed": false,
		"author": "",
		"cover_href": "/images/library/missing-cover-image.png",
		"created_at": "2012-06-15T00:08:27.336Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.hefty.water",
		"key": "hefty_water",
		"language": "en",
		"layout": "",
		"modified_date": "2012-03-29T12:00:00Z",
		"ncx": "",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/hefty_water/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "2012-03-29",
		"publisher": "",
		"rights": "",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Hefty Water",
		"updated_at": "2012-06-15T00:09:37.681Z"
	}, {
		"apple_fixed": false,
		"author": "Matt Garrish",
		"cover_href": "/epub_content/accessible_epub_3/EPUB/covers/9781449328030_lrg.jpg",
		"created_at": "2012-06-15T00:10:25.327Z",
		"current_margin": 1,
		"current_theme": "default-theme",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"font_size": 10,
		"id": "urn:isbn:9781449328030",
		"key": "accessible_epub_3",
		"language": "en",
		"layout": "",
		"modified_date": "2012-02-20T22:17:24Z",
		"ncx": "ncx",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/accessible_epub_3/EPUB/package.opf",
		"page_prog_dir": "",
		"paginate_backwards": false,
		"pubdate": "2012",
		"publisher": "O’Reilly Media, Inc.",
		"rights": "Copyright © 2012 O’Reilly Media, Inc",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Accessible EPUB 3",
		"two_up": true,
		"updated_at": "2012-06-15T00:13:26.319Z"
	}, {
		"apple_fixed": false,
		"author": "Pr David Khayat",
		"cover_href": "/epub_content/regime_anticancer_arabic/EPUB/Image/cover.jpg",
		"created_at": "2012-06-15T00:11:17.450Z",
		"description": "",
		"epub_version": "3.0",
		"fixed_layout": false,
		"id": "code.google.com.epub-samples.regime-anticancer-arabic",
		"key": "regime_anticancer_arabic",
		"language": "ar",
		"layout": "",
		"modified_date": "2012-03-26T12:00:00Z",
		"ncx": "ncx",
		"open_to_spread": false,
		"orientation": "",
		"package_doc_path": "/epub_content/regime_anticancer_arabic/EPUB/package.opf",
		"page_prog_dir": "rtl",
		"paginate_backwards": false,
		"pubdate": "2012",
		"publisher": "Hachette Antoine",
		"rights": "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		"spread": "",
		"src_url": "http://code.google.com/p/epub-samples/downloads/list",
		"title": "Le Vrai Régime anti-cancer",
		"updated_at": "2012-06-15T00:11:57.065Z"
	}
]
// This is the namespace and initialization code that is used by
// by the epub viewer of the chrome extension

window.Readium = {
	Models: {},
	Collections: {},
	Views: {},
	Routers: {},
	Utils: {},
	Init: function() {
		_router = new Readium.Routers.ViewerRouter();
		Backbone.history.start({pushState: true});
	}
};

$(function() {
	// call the initialization code when the dom is loaded
	window.Readium.Init();
});
Readium.HttpFileApi = function(initCallback) {
    var api = {
        readTextFile: function(path, readCallback, errorCallback) {
            $.ajax({
                //'cache' : false,
                'url' : path,
                'dataType' : 'text',
                'success' : function(data, textStatus, jqXHR) {
                    readCallback(data, jqXHR)
                },
                'error' : function(data, textStatus, jqXHR) {
                    errorCallback(data, textStatus, jqXHR)
                }
            })
        },

        getFsUri: function(path, successCallback, errorCallback) {
            successCallback(document.location.protocol + '//' + document.location.host + path)
        }
    }

    return function ( callback ) {
        callback(api);
        return api;
    }
}();

// patch in:
// TODO: Find a way to easily patch in
Readium.FileSystemApi = Readium.HttpFileApi
Readium.Utils.setCookie = function(c_name,value,exdays) {
	var exdate=new Date();
	exdate.setDate(exdate.getDate() + exdays);
	var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
	document.cookie=c_name + "=" + c_value;
}


Readium.Utils.getCookie = function(c_name) {
	var i, x, y, ARRcookies=document.cookie.split(";");
	for (i = 0; i < ARRcookies.length; i++) {
		x = ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
		y = ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
		x = x.replace(/^\s+|\s+$/g,"");
		if ( x == c_name ) {
			return unescape(y);
		}
	}
}

Readium.Utils.trimString = function(str) {
	return str.replace(/^\s+|\s+$/g, '');
}
/*
 * A sync for backbone based on html5 fs api
 */

BBFileSystemSync = function(method, model, options) {

	if(!model.file_path) {
		throw "Cannot sync the model to the fs without a path";
	}

	// this is a read only sync, no saving for now
	switch (method) {
        case "read":
            Readium.FileSystemApi(function(api) {
            	api.readTextFile(model.file_path, function(a,b) {
            		options.success(a);
            	}, function(e) {
            		options.error(e);
            	});
            });
            break;
        case "create":
            throw "Not yet implemented";
            break;
        case "update":
            throw "Not yet implemented";
            break;
        case "delete":
            throw "Not yet implemented";
            break;
    }

    return null;
	
}
// Description: This model is responsible for implementing the Alternate Style Tags specification
// found at http://idpf.org/epub/altss-tags/. The model selects a "preferred" style sheet or style set 
// with which to render an ePUB document. 
// 
// Notes: The convention in this model is to prepend the names of "private" methods with an underscore ('_')
//
// TODO: More validation for style sets with mixed rel="alternate ..." and rel="stylesheet"?
// TODO: Ensure that the "default" style set (the default in the ePub) is activated if no tags are supplied
 

Readium.Models.AlternateStyleTagSelector = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {},

	/* Description: Activate a style set based on a single, or set, of ePub alternate style tags
	 * Arguments (
	 *   altStyleTags: An array of ePUB alternate style tags
	 *   bookDom: An epub document object
	 * )
	 */
	activateAlternateStyleSet: function(altStyleTags, bookDom) {

		var $bookStyleSheets;
		var styleSetTitles = [];
		var that = this;
		var styleSetToActivate;

		// If there are no alternate tags supplied, do not change the style sets
		if (altStyleTags.length === 0) {

			return bookDom;
		}

		// Get all style sheets in the book dom
		$bookStyleSheets = $("link[rel*='stylesheet']", bookDom);

		// If the book does not have any stylesheets, do not change style sets
		if ($bookStyleSheets.length === 0) {

			return bookDom;
		}

		// Maintain original information about stylesheets
		$bookStyleSheets = this._storeOriginalAttributes($bookStyleSheets);

		// Get a list of the unique style set titles 
		styleSetTitles = this._getStyleSetTitles($bookStyleSheets);

		// Determine which style set should be activated
		styleSetToActivate = this._getStyleSetTitleToActivate($bookStyleSheets, styleSetTitles, altStyleTags);

		// If no style was found to activate, based on the supplied tags, do not change the style sets
		if (styleSetToActivate === null) {

			return bookDom;
		}

		// Activate the specified style set, de-activing all others
		this._activateStyleSet($bookStyleSheets, styleSetToActivate);

		return bookDom;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	/* Description: Activate the specified style set and de-activate all others
	 * Design rationale: The disabled property is used to activate/de-activate the style sheets, as opposed to changing 
	 * attribute values, as this ensures that the document is re-rendered
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 *   styleSetToActivate: The attribute value for the "title" property of the style set to activate
	 * )
	 */
	_activateStyleSet: function (bookStyleSheets, styleSetToActivate) {

		bookStyleSheets.each(function () {

			$styleSheet = $(this);

			// The stylesheets must all be set as preferred so that when enabled, they will be activated
			$styleSheet.attr("rel", "stylesheet");
			// Always leave persistent style sets activated
			if ($styleSheet.attr('title') === undefined) {

				$styleSheet[0].disabled = false;
			}
			// Activate this style set
			else if ($.trim($styleSheet.attr('title')) === styleSetToActivate) {

				// Chrome is buggy and change to disabled = false is only
				// picked up if you first set it to true
				$styleSheet[0].disabled = true;
				$styleSheet[0].disabled = false;
			}
			// De-activate other style sets
			else {

				$styleSheet[0].disabled = true;
			}
		});

		return bookStyleSheets;
	},

	/* Description: Creates data attributes to store the original stylesheet attribute values
	 * Design rationale: The "rel" attribute must be modified in other methods but we need to "remember" 
	 * the author's original style sheet specification
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 * )
	 */
	_storeOriginalAttributes: function(bookStyleSheets) {

		var $styleSheet;

		// For each style sheet, if the original value attributes are empty, set them
		bookStyleSheets.each(function() {

			$styleSheet = $(this);

			if ($styleSheet.data('orig-rel') === undefined) {

				$styleSheet.attr('data-orig-rel', $styleSheet.attr("rel"));
			}
		});

		return bookStyleSheets;
	},

	/* Description: Finds the title of the style set to activate using HTML preference rules for style sheets, as well as ePub 
	 * alternate style tags.
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets 
	 *   styleSetTitles: An array of the unique style set titles for the ePub
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 * Error handling: Returns null if not title is found
	 */
	_getStyleSetTitleToActivate: function (bookStyleSheets, styleSetTitles, altStyleTags) {

		var styleSetTagMatches = [];
		var styleSetNum;
		var $styleSet;
		var maxNumTagMatches;
		var styleSetCandidates = [];

		// Find the style set with the most matching alternate tags, removing mututally exclusive tags
		for (styleSetNum = 0; styleSetNum < styleSetTitles.length; styleSetNum += 1) {

			$styleSet = bookStyleSheets.filter("link[title='" + styleSetTitles[styleSetNum] + "']");
			$styleSet = this._removeMutuallyExclusiveAltTags($styleSet);
			styleSetTagMatches.push(
				{ "numAltTagMatches" : this._getNumAltStyleTagMatches($styleSet, altStyleTags),
				  "styleSetTitle" : styleSetTitles[styleSetNum] }
			);
		}

		// Get a list of the style sets with the maximum number of tag matches
		// _.max returns one of the info elements with a maximum value, which is why the numAltTagMatches property is used to retrieve the actual max value
		maxNumTagMatches = (_.max(styleSetTagMatches, function (styleSetTagMatchInfo) { return styleSetTagMatchInfo.numAltTagMatches } )).numAltTagMatches;

		// Do nothing if there are no matching tags
		if (maxNumTagMatches === 0) {

			return null;
		}

		// Get a list of the style sets that had the maximum number of alternate tag matches
		_.each(styleSetTagMatches, function(styleSetTagMatchInfo) {

			if (styleSetTagMatchInfo['numAltTagMatches'] === maxNumTagMatches) {

				styleSetCandidates.push(styleSetTagMatchInfo["styleSetTitle"]);
			}
		});

		// If there is only one style set in the candidate list
		if (styleSetCandidates === 1) {

			return styleSetCandidates[0];
		}
		// Since there are multiple candidates, return the style set that is preferred (the first style set with rel="stylesheet")
		else {

			var candidateNum;
			for (candidateNum = 0; candidateNum < styleSetCandidates.length; candidateNum++) {

				// TODO: This assumes that all the style sheets in the style set are marked as either preferred or alternate. It simply checks the first 
				// style sheet of every style set.
				$styleSet = bookStyleSheets.filter("link[title='" + styleSetCandidates[candidateNum] + "']");
				if ($.trim($($styleSet[0]).attr("data-orig-rel")) === "stylesheet") {

					return styleSetCandidates[candidateNum];
				}
			}

			// If none of the stylesheets were preferred (only rel="alternate stylesheet"), return the first style set title
			return styleSetCandidates[0];
		}
	},

	/* Description: Finds the unique list of style set titles from the set of style sheets for the ePub
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePub's style sheets 
	 * )
	 */
	_getStyleSetTitles: function (bookStyleSheets) {

		var styleSetTitles = [];

		// Find the unique style sets from the 'title' property
		bookStyleSheets.each(function() {

			var styleSheetTitle = $(this).attr("title");
			if (!_.include(styleSetTitles, styleSheetTitle)) {

				styleSetTitles.push(styleSheetTitle);
			}
		});

		return styleSetTitles;
	},

	/* Description: Finds the number of alternate style tags in a style set's class attribute
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 */
	_getNumAltStyleTagMatches: function (styleSet, altStyleTags) {

		var numMatches = 0;

		// If the alt style tag is found in the style set, increment num matches
		var altTagNum;
		for (altTagNum = 0; altTagNum < altStyleTags.length; altTagNum += 1) {

			// filter used so top-level elements are selected
			if (styleSet.filter("link[class*='" + altStyleTags[altTagNum] + "']").length > 0) {

				numMatches++;	
			}
		}

		return numMatches;
	},

	// 
	/* Description: This method removes, thus ignoring, mututally exclusive alternate tags within a style set
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 * )
	 */
	//TODO: Maybe change this to act on data- attributes, rather than the actual class attribute
	_removeMutuallyExclusiveAltTags: function (styleSet) {

		var $styleSheet;

		if (styleSet.filter("link[class*='night']").length > 0 &&
		    styleSet.filter("link[class*='day']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.night').length > 0) {

					$styleSheet.toggleClass('night');
				}

				if ($styleSheet.filter('.day').length > 0) {

					$styleSheet.toggleClass('day');
				}
			});
		}

		if (styleSet.filter("link[class*='vertical']").length > 0 &&
			styleSet.filter("link[class*='horizontal']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.vertical').length > 0) {
					
					$styleSheet.toggleClass('vertical');
				}

				if ($styleSheet.filter('.horizontal').length > 0) {

					$styleSheet.toggleClass('horizontal');
				}
			});
		}

		return styleSet;
	}
});

// based on http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
Readium.Utils.Guid = function() {
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    	var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
    	return v.toString(16);
	});
};

// roughly based on http://documentcloud.github.com/backbone/docs/backbone-localstorage.html
Readium.Utils.LocalStorageAdaptor = function(storeName) {

	var _data;

	var save = function() {
		localStorage.setItem(storeName, JSON.stringify(_data));
	};

	var create = function(model) {
		if (!model.id) model.id = model.attributes.id = guid();
		_data[model.id] = model;
		save();
		return model;
	};

	var update = function(model) {
		_data[model.id] = model;
		save();
		return model;
	};

	var find = function(model) {
		return _data[model.id];
	};

	var findAll = function() {
		return _.values(_data);
	};


	var destroy = function(model) {
		delete _data[model.id];
		save();
		return model;
	};

	return function(method, model, options) {

		var resp;
		var strData = localStorage.getItem(storeName);
		_data = ( strData && JSON.parse(strData)) || {};

		switch (method) {
			case "read":    resp = model.id ? find(model) : findAll(); break;
			case "create":  resp = create(model);                            break;
			case "update":  resp = update(model);                            break;
			case "delete":  resp = destroy(model);                           break;
		}

		if (resp) {
			if(options.success) {
				options.success(resp);
			}
		} else {
			if(options.error) {
				options.error("Record not found");	
			}
		}
	};

};
// Description: This model is responsible for implementing the Alternate Style Tags specification
// found at http://idpf.org/epub/altss-tags/. The model selects a "preferred" style sheet or style set 
// with which to render an ePUB document. 
// 
// Notes: The convention in this model is to prepend the names of "private" methods with an underscore ('_')
//
// TODO: More validation for style sets with mixed rel="alternate ..." and rel="stylesheet"?
// TODO: Ensure that the "default" style set (the default in the ePub) is activated if no tags are supplied
 

Readium.Models.AlternateStyleTagSelector = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {},

	/* Description: Activate a style set based on a single, or set, of ePub alternate style tags
	 * Arguments (
	 *   altStyleTags: An array of ePUB alternate style tags
	 *   bookDom: An epub document object
	 * )
	 */
	activateAlternateStyleSet: function(altStyleTags, bookDom) {

		var $bookStyleSheets;
		var styleSetTitles = [];
		var that = this;
		var styleSetToActivate;

		// If there are no alternate tags supplied, do not change the style sets
		if (altStyleTags.length === 0) {

			return bookDom;
		}

		// Get all style sheets in the book dom
		$bookStyleSheets = $("link[rel*='stylesheet']", bookDom);

		// If the book does not have any stylesheets, do not change style sets
		if ($bookStyleSheets.length === 0) {

			return bookDom;
		}

		// Maintain original information about stylesheets
		$bookStyleSheets = this._storeOriginalAttributes($bookStyleSheets);

		// Get a list of the unique style set titles 
		styleSetTitles = this._getStyleSetTitles($bookStyleSheets);

		// Determine which style set should be activated
		styleSetToActivate = this._getStyleSetTitleToActivate($bookStyleSheets, styleSetTitles, altStyleTags);

		// If no style was found to activate, based on the supplied tags, do not change the style sets
		if (styleSetToActivate === null) {

			return bookDom;
		}

		// Activate the specified style set, de-activing all others
		this._activateStyleSet($bookStyleSheets, styleSetToActivate);

		return bookDom;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	/* Description: Activate the specified style set and de-activate all others
	 * Design rationale: The disabled property is used to activate/de-activate the style sheets, as opposed to changing 
	 * attribute values, as this ensures that the document is re-rendered
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 *   styleSetToActivate: The attribute value for the "title" property of the style set to activate
	 * )
	 */
	_activateStyleSet: function (bookStyleSheets, styleSetToActivate) {

		bookStyleSheets.each(function () {

			$styleSheet = $(this);

			// The stylesheets must all be set as preferred so that when enabled, they will be activated
			$styleSheet.attr("rel", "stylesheet");
			// Always leave persistent style sets activated
			if ($styleSheet.attr('title') === undefined) {

				$styleSheet[0].disabled = false;
			}
			// Activate this style set
			else if ($.trim($styleSheet.attr('title')) === styleSetToActivate) {

				// Chrome is buggy and change to disabled = false is only
				// picked up if you first set it to true
				$styleSheet[0].disabled = true;
				$styleSheet[0].disabled = false;
			}
			// De-activate other style sets
			else {

				$styleSheet[0].disabled = true;
			}
		});

		return bookStyleSheets;
	},

	/* Description: Creates data attributes to store the original stylesheet attribute values
	 * Design rationale: The "rel" attribute must be modified in other methods but we need to "remember" 
	 * the author's original style sheet specification
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets
	 * )
	 */
	_storeOriginalAttributes: function(bookStyleSheets) {

		var $styleSheet;

		// For each style sheet, if the original value attributes are empty, set them
		bookStyleSheets.each(function() {

			$styleSheet = $(this);

			if ($styleSheet.data('orig-rel') === undefined) {

				$styleSheet.attr('data-orig-rel', $styleSheet.attr("rel"));
			}
		});

		return bookStyleSheets;
	},

	/* Description: Finds the title of the style set to activate using HTML preference rules for style sheets, as well as ePub 
	 * alternate style tags.
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePubs style sheets 
	 *   styleSetTitles: An array of the unique style set titles for the ePub
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 * Error handling: Returns null if not title is found
	 */
	_getStyleSetTitleToActivate: function (bookStyleSheets, styleSetTitles, altStyleTags) {

		var styleSetTagMatches = [];
		var styleSetNum;
		var $styleSet;
		var maxNumTagMatches;
		var styleSetCandidates = [];

		// Find the style set with the most matching alternate tags, removing mututally exclusive tags
		for (styleSetNum = 0; styleSetNum < styleSetTitles.length; styleSetNum += 1) {

			$styleSet = bookStyleSheets.filter("link[title='" + styleSetTitles[styleSetNum] + "']");
			$styleSet = this._removeMutuallyExclusiveAltTags($styleSet);
			styleSetTagMatches.push(
				{ "numAltTagMatches" : this._getNumAltStyleTagMatches($styleSet, altStyleTags),
				  "styleSetTitle" : styleSetTitles[styleSetNum] }
			);
		}

		// Get a list of the style sets with the maximum number of tag matches
		// _.max returns one of the info elements with a maximum value, which is why the numAltTagMatches property is used to retrieve the actual max value
		maxNumTagMatches = (_.max(styleSetTagMatches, function (styleSetTagMatchInfo) { return styleSetTagMatchInfo.numAltTagMatches } )).numAltTagMatches;

		// Do nothing if there are no matching tags
		if (maxNumTagMatches === 0) {

			return null;
		}

		// Get a list of the style sets that had the maximum number of alternate tag matches
		_.each(styleSetTagMatches, function(styleSetTagMatchInfo) {

			if (styleSetTagMatchInfo['numAltTagMatches'] === maxNumTagMatches) {

				styleSetCandidates.push(styleSetTagMatchInfo["styleSetTitle"]);
			}
		});

		// If there is only one style set in the candidate list
		if (styleSetCandidates === 1) {

			return styleSetCandidates[0];
		}
		// Since there are multiple candidates, return the style set that is preferred (the first style set with rel="stylesheet")
		else {

			var candidateNum;
			for (candidateNum = 0; candidateNum < styleSetCandidates.length; candidateNum++) {

				// TODO: This assumes that all the style sheets in the style set are marked as either preferred or alternate. It simply checks the first 
				// style sheet of every style set.
				$styleSet = bookStyleSheets.filter("link[title='" + styleSetCandidates[candidateNum] + "']");
				if ($.trim($($styleSet[0]).attr("data-orig-rel")) === "stylesheet") {

					return styleSetCandidates[candidateNum];
				}
			}

			// If none of the stylesheets were preferred (only rel="alternate stylesheet"), return the first style set title
			return styleSetCandidates[0];
		}
	},

	/* Description: Finds the unique list of style set titles from the set of style sheets for the ePub
	 * Arguments (
	 *   bookStyleSheets: A JQuery object of the ePub's style sheets 
	 * )
	 */
	_getStyleSetTitles: function (bookStyleSheets) {

		var styleSetTitles = [];

		// Find the unique style sets from the 'title' property
		bookStyleSheets.each(function() {

			var styleSheetTitle = $(this).attr("title");
			if (!_.include(styleSetTitles, styleSheetTitle)) {

				styleSetTitles.push(styleSheetTitle);
			}
		});

		return styleSetTitles;
	},

	/* Description: Finds the number of alternate style tags in a style set's class attribute
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 *   altStyleTags: An array of ePUB alternate style tags
	 * )
	 */
	_getNumAltStyleTagMatches: function (styleSet, altStyleTags) {

		var numMatches = 0;

		// If the alt style tag is found in the style set, increment num matches
		var altTagNum;
		for (altTagNum = 0; altTagNum < altStyleTags.length; altTagNum += 1) {

			// filter used so top-level elements are selected
			if (styleSet.filter("link[class*='" + altStyleTags[altTagNum] + "']").length > 0) {

				numMatches++;	
			}
		}

		return numMatches;
	},

	// 
	/* Description: This method removes, thus ignoring, mututally exclusive alternate tags within a style set
	 * Arguments (
	 *   styleSet: A JQuery object that represents a single style set
	 * )
	 */
	//TODO: Maybe change this to act on data- attributes, rather than the actual class attribute
	_removeMutuallyExclusiveAltTags: function (styleSet) {

		var $styleSheet;

		if (styleSet.filter("link[class*='night']").length > 0 &&
		    styleSet.filter("link[class*='day']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.night').length > 0) {

					$styleSheet.toggleClass('night');
				}

				if ($styleSheet.filter('.day').length > 0) {

					$styleSheet.toggleClass('day');
				}
			});
		}

		if (styleSet.filter("link[class*='vertical']").length > 0 &&
			styleSet.filter("link[class*='horizontal']").length > 0) {

			styleSet.each(function () { 

				$styleSheet = $(this);

				if ($styleSheet.filter('.vertical').length > 0) {
					
					$styleSheet.toggleClass('vertical');
				}

				if ($styleSheet.filter('.horizontal').length > 0) {

					$styleSheet.toggleClass('horizontal');
				}
			});
		}

		return styleSet;
	}
});

Readium.Models.ManifestItem = Backbone.Model.extend({
	
	parseMetaTags: function() {
		 var pageSize;
		// only need to go through this one time, so only parse it
		// if it is not already known
		if(typeof this.get("meta_width") !== "undefined") {
			return;
		}

		if(this.isSvg()) {
			pageSize = this.parseViewboxTag();
		}
		else if(!this.isImage()) {
			pageSize = this.parseViewportTag();
		}

		if(pageSize) {
			this.set({"meta_width": pageSize.width, "meta_height": pageSize.height});
		}
	},

	getContentDom: function() {
		var content = this.get('content');
		if(content) {
			var parser = new window.DOMParser();
			return parser.parseFromString(content, 'text/xml');
		}
	},

	// for fixed layout xhtml we need to parse the meta viewport
	// tag to determine the size of the pages. more info in the 
	// [fixed layout spec](http://idpf.org/epub/fxl/#dimensions-xhtml-svg)
	parseViewportTag: function() {
		var dom = this.getContentDom();
		if(!dom) {
			return;
		}
		var viewportTag = dom.getElementsByName("viewport")[0];
		if(!viewportTag) {
			return null;
		}
		// this is going to be ugly
		var str = viewportTag.getAttribute('content');
		str = str.replace(/\s/g, '');
		var valuePairs = str.split(',');
		var values = {};
		var pair;
		for(var i = 0; i < valuePairs.length; i++) {
			pair = valuePairs[i].split('=');
			if(pair.length === 2) {
				values[ pair[0] ] = pair[1];
			}
		}
		values['width'] = parseFloat(values['width'], 10);
		values['height'] = parseFloat(values['height'], 10);
		return values;
	},

	// for fixed layout svg we need to parse the viewbox on the svg
	// root tag to determine the size of the pages. more info in the 
	// [fixed layout spec](http://idpf.org/epub/fxl/#dimensions-xhtml-svg)
	parseViewboxTag: function() {

		// The value of the ‘viewBox’ attribute is a list of four numbers 
		// `<min-x>`, `<min-y>`, `<width>` and `<height>`, separated by 
		// whitespace and/or a comma
		var dom = this.getContentDom();
		if(!dom) {
			return;
		}
		var viewboxString = dom.documentElement.getAttribute("viewBox");
		// split on whitespace and/or comma
		var valuesArray = viewboxString.split(/,?\s+|,/);
		var values = {};
		values['width'] = parseFloat(valuesArray[2], 10);
		values['height'] = parseFloat(valuesArray[3], 10);
		return values;

	},

	resolvePath: function(path) {
		return this.collection.packageDocument.resolvePath(path)
	},

	resolveUri: function(path) {
		return this.collection.packageDocument.resolveUri(path)	
	},

	isSvg: function() {
		return this.get("media_type") === "image/svg+xml";
	},

	isImage: function() {
		var media_type = this.get("media_type");

		if(media_type && media_type.indexOf("image/") > -1) {
			// we want to treat svg as a special case, so they
			// are not images
			return media_type !== "image/svg+xml";
		}
		return false;
	},

	// Load this content from the filesystem
	loadContent: function() {
		var that = this;
		var path = this.resolvePath(this.get("href"));
		
		Readium.FileSystemApi(function(api) {
			api.readTextFile(path, function(result) {
				that.set( {content: result} );
			}, function() {
				console.log("Failed to load file: " + path);
			})
		});
	}
	
});

Readium.Models.SpineItem = Readium.Models.ManifestItem.extend({

	initialize: function() {
		if(this.isFixedLayout()) {
			this.on("change:content", this.parseMetaTags, this);
			this.loadContent();
		}
		
	},

	// this method creates the JSON representation of a manifest item
	// that is used to render out a page view.
	buildSectionJSON: function(manifest_item, spine_index) {
		if(!manifest_item) {
			return null;
		}
		var section = Object.create(null);
		section.width = this.get("meta_width") || 0;
		section.height = this.get("meta_height") || 0;
		section.uri = this.packageDocument.resolveUri(manifest_item.get('href'));
		section.page_class = this.getPageSpreadClass(manifest_item, spine_index);
		return section;
	},

	toJSON: function() {
		if(this.isFixedLayout()) {
			this.parseMetaTags();
		}
		var json = {};
		json.width = this.get("meta_width") || 0;
		json.height = this.get("meta_height") || 0;
		json.uri = this.resolveUri(this.get('href'));
		json.page_class = this.getPageSpreadClass();
		return json;
	},

	// when rendering fixed layout pages we need to determine whether the page
	// should be on the left or the right in two up mode, options are:
	// 	left_page: 		render on the left side
	//	right_page: 	render on the right side
	//	center_page: 	always center the page horizontally
	getPageSpreadClass: function() {
		var book = this.collection.packageDocument.get("book");
		var spine_index = this.get("spine_index");
		var pageSpreadProperty;

		if(book.get("apple_fixed")) {
			// the logic for apple fixed layout is a little different:
			/*
			if(!book.get("open_to_spread")) {
				// page spread is disabled for this book
				return	"center_page"
			}
			else if(spine_index === 0) {
				*/
			if(spine_index === 0) {
				// for ibooks, odd pages go on the right. This means
				// the first page (0th index) will always be on the right
				// without a left counterpart, so center it
				return "center_page";
			}
			else if (spine_index % 2 === 1 && 
				spine_index === this.collection.length) {

				// if the last spine item in the book would be on the left, then
				// it would have no left counterpart, so center it
				return "center_page";
			}
			else {
				// otherwise first page goes on the right, and then alternate
				// left - right - left - right etc
				return (spine_index % 2 === 0 ? "right_page" : "left_page");
			}
		}
		else {

			// If the page spread property has been set for this spine item, return 
			// the name of the appropriate spread class. 
			// Note: As there are only three valid values (left, right, center) for the page
			// spread property in ePub 3.0, if the property is set and 
			// it is not "left" or "right, "center" will always be assumed. 
			if (this.get("page_spread")) {

				pageSpreadProperty = this.get("page_spread");
				if (pageSpreadProperty === "left") {

					return "left_page";
				}
				else if (pageSpreadProperty === "right") {

					return "right_page";
				}
				else {

					return "center_page";
				}
			}
			// If the page spread property is not set, use a even/odd page index heuristic that depends on the 
			// page progression order:
			//   - Even-numbered pages on the right for rtl text
			//   - Odd-numbered pages on the left for ltr text
			else {

				// Check for right-to-left page progression direction
				if (this.get("page_prog_dir") === "rtl") {

					return (spine_index % 2 === 0 ? "right_page" : "left_page");
				}
				// Text is left-to-right
				else {

					return (spine_index % 2 === 0 ? "left_page" : "right_page");
				}
			}
		}
	},

	isFixedLayout: function() {

		// if it an svg or image then it is fixed layout
		if(this.isSvg() || this.isImage()) {
			return true;
		}

		// if there is a fixed_flow property, then it takes precedence
		if(typeof this.get("fixed_flow") !== 'undefined') {
			return this.get('fixed_flow');
		}

		// nothing special about this spine item, fall back to the books settings
		return this.collection.isBookFixedLayout();
	},

	// REFACTORING CANDIDATE: caching the the fixed layout views. I do not remember the reason that
	// we are doing this. Possible that it is not necessary...
	getPageView: function() {
		if(!this.view) {
			if(this.isImage()) {
				this.view = new Readium.Views.ImagePageView({model: this});
			}
			else {
				this.view = new Readium.Views.FixedPageView({model: this});	
			}
			
		}
		return this.view;
	},
    
    hasMediaOverlay: function() {
        return !!this.get("media_overlay") && !!this.getMediaOverlay();
    },
    
    getMediaOverlay: function() {
		return this.collection.getMediaOverlay(this.get("media_overlay"));
    }
});



Readium.Collections.ManifestItems = Backbone.Collection.extend({
	model: Readium.Models.ManifestItem,

	initialize: function(models, options) {
		this.packageDocument = options.packageDocument;   
    }
});

Readium.Collections.Spine = Backbone.Collection.extend({
	model: Readium.Models.SpineItem,

	initialize: function(models, options) {
		this.packageDocument = options.packageDocument;
	},

	isBookFixedLayout: function() {
		return this.packageDocument.get("book").isFixedLayout();
	},

	getMediaOverlay: function(id) {
        return this.packageDocument.getMediaOverlayItem(id);
    }
});
// `PackageDocumentParser` are used to parse the xml of an epub package
// document and build a javascript object. The constructor accepts an
// instance of `URI` that is used to resolve paths durring the process
Readium.Models.PackageDocumentParser = function(uri_object) {
	this.uri_obj = uri_object;
};

// We use [Jath](https://github.com/dnewcome/jath) for converting xml into
// JSON in a declaritive manner. This is the template that performs that
// conversion
Readium.Models.PackageDocumentParser.JathTemplate = {

	metadata:  { 
		id: "//def:metadata/dc:identifier",
		epub_version: "//def:package/@version",
		title: "//def:metadata/dc:title",
		author: "//def:metadata/dc:creator",
		publisher: "//def:metadata/dc:publisher",
		description: "//def:metadata/dc:description",
		rights: "//def:metadata/dc:rights",
		language: "//def:metadata/dc:language",
		pubdate: "//def:metadata/dc:date",
		modified_date: "//def:metadata/def:meta[@property='dcterms:modified']",
		layout: "//def:metadata/def:meta[@property='rendition:layout']",
		spread: "//def:metadata/def:meta[@property='rendition:spread']",
		orientation: "//def:metadata/def:meta[@property='rendition:orientation']",
		ncx: "//def:spine/@toc",
		page_prog_dir: "//def:spine/@page-progression-direction",
		active_class: "//def:metadata/def:meta[@property='media:active-class']"
	 },

	manifest: [ "//def:item", { 
		id: "@id",
		href: "@href",
		media_type: "@media-type",
		properties: "@properties",
        media_overlay: "@media-overlay"
	} ],
						 
	spine: [ "//def:itemref", { idref: "@idref", properties: "@properties", linear: "@linear" } ],

	bindings: ["//def:bindings/def:mediaType", { 
		handler: "@handler",
		media_type: "@media-type"
	} ]
	
};

// Parse an XML package document into a javascript object
Readium.Models.PackageDocumentParser.prototype.parse = function(xml_content) {

	var json, manifest, cover, xmlDom;
	if(typeof(xml_content) === "string" ) {
		var parser = new window.DOMParser;
  		xmlDom = parser.parseFromString(xml_content, 'text/xml');
	}
	else {
		xmlDom = xml_content;
	}

	Jath.resolver = function( prefix ) {
		var mappings = { 
    		def: "http://www.idpf.org/2007/opf",
			dc: "http://purl.org/dc/elements/1.1/"
		};
		return mappings[ prefix ];
	}

	json = Jath.parse( Readium.Models.PackageDocumentParser.JathTemplate, xmlDom);

	// parse the page-progression-direction if it is present
	json.paginate_backwards = this.paginateBackwards(xmlDom);

	// try to find a cover image
	cover = this.getCoverHref(xmlDom);
	if(cover) {
		json.metadata.cover_href = this.resolveUri(cover);
	}		
	if(json.metadata.layout === "pre-paginated") {
		json.metadata.fixed_layout = true;
	}
    
    // parse the manifest into a proper collection
	json.manifest = new Readium.Collections.ManifestItems(json.manifest, {packageDocument: this});

	// create a map of all the media overlay objects
	json.mo_map = this.resolveMediaOverlays(json.manifest);

	// parse the spine into a proper collection
	json.spine = this.parseSpineProperties(json.spine);

	// return the parse result
	return json;

};

	

Readium.Models.PackageDocumentParser.prototype.getCoverHref = function(dom) {
	var manifest; var $imageNode;
	manifest = dom.getElementsByTagName('manifest')[0];

	// epub3 spec for a cover image is like this:
	/*<item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />*/
	$imageNode = $('item[properties~="cover-image"]', manifest);
	if($imageNode.length === 1 && $imageNode.attr("href") ) {
		return $imageNode.attr("href");
	}

	// some epub2's cover image is like this:
	/*<meta name="cover" content="cover-image-item-id" />*/
	var metaNode = $('meta[name="cover"]', dom);
	var contentAttr = metaNode.attr("content");
	if(metaNode.length === 1 && contentAttr) {
		$imageNode = $('item[id="'+contentAttr+'"]', manifest);
		if($imageNode.length === 1 && $imageNode.attr("href")) {
			return $imageNode.attr("href");
		}
	}

	// that didn't seem to work so, it think epub2 just uses item with id=cover
	$imageNode = $('#cover', manifest);
	if($imageNode.length === 1 && $imageNode.attr("href")) {
		return $imageNode.attr("href");
	}

	// seems like there isn't one, thats ok...
	return null;
};

Readium.Models.PackageDocumentParser.prototype.parseSpineProperties = function(spine) {
	
	var parseProperiesString = function(str) {
		var properties = {};
		var allPropStrs = str.split(" "); // split it on white space
		for(var i = 0; i < allPropStrs.length; i++) {
			// brute force!!!
			//rendition:orientation landscape | portrait | auto
			//rendition:spread none | landscape | portrait | both | auto

			//rendition:page-spread-center 
			//page-spread | left | right
			//rendition:layout reflowable | pre-paginated
			if(allPropStrs[i] === "rendition:page-spread-center") properties.page_spread = "center";
			if(allPropStrs[i] === "page-spread-left") properties.page_spread = "left";
			if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
			if(allPropStrs[i] === "page-spread-right") properties.page_spread = "right";
			if(allPropStrs[i] === "rendition:layout-reflowable") properties.fixed_flow = false;
			if(allPropStrs[i] === "rendition:layout-pre-paginated") properties.fixed_flow = true;
		}
		return properties;
		
	}

	for(var i = 0; i < spine.length; i++) {
		var props = parseProperiesString(spine[i].properties);
		// add all the properties to the spine item
		_.extend(spine[i], props);
	}
	return spine;
};

// resolve the url of smils on any manifest items that have a MO
// attribute
Readium.Models.PackageDocumentParser.prototype.resolveMediaOverlays = function(manifest) {
	var that = this;
    var momap = {};
    
    // create a bunch of media overlay objects
    manifest.forEach( function(item) {
		if(item.get("media_type") === "application/smil+xml") {
            var url = that.resolveUri(item.get("href"));
            var moObject = new Readium.Models.MediaOverlay();
            moObject.setUrl(url);
            moObject.fetch(); 
            momap[item.id] = moObject;
        }
	});
	return momap;
};

// parse the EPUB3 `page-progression-direction` attribute
Readium.Models.PackageDocumentParser.prototype.paginateBackwards = function(xmlDom) {
	return $('spine', xmlDom).attr('page-progression-direction') === "ltr";
};


// combine the spine item data with the corresponding manifest
// data to build useful set of backbone objects
Readium.Models.PackageDocumentParser.prototype.crunchSpine = function(spine, manifest) {
	//var bbSpine = new Readium.Collections.Spine(spine, {packageDocument: this});
	var that = this;
	var index = -1; // to keep track of the index of each spine item
	
	var bbSpine = _.map(spine, function(spineItem) {
		index += 1;
		
		var manItem = manifest.find(function(x) {
			if(x.get("id") === spineItem["idref"]) return x;
		});

		// crunch spine attrs and manifest attrs together into one obj
		var book = that.get("book");
		return _.extend({}, spineItem, manItem.attributes, {"spine_index": index}, {"page_prog_dir": book.get("page_prog_dir")});
	});

	return new Readium.Collections.Spine(bbSpine, {packageDocument: this});
};

// convert a relative uri to a fully resolved one
Readium.Models.PackageDocumentParser.prototype.resolveUri = function(rel_uri) {
	uri = new URI(rel_uri);
	return uri.resolve(this.uri_obj).toString();
};
// This class is used to navigate an EPub's package document
Readium.Models.PackageDocument = Backbone.Model.extend({

	initialize: function(attributes, options) {
		var that = this;
		
		if(!attributes.file_path) {
			// Sanity Check: we need to know where to fetch the data from
			throw "This class cannot be synced without a file path";
		}
		else {
			// set it as a property of `this` so that `BackboneFileSystemSync`
			// knows how to find it
			this.file_path = attributes.file_path;

			// use the `FileSystemApi` to generate a fully resolved
			// `filesytem:url`
			Readium.FileSystemApi(function(api) {
				api.getFsUri(that.file_path, function(uri) {
					that.uri_obj = new URI(uri);
				})
			});
		}
		this.on('change:spine_position', this.onSpinePosChanged);
		
    },

    onSpinePosChanged: function() {
    	if( this.get("spine_position") >= this.previous("spine_position") ) {
    		this.trigger("increased:spine_position");
    	}
    	else {
    		this.trigger("decreased:spine_position");
    	}
    },

	// just want to make sure that we do not slip into an
	// invalid state
	validate: function(attrs) {
		
		if( !( attrs.manifest || this.get("manifest") ) ) {
			return "ERROR: All ePUBs must have a manifest";
		}

		//validate the spine exists and the position is valids
		var spine = attrs.spine || this.get("spine") ;
		if( !spine ) {
			return "ERROR: All ePUBs must have a spine";
		}
		if(attrs.spine_position < 0 || attrs.spine_position >= spine.length)	{
			return "ERROR: invalid spine position";
		}
	},

	sync: BBFileSystemSync,

	defaults: {
		spine_position: 0
	},
	
	getManifestItemById: function(id) {
		return this.get("manifest").find(function(x) { 
					if(x.get("id") === id) return x;
				});
	},

	getSpineItem: function(index) {
		return this.get("res_spine").at(index);
	},

	spineLength: function() {
		return this.get("res_spine").length;
	},

	// gets the next position in the spine for which the
	// spineItem does not have `linear='false'`. The start
	// param is the non-inclusive position to begin the search
	// from. If start is not supplied, the search will begin at
	// postion 0. If no linear position can be found, this 
	// funciton returns -1
	getNextLinearSpinePostition: function(start) {
		var spine = this.get("res_spine");
		if(start === undefined || start < -1) {
			start = -1;
		}

		while(start < spine.length - 1) {
			start += 1;
			if(spine.at(start).get("linear") !== "no") {
				return start;
			}
		}

		return -1;
	},

	// gets the previous position in the spine for which the
	// spineItem does not have `linear='false'`. The start
	// param is the non-inclusive position to begin the search
	// from. If start is not supplied, the search will begin at
	// the end of the spine. If no linear position can be found, 
	// this function returns -1
	getPrevLinearSpinePostition: function(start) {
		var spine = this.get("res_spine");
		if(start === undefined || start > spine.length) {
			start = spine.length;
		}

		while(start > 0) {
			start -= 1;
			if(spine.at(start).get("linear") !== "no") {
				return start;
			}
		}

		return -1;
	},

	goToNextSection: function() {
		var cp = this.get("spine_position");
		this.set({spine_position: (cp + 1) });
	},

	goToPrevSection: function() {
		var cp = this.get("spine_position");
		this.set({spine_position: (cp - 1) });	
	},

	spineIndexFromHref: function(href) {
		var spine = this.get("res_spine");
		href = this.resolveUri(href).replace(/#.*$/, "");
		for(var i = 0; i < spine.length; i++) {
			var path = spine.at(i).get("href");
			path = this.resolveUri(path).replace(/#.*$/, "");
			if(path === href) {
				return i;
			}
		}
		return -1;
	},

	goToHref: function(href) {
		var spine = this.get("spine");
		var manifest = this.get("manifest");
		var that = this;
		href = that.resolveUri(href).replace(/#.*$/, "");
		var node = manifest.find(function(x) {
			var path = that.resolveUri(x.get("href")).replace(/#.*$/, "");
			if (href == path) return x;
		});
								 
		// didn't find the spine node, href invalid
		if(!node) {
			return null;
		}

		var id = node.get("id");
		
		for(var i = 0; i < spine.length; ++i ) {
			if(spine[i].idref === id) {
				// always aproach link spine items in fwd dir
				this.set({spine_position: i}, {silent: true});
				this._previousAttributes.spine_position = 0
				this.trigger("change:spine_position")
				break;
			}
		}
	},

	getTocItem: function() {
		var manifest = this.get("manifest");
		var spine_id = this.get("metadata").ncx;
		var item = manifest.find(function(item){ 
			return item.get("properties") === "nav" 
		});

		if( item ) {
			return item;
		}

		if( spine_id && spine_id.length > 0 ) {
			return manifest.find(function(item) {
				return item.get("id") === spine_id;
			});
		}

		return null;
	},

	getMediaOverlayItem: function(idref) {
		// just look up the object in the mo_map
		var map = this.get("mo_map");
		return map && map[idref];
	},

	// combine the spine item data with the corresponding manifest
	// data to build useful set of backbone objects
	crunchSpine: function(spine, manifest) {
		//var bbSpine = new Readium.Collections.Spine(spine, {packageDocument: this});
		var that = this;
		var index = -1; // to keep track of the index of each spine item
		
		var bbSpine = _.map(spine, function(spineItem) {
			index += 1;
			
			var manItem = manifest.find(function(x) {
				if(x.get("id") === spineItem["idref"]) return x;
			});

			// crunch spine attrs and manifest attrs together into one obj
			var book = that.get("book");
			return _.extend({}, spineItem, manItem.attributes, {"spine_index": index}, {"page_prog_dir": book.get("page_prog_dir")});
		});

		// Add the index of the spine item to the manifest item's id to prevent the backbone collection
		//   from finding duplicate manifest items when different itemref elements in the spine reference
		//   the same manifest item through the "idref" attribute.
		$.each(bbSpine, function () {
			this.id = this.id + this.spine_index;
		});

		return new Readium.Collections.Spine(bbSpine, {packageDocument: this});
	},

	parse: function(xmlDom) {
		var parser = new Readium.Models.PackageDocumentParser(this.uri_obj);
		var json = parser.parse(xmlDom);
		json.res_spine = this.crunchSpine(json.spine, json.manifest);
		return json;
	},

	resolveUri: function(rel_uri) {
		uri = new URI(rel_uri);
		return uri.resolve(this.uri_obj).toString();
	},

	// reslove a relative file path to relative to this the
	// the path of this pack docs file path
	resolvePath: function(path) {
		var suffix;
		var pack_doc_path = this.file_path;
		if(path.indexOf("../") === 0) {
			suffix = path.substr(3);
		}
		else {
			suffix = path;
		}
		var ind = pack_doc_path.lastIndexOf("/")
		return pack_doc_path.substr(0, ind) + "/" + suffix;
	}


});
// Description: This model is a sort of "controller" for an ePUB, managing the interaction between calling code
//   and the saved epub. This model also exposes and persists properties that determine how an epub is displayed in 
//   Readium. Some of these properties are determined by the user, such as whether two pages are being displayed, the font size etc.
//   Other properties are determined by the user's interaction with the reader and the structure of the book. These include
//   the current spine item rendered in the viewer, as well the logic that governs changing the current spine item.  
//
// Rationale: This model is designed to expose a useful concept of an "epub" to the rest of Readium. This includes the contents
//   of the epub itself, as well as view properties (mentioned above) and the logic governing interaction with epub properties and 
//   contents. It is the intention for this model that it have little to no knowledge of how an epub is rendered. It is intended 
//   that Backbone attributes (getting/setting) and the backbone attribute event model (events fired on attribute changes) should 
//   the primary ways of interacting with this model.

// REFACTORING CANDIDATE: Need to think about the purpose and implementation of the hash_fragment attribute

Readium.Models.EPUBController = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function() {

		// capture context for use in callback functions
		var that = this;

		this.epub = this.get("epub");
        
        this.set("media_overlay_controller", 
            new Readium.Models.MediaOverlayController({epubController : this}));

		// create a [`Paginator`](/docs/paginator.html) object used to initialize
		// pagination strategies for the spine items of this book
		this.paginator = new Readium.Models.PaginationStrategySelector({book: this});

		// Get the epub package document
		this.packageDocument = this.epub.getPackageDocument();

		// TODO: this might have to change: Should this model load the package document or epub_state??
		// load the `packageDocument` from the HTML5 filesystem asynchroniously
		this.packageDocument.fetch({

			// success callback is executed once the filesSystem contents have 
			// been read and parsed
			success: function() {

				// restore the position the reader left off at from cookie storage
				var pos = that.restorePosition();
				that.set("spine_position", pos);

				// tell the paginator to start rendering spine items from the 
				// freshly restored position
				var items = that.paginator.renderSpineItems(false);
				that.set("rendered_spine_items", items);
				
				// check if a TOC is specified in the `packageDocument`
				that.set("has_toc", ( !!that.packageDocument.getTocItem() ) );
			}
		});
        
        // `change:spine_position` is triggered whenver the reader turns pages
		// accross a `spine_item` boundary. We need to cache thier new position
		// and 
		this.on("change:spine_position", this.savePosition, this);

		// If we encounter a new fixed layout section, we need to parse the 
		// `<meta name="viewport">` to determine the size of the iframe
		this.on("change:spine_position", this.setMetaSize, this);
	},

	// Description: Persists the attributes of this model
	// Arguments (
	//   attrs: doesn't appear to be used
	//   options: 
	//	)
	// Rationale: Each epub unpacked and saved to the filesystem in Readium has a unique
	//   key. "_epubViewProperties" is appended to this unique key to persist the read/write
	//   attributes separately from the read-only attributes of the epub.
	save: function(attrs, options) {
		// TODO: this should be done properly with a backbone sync
		var ops = {
			success: function() {
			}
		}
		_.extend(ops,options);
		var that = this;

		// Set attributes required to persist the epub-specific viewer properties
		this.set("updated_at", new Date());
		this.set("key", this.epub.get("key") + "_epubViewProperties");

		// Persist viewer properties
		Lawnchair(function() {
			this.save(that.toJSON(), ops.success);
		});
	},

	defaults: {
		"font_size": 10,
    	"two_up": false,
    	"full_screen": false,
    	"toolbar_visible": true,
    	"toc_visible": false,
    	"rendered_spine_items": [],
    	"current_theme": "default-theme",
    	"current_margin": 3,
    	"epubCFIs" : {}
  	},

  	// Description: serialize this models state to `JSON` so that it can
  	//   be persisted and restored
  	toJSON: function() {

  		// only save attrs that should be persisted:
  		return {
			"updated_at": this.get("updated_at"),
			"current_theme": this.get("current_theme"),
			"current_margin": this.get("current_margin"),
			"two_up": this.get("two_up"),
			"font_size": this.get("font_size"),
			"key": this.get("key"),
			"epubCFIs" : this.get("epubCFIs")
		};
	},

	toggleFullScreen: function() {
		var fullScreen = this.get("full_screen");
		this.set({full_screen: !fullScreen});
	},

	increaseFont: function() {
		var size = this.get("font_size");
		this.set({font_size: size + 1})
	},

	decreaseFont: function() {
		var size = this.get("font_size");
		this.set({font_size: size - 1})
	},

	toggleToc: function() {
		var vis = this.get("toc_visible");
		this.set("toc_visible", !vis);
	},

	// Description: Obtains the href and hash (if it exists) to set as the current "position"
	//    of the epub. Any views and models listening to epub attributes are informed through
	//    the backbone event broadcast.
	// Arguments (
	//   href (URL): The url and hash fragment that indicates the position in the epub to set as
	//   the epub's current position. This argument either has to be the absolute path of the resource in 
	//   the filesystem, or the path of the resource RELATIVE to the package document.
	//   When a URI is resolved by the package document model, it assumes that any relative path for a resource is
	//   relative to the package document.
	// )
	goToHref: function(href) {
		// URL's with hash fragments require special treatment, so
		// first thing is to split off the hash frag from the rest
		// of the url:
		var splitUrl = href.match(/([^#]*)(?:#(.*))?/);

		// Check if the hash contained a CFI reference
		if (splitUrl[2] && splitUrl[2].match(/epubcfi/)) {

			this.handleCFIReference(splitUrl[2]);
		}
		// The href is a standard hash fragment
		else {

			// REFACTORING CANDIDATE: Move this into its own "private" method
			if(splitUrl[1]) {
				var spine_pos = this.packageDocument.spineIndexFromHref(splitUrl[1]);
				this.setSpinePos(spine_pos, false, false, splitUrl[2]);
				this.set("hash_fragment", splitUrl[2]);
			}
		}
	},

	getToc: function() {
		var item = this.packageDocument.getTocItem();
		if(!item) {
			return null;
		}
		else {
			var that = this;
			return Readium.Models.Toc.getToc(item, {
				file_path: that.resolvePath(item.get("href")),
				book: that
			});
		}
	},

	// Info: "Section" actually refers to a spine item
	getCurrentSection: function(offset) {
		if(!offset) {
			offset = 0;
		}
		var spine_pos = this.get("spine_position") + offset;
		return this.packageDocument.getSpineItem(spine_pos);
	},

	// REFACTORING CANDIDATE: this should be renamed to indicate it applies to the entire epub.
	//   This is only passing through this data to avoid breaking code in viewer.js. Eventually
	//   this should probably be removed. 
	isFixedLayout: function() {
		return this.epub.isFixedLayout();
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	handleCFIReference : function (CFI) {

		var packageDocument;
		var hrefOfFirstContentDoc;
		var spinePos;
		var elementId;

		// REFACTORING CANDIDATE: This is a temporary approach for retrieving a document representation of the 
		//   package document. Probably best that the package model be able to return this representation of itself.
        $.ajax({

            type: "GET",
            url: this.epub.get("root_url"),
            dataType: "xml",
            async: false,
            success: function (response) {

                packageDocument = response;
            }
        });

		// get the href of the first content document
		hrefOfFirstContentDoc = EPUBcfi.Interpreter.getContentDocHref(CFI, packageDocument);

		// get the spine position of the content document and add the cfi to the current list, set the spine position
		spinePos = this.packageDocument.spineIndexFromHref(hrefOfFirstContentDoc);

		// Generate an element id from the CFI
		// REFACTORING CANDIDATE: There is no need for this to be a cryptographic hash function. It was chosen 
		//   because the Crypto library was already part of Readium. All that is required here is a unique id
		//   for injected elements. 
		var elementId = Crypto.SHA1(CFI);

		this.addCFIwithPayload(CFI, spinePos, "<span id='" + elementId + "' class='cfi_marker' data-cfi='" + CFI + "'></span>");
		this.setSpinePos(spinePos, false, true, elementId);
		this.set("hash_fragment", elementId);
	},

	restorePosition: function() {
		var pos = Readium.Utils.getCookie(this.epub.get("key"));
		return parseInt(pos, 10) || this.packageDocument.getNextLinearSpinePostition();
	},

	savePosition: function() {
		Readium.Utils.setCookie(this.epub.get("key"), this.get("spine_position"), 365);
	},

	resolvePath: function(path) {
		return this.packageDocument.resolvePath(path);
	},

	hasNextSection: function() {
		var start = this.get("spine_position");
		return this.packageDocument.getPrevLinearSpinePostition(start) > -1;
	},

	hasPrevSection: function() {
		var start = this.get("spine_position");
		return this.packageDocument.getNextLinearSpinePostition(start) > -1;
	},
	
	// goes the next linear section in the spine. Non-linear sections should be
	// skipped as per [the spec](http://idpf.org/epub/30/spec/epub30-publications.html#sec-itemref-elem)
	// REFACTORING CANDIDATE: I think this is a public method and should be moved to the public section
	goToNextSection: function() {

		var cp = this.get("spine_position");
		var pos = this.packageDocument.getNextLinearSpinePostition(cp);
		if(pos > -1) {
			this.setSpinePos(pos, false, false);
		}
	},
	
	// goes the previous linear section in the spine. Non-linear sections should be
	// skipped as per [the spec](http://idpf.org/epub/30/spec/epub30-publications.html#sec-itemref-elem)
	// REFACTORING CANDIDATE: I think this is a public method and should be moved to the public section
	goToPrevSection: function() {
		var cp = this.get("spine_position");
		var pos = this.packageDocument.getPrevLinearSpinePostition(cp);
		if(pos > -1) {
			this.setSpinePos(pos, true, false);
		}
	},

	// Description: Sets the current spine position for the epub, checking if the spine
	//   item is already rendered. 
	// Arguments (
	//	 pos (integer): The index of the spine element to set as the current spine position
	//   goToLastPageOfSection (boolean): Set the viewer to the last page of the spine item (content document/svg)
	//     that will be loaded.
	//   reRenderSpinePos (boolean): Force the spine item to be re-rendered, regardless of whether it is the 
	//     currently set spine item.
	//   goToHashFragmentId: Set the view position to the element with the specified id. This parameter 
	//     overrides the behaviour of "goToLastPageOfSection"
	//	)
	// REFACTORING CANDIDATE: The abstraction here is getting sloppy, as goToHashFragmentId overrides goToLastPageOfSection
	//   and generally, the behaviour of this method is not entirely clear from its name. Perhaps a simple renaming of the
	//   method would suffice? Additionally, the internal impementation could be reviewed to tightened up (comments below).
	setSpinePos: function(pos, goToLastPageOfSection, reRenderSpinePos, goToHashFragmentId) {

		// check for invalid spine position
		if (pos < 0 || pos >= this.packageDocument.spineLength()) {
			
			return;
		}

		var spineItems = this.get("rendered_spine_items");
		var spinePosIsRendered = spineItems.indexOf(pos) >=0 ? true : false;

		// REFACTORING CANDIDATE: There is a somewhat hidden dependency here between the paginator
		//   and the setting of the spine_position. The pagination strategy selector re-renders based on the currently
		//   set spine_position on this model. The pagination strategy selector has a reference to this model, which is 
		//   how it accesses the new spine_position, through the "getCurrentSection" method. 
		//   This would be clearer if the spine_position to set were passed explicitly to the paginator. 
		this.set("spine_position", pos);

		// REFACTORING CANDIDATE: This event should only be triggered for fixed layout sections
		this.trigger("FXL_goToPage");

		// Render the new spine position if it is not already rendered. Otherwise, check if a re-render should
		// be forced (in case a new CFI has to be injected, for example). 
		if (!spinePosIsRendered) {

			var renderedItems = this.paginator.renderSpineItems(goToLastPageOfSection, goToHashFragmentId);
			this.set("rendered_spine_items", renderedItems);
		}
		else {

			if (reRenderSpinePos) {

				var renderedItems = this.paginator.renderSpineItems(goToLastPageOfSection, goToHashFragmentId);
				this.set("rendered_spine_items", renderedItems);				
			}
			else {

				if (!this.isFixedLayout() && goToHashFragmentId) {
					this.paginator.v.goToHashFragment(goToHashFragmentId);
				}
			}
		}
	},

	setMetaSize: function() {

		if(this.meta_section) {
			this.meta_section.off("change:meta_height", this.setMetaSize);
		}
		this.meta_section = this.getCurrentSection();
		if(this.meta_section.get("meta_height")) {
			this.set("meta_size", {
				width: this.meta_section.get("meta_width"),
				height: this.meta_section.get("meta_height")
			});
		}
		this.meta_section.on("change:meta_height", this.setMetaSize, this);
	},

	// REFACTORING CANDIDATE: The methods related to maintaining a hash of cfi information and payloads
	//   will likely be refactored into its own backbone object.
	addCFIwithPayload : function (CFI, spinePosition, htmlPayload, bodyType) {

		var cfiPayload = { contentDocSpinePos : spinePosition, payload : htmlPayload, type : bodyType };
		this.get("epubCFIs")[CFI] = cfiPayload;
	},

	addLastPageCFI : function (CFI, spinePosition) {

		// Create last page marker
		var elementId = Crypto.SHA1(CFI);
		var marker = "<span id='" + elementId + "' data-last-page-cfi='" + CFI + "' class='cfi-marker last-page'></span>";

		// Create payload
		var cfiPayload = { contentDocSpinePos : spinePosition, payload : marker, type : "last-page" };

		// Check if a last page marker already exists
		var CFIPayloads = this.get("epubCFIs");

		// Check every CFI payload for a "last-page" type, in case more than one exists
		$.each(CFIPayloads, function (currCFI, payloadObject) {

			if (this.type === "last-page") {
				delete CFIPayloads[currCFI]
			}
		});

		// Add the new last page marker
		this.get("epubCFIs")[CFI] = cfiPayload;	
	}
});
Readium.Models.OptionsPresenter = Backbone.Model.extend({

	initialize: function() {
		var book = this.get("book");
		if(!book) {
			throw "ebook must be set in the constructor";
		}
		this.resetOptions();

		// keep self up to date with book
		book.on("change:font_size", this.resetOptions, this);
		book.on("change:two_up", this.resetOptions, this);
		book.on("change:current_theme", this.resetOptions, this);
		book.on("change:current_margin", this.resetOptions, this);
	},

	applyOptions: function() {
		var book = this.get("book");

		// set everything but two_up
		book.set({
			"font_size": 		this.get("font_size"),
	    	"current_theme": 	this.get("current_theme"),
	    	"current_margin": 	this.get("current_margin")
		});

		// cannot set two_up directly, need to call toggle
		// so determine if we should
		var shouldToggleTwoUp = this.get("two_up") !== book.get("two_up");
		if (shouldToggleTwoUp) {

			book.set("two_up", !book.get("two_up"));
		}

		// persist user settings for next time
		book.save();
	},

	resetOptions: function() {
		var book = this.get("book");
		this.set({
			"font_size": 		book.get("font_size"),
	    	"two_up": 			book.get("two_up"),
	    	"current_theme": 	book.get("current_theme"),
	    	"current_margin": 	book.get("current_margin")
		});
	}
});
Readium.Models.Toc = Backbone.Model.extend({

	sync: BBFileSystemSync,

	initialize: function(options) {
		this.file_path = options.file_path;
		this.book = options.book;
		this.book.on("change:toc_visible", this.setVisibility, this);
		this.book.on("change:toolbar_visible", this.setTocVis, this);
	},

	// Rationale: Readium expects that any hrefs to EPUB content are either absolute references or references to the content relative
	//   to the EPUBs package document. Since any href passed to this method is specified as either absolute (in which case we 
	//   don't need to worry) or as relative to the nav document (where the click was generated, as this is the toc), we need
	//   to construct an absolute path from that.
	handleLink: function(href) {

		var TOCHref = this.book.packageDocument.getTocItem().get("href");

		// If toc is in the same folder as the package document, use the href straight
		if (TOCHref.indexOf("/") === -1) {

			this.book.goToHref(href);	
		}
		// If the href target is in a child folder of the toc folder, create the relative URI
		// If the href target is in a parent folder of the toc folder, this will fail, for now.
		else {

			var TOC_URI = new URI(TOCHref);
			var targetHrefURI = new URI(href);

			// Use the TOC path, relative to the package document to create an href for the target resource which will also be relative
			//   to the package document (or absolute, if the href for the TOC was absolute).
			href = targetHrefURI.resolve(TOC_URI).toString();
			this.book.goToHref(href);
		}
	},

	setVisibility: function() {
		this.set("visible", this.book.get("toc_visible"));
	},

	hide: function() {
		this.book.set("toc_visible", false)
	},

	setTocVis: function() {
		if(!this.book.get("toolbar_visible")) {
			this.book.set("toc_visible", false);
		}
	},

	defaults: {
		visible: false
	}

}, {
	// Class Level Attributes!
	XHTML_MIME: "application/xhtml+xml",
	XML_MIME: "text/xml",	
	NCX_MIME: "application/x-dtbncx+xml",
	getToc: function(manItem, options) {
		var media_type = manItem.get("media_type");
		if(media_type === Readium.Models.Toc.XHTML_MIME || 
				media_type === Readium.Models.Toc.XML_MIME) {
			return new Readium.Models.XhtmlToc(options);
		}
		else if (media_type ===  Readium.Models.Toc.NCX_MIME) {
			return new Readium.Models.NcxToc(options);
		}
	}
});


Readium.Models.NcxToc = Readium.Models.Toc.extend({

	jath_template: {

		title: "//ncx:docTitle/ncx:text",

		navs: [ "//ncx:navMap/ncx:navPoint", { 
			text: "ncx:navLabel/ncx:text",
			href: "ncx:content/@src"
		} ]
	},

	// Rationale: This method does not use JATH to parse an NCX document, as JATH doesn't really support elements nested 
	//   recursively, as is possibly the case for navPoint elements in an NCX document. 
	parse: function (xmlDom) {
		var ncxJson = {};

		var $navMap;
		var that = this;

		if (typeof(xmlDom) === "string") {
			var parser = new window.DOMParser;
      		xmlDom = parser.parseFromString(xmlDom, 'text/xml');
		}

		// Get NCX TOC text title
		ncxJson.title = $($("text", $("docTitle", xmlDom)[0])[0]).text();
		
		// For each navpoint, create navPoint objects recursively
		ncxJson.navs = [];
		$navMap = $("navMap", xmlDom);
		$.each($navMap.children(), function() {

			if ($(this).is("navPoint")) {

				ncxJson.navs.push(that.createNavPointObject($(this)));
			}
		});

		return ncxJson;
	},

	// Description: Creates an object that represents a NCX navPoint.   
	// Rationale: Since navPoints can be nested within each other, this method creates each navPoint object recursively.
	createNavPointObject : function ($navPoint) {

		var jsonNavPoint = {};
		var that = this;

		// Each navPoint object has a content src, a label and 0 or more child navPoints
		jsonNavPoint.navs = [];
		$.each($navPoint.children(), function () {

			$currElement = $(this);
			if ($currElement.is("content")) {

				jsonNavPoint.href = $currElement.attr("src");
			}
			else if ($currElement.is("navLabel")) {

				jsonNavPoint.text = $($("text", $currElement)[0]).text();
			}
			else if ($currElement.is("navPoint")) {

				jsonNavPoint.navs.push(that.createNavPointObject($currElement));
			}
		});

		return jsonNavPoint;
	},

	TocView: function() {
		return new Readium.Views.NcxTocView({model: this});
	}
});

Readium.Models.XhtmlToc = Readium.Models.Toc.extend({

	parse: function(xmlDom) {
		var json = {};
		if(typeof(xmlDom) === "string" ) {
			var parser = new window.DOMParser;
      		xmlDom = parser.parseFromString(xmlDom, 'text/xml');
		}
		json.title = $('title', xmlDom).text();
		json.body = $('body', xmlDom);
		return json;
	},

	TocView: function() {
		return new Readium.Views.XhtmlTocView({model: this});
	}
});
// SmilModel both creates and plays the model
// Right now, the model extends the SMIL XML DOM; 
// if this becomes too heavy, we could use a custom lightweight tree instead
Readium.Models.SmilModel = function() {
    
    // these are playback logic functions for SMIL nodes
    // the context of each function is the node itself, as these functions will be attached to the nodes as members
    // e.g. 
    // parNode.render = parRender
    // seqNode.render = seqRender
    // etc
    NodeLogic = {
        
        parRender: function() {
            $.each(this.childNodes, function(index, value) {
                if (value.hasOwnProperty("render")) {
                    value.render();
                }
            });
        },
    
        // render starting at the given node; if null, start at the beginning
        seqRender: function(node) {
            if (node == null) {
                this.firstElementChild.render();
            }
            else {
                node.render();
            }
        },
    
        // called when the clip has completed playback
        audioNotifyChildDone: function() {
            this.parentNode.notifyChildDone(this);
        },
    
        // receive notice that a child node has finished playing
        parNotifyChildDone: function(node) {
            // we're only expecting one audio node child that we have to wait for
            // in the case of a more complex SMIL document (i.e. not media overlays), 
            // we might have to wait for more children to finish playing
            if (node.tagName == "audio") {
                this.parentNode.notifyChildDone(this);
            }
        },
    
        // receive notice that a child node has finished playing
        seqNotifyChildDone: function(node) {
            if (node.nextElementSibling == null) {
                if (this == root) {
                    notifySmilDone();
                }
                else {
                    this.parentNode.notifyChildDone(this);
                }
            }
            else {
                // prepare to play the next child node
                this.render(node.nextElementSibling);
            }
        }
    };
    
    
    // default renderers for time container playback
    // treat <body> like <seq>
    var renderers = {"seq": NodeLogic.seqRender, 
                    "par": NodeLogic.parRender, 
                    "body": NodeLogic.seqRender};
                    
    // each node type has a notification function associated with it
    // the notifiers get called when a child of the node has finished playback
    var notifiers = {"seq": NodeLogic.seqNotifyChildDone, 
                    "par": NodeLogic.parNotifyChildDone, 
                    "body": NodeLogic.seqNotifyChildDone,
                    "audio": NodeLogic.audioNotifyChildDone,
                    "text": function() {}}
    var url = null;
    var notifySmilDone = null;
    var root = null;
    
    // call this first with the media node renderers to add them to the master list
    this.addRenderers = function(rendererList) {
        renderers = $.extend(renderers, rendererList);
    };
    
    // set this so the model can resolve src attributes
    this.setUrl = function(fileUrl) {
        url = fileUrl;
    };
    
    // set the callback for when the tree is done
    this.setNotifySmilDone = function(fn) {
        notifySmilDone = fn;
    };
    
    // build the model
    // node is the root of the SMIL tree, for example the body node of the DOM
    this.build = function(node) {
        root = node;
        processTree(node);
    };
    
    // prepare the tree to start rendering from a node
    this.render = function(node) {
        if (node == null || node == undefined || node == root) {
            root.render(null);
        }
        else {
            // if we're jumping to a point in the middle of the tree, then mark the first audio clip as a jump target
            // because it affects audio playback
            var audioNode = this.peekNextAudio(node);
            audioNode.isJumpTarget = true;
            node.parentNode.render(node);
        }
    };
    
    // find the first node with the given attribute value
    // e.g.
    // findNodeByAttrValue("*", "id", "num1")
    // findNodeByAttrValue("text", "", "")
    // findNodeByAttrValue("*", "id", "")
    // but NOT findNodeByAttrValue("text", "", "num1")
    this.findNodeByAttrValue = function(nodename, attr, val) {
        if (root == null) return null;
        var res = null;
        var attr_ = attr;
        if (attr_ == "src" || attr_ == "epub:textref") {
            if (attr_ == "epub:textref") attr_ = "epub\\:textref"; // normalize for jquery
            
            // treat src and textref attrs differently
            // TODO can get better filepath comparison with something like http://medialize.github.com/URI.js/
            // for now, just look at the text file names
            var doc_href = val.substr(val.lastIndexOf("/")+1); 
            var selector = nodename + "[" + attr_ + "]";
            var potentialMatches = $(root).find(selector);
            if (val == "") {
                res = potentialMatches[0];
            }
            else {
                potentialMatches.each(function(idx) {
                    var src = $(this).attr(attr_);
                    if (src != undefined) {
                        // TODO use a proper URI library to get more accurate filepath comparison (same as above)
                        src = src.substr(src.lastIndexOf("/")+1);
                        if (src === doc_href) {
                            res = this;
                            return false;
                        }
                    }
                });
            }
        }
        else {
            var selector = nodename;
            if (attr_ != "") {
                selector += "[" + attr_;
                if (val != "") {
                    selector += "='" + val + "'";
                }
                selector += "]";
            }
            res = $(root).find(selector);
            res = res.length == 0 ? null : res[0]; // grab first result
        }   
        return res;
    };
    
    // see what the next audio node is going to be
    // TODO take skippability into consideration
    this.peekNextAudio = function(currentNode) {
        
        // these first 2 cases are arguably just here for convenience: if we're near an audio node, then return it
        // TODO this does not consider that audio elements are actually optional children of <par>
        if (currentNode.tagName == "par") {
            return $(currentNode).find("audio")[0];
        }
        // TODO same as above
        if (currentNode.tagName == "text") {
            return $(currentNode.parentNode).find("audio")[0];
        }
        
        // if we aren't near an audio node, then keep looking
        var node = currentNode.parentNode;
        // go up the tree until we find a relative
        while(node.nextElementSibling == null) {
            node = node.parentNode;
            if (node == root) {
                return null;
            }
        }
        // find the first audio node
        return $(node.nextElementSibling).find("audio")[0];
    };
    
    // recursively process a SMIL XML DOM
    function processTree(node) {
        processNode(node);
        if (node.childNodes.length > 0) {
            $.each(node.childNodes, function(idx, val) {
                processTree(val);
            });
        }
    }       
    
    // process a single node and attach render and notify functions to it
    function processNode(node) {
        // add a toString method for debugging
        node.toString = function() {
            var string = "<" + this.nodeName;
            for (var i = 0; i < this.attributes.length; i++) {
                string += " " + this.attributes.item(i).nodeName + "=" + this.attributes.item(i).nodeValue;
            }
            string += ">";
            return string;
        };
        
        // connect the appropriate renderer
        if (renderers.hasOwnProperty(node.tagName)) {
            node.render = renderers[node.tagName];
        }
        
        // connect the appropriate notifier
        if (notifiers.hasOwnProperty(node.tagName)) {
            node.notifyChildDone = notifiers[node.tagName];
        }
        
        scrubAttributes(node);
    }
    
    // make sure the attributes are to our liking
    function scrubAttributes(node) {
        // TODO do we need to resolve the text srcs too, or does Readium want relative paths?
        
        // process audio nodes' clock values
        if (node.tagName == "audio") {
            if ($(node).attr("src") != undefined) {
                $(node).attr("src", resolveUrl($(node).attr("src"), url));
            }    
            if ($(node).attr("clipBegin") != undefined) {
                $(node).attr("clipBegin", resolveClockValue($(node).attr("clipBegin")));
            }
            else {
                $(node).attr("clipBegin", 0);
            }
            if ($(node).attr("clipEnd") != undefined) {
                $(node).attr("clipEnd", resolveClockValue($(node).attr("clipEnd")));
            }
            else {
                // TODO check if this is reasonable
                $(node).attr("clipEnd", 9999999);
            }
        }
    }
    
    // TODO in the future, this will act as a skippability filter
    function canPlayNode(node) {
        return true;
    }
    
    function resolveUrl(url, baseUrl) {
        if (url.indexOf("://") != -1) {
            return url;
        }
        
        var base = baseUrl;
        if (baseUrl[baseUrl.length-1] != "/") {
            base = baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1);
        }
        return base + url;
    }
    
    // parse the timestamp and return the value in seconds
    // supports this syntax: http://idpf.org/epub/30/spec/epub30-mediaoverlays.html#app-clock-examples
    function resolveClockValue(value) {        
        var hours = 0;
        var mins = 0;
        var secs = 0;
        
        if (value.indexOf("min") != -1) {
            mins = parseFloat(value.substr(0, value.indexOf("min")));
        }
        else if (value.indexOf("ms") != -1) {
            var ms = parseFloat(value.substr(0, value.indexOf("ms")));
            secs = ms/1000;
        }
        else if (value.indexOf("s") != -1) {
            secs = parseFloat(value.substr(0, value.indexOf("s")));                
        }
        else if (value.indexOf("h") != -1) {
            hours = parseFloat(value.substr(0, value.indexOf("h")));                
        }
        else {
            // parse as hh:mm:ss.fraction
            // this also works for seconds-only, e.g. 12.345
            arr = value.split(":");
            secs = parseFloat(arr.pop());
            if (arr.length > 0) {
                mins = parseFloat(arr.pop());
                if (arr.length > 0) {
                    hours = parseFloat(arr.pop());
                }
            }
        }
        var total = hours * 3600 + mins * 60 + secs;
        return total;
    }
};
// loads and plays a single SMIL document
Readium.Models.MediaOverlay = Backbone.Model.extend({
    audioplayer: null,
    smilModel: null,
    consoleTrace: false,
    url: null,
    
    // observable properties
    defaults: {
        current_text_src: null,    
        has_started_playback: false,
        is_document_done: false,
        is_playing: false,
        is_ready: false
    },
    
    initialize: function() {
        var self = this;
        this.audioplayer = new Readium.Models.AudioClipPlayer();
        this.audioplayer.setConsoleTrace(false);

        // always know whether we're playing or paused
        this.audioplayer.setNotifyOnPause(function() {
            self.set({is_playing: self.audioplayer.isPlaying()});
        });
        this.audioplayer.setNotifyOnPlay(function(){
           self.set({is_playing: self.audioplayer.isPlaying()});
        });    
    },
    
    // set the URL before calling fetch()
    setUrl: function(smilUrl) {
        this.url = smilUrl;
    },
    
    // start retrieving the data
    fetch: function(options) {
        this.set({is_ready: false});
        options = options || {};
        options.dataType="xml";
        Backbone.Model.prototype.fetch.call(this, options);
    },
    
    // backbone fetch() callback; passes in an xml data object
    parse: function(xml) {
        var self = this;
        this.smilModel = new Readium.Models.SmilModel();
        this.smilModel.setUrl(this.url);
        this.smilModel.setNotifySmilDone(function() {
            self.debugPrint("document done");
            self.set({is_document_done: true});
        });
        
        // very important piece of code: attach render functions to the model
        // at runtime, 'this' is the node in question
        this.smilModel.addRenderers({
            "audio": function() {
                // have the audio player inform the node directly when it's done playing
                var thisNode = this;
                self.audioplayer.setNotifyClipDone(function() {
                    thisNode.notifyChildDone();
                });
                var isJumpTarget = false;
                if (this.hasOwnProperty("isJumpTarget")) {
                    isJumpTarget = this.isJumpTarget;
                    // reset the node's property
                    this.isJumpTarget = false;
                }
                // play the node
                self.audioplayer.play($(this).attr("src"), parseFloat($(this).attr("clipBegin")), parseFloat($(this).attr("clipEnd")), isJumpTarget);
            }, 
            "text": function(){
                var src = $(this).attr("src");
                self.debugPrint("Text: " + src);
                self.set("current_text_src", src);
            }
        });
        
        // start the playback tree at <body>
        var smiltree = $(xml).find("body")[0]; 
        this.smilModel.build(smiltree);
        this.set({is_ready: true});
    },
    // start playback
    // node is a SMIL node that indicates the starting point
    // if node is null, playback starts at the beginning
    startPlayback: function(node) {
        if (this.get("is_ready") === false) {
            this.debugPrint("document not ready");
            return;
        }
        this.set({is_document_done: false});
        this.set({has_started_playback: true});
        this.smilModel.render(node);        
    },
    pause: function() {
        if (this.get("is_ready") == false) {
            this.debugPrint("document not ready");
            return;
        }
        if (this.get("has_started_playback") == false) {
            this.debugPrint("can't pause: playback not yet started");
            return;
        }
        this.audioplayer.pause();
    },
    resume: function() {
        if (this.get("is_ready") == false) {
            this.debugPrint("document not ready");
            return;
        }
        if (this.get("has_started_playback") == false) {
            this.debugPrint("can't resume: playback not yet started");
            return;
        }
        this.audioplayer.resume();        
    },
    findNodeByTextSrc: function(src) {
        if (this.get("is_ready") == false) {
            this.debugPrint("document not ready");
            return null;
        }
        
        if (src == null || src == undefined || src == "") {
            return null;
        }
        
        var elm = this.smilModel.findNodeByAttrValue("text", "src", src);
        if (elm == null){
            elm = this.smilModel.findNodeByAttrValue("seq", "epub:textref", src);
        }    
        return elm;
    },
    setVolume: function(value) {
        this.audioplayer.setVolume(value);
    },
    setRate: function(value) {
        this.audioplayer.setRate(value);
    },
    getVolume: function() {
        return this.audioplayer.getVolume();
    },
    getRate: function() {
        return this.audioplayer.getRate();
    },
    reset: function() {
        this.set("current_text_src", null);
        this.set("has_started_playback", false);
    },
    setConsoleTrace: function(onOff) {
        this.consoleTrace = onOff;
    },
    debugPrint: function(str) {
        if (this.consoleTrace) {
            console.log("MediaOverlay: " + str);
        }
    }
});
Readium.Models.AudioClipPlayer = function() {
    
    // clip info
    var src = null;
    var clipBegin = null;
    var clipEnd = null;
    
    // force the clip to reset its start time
    var forceReset = false;
    
    // the html audio element created to hold whatever the current file is
    var elm = new Audio();
    
    // callback function
    var notifyClipDone = null;
    
    // send debug statements to the console
    var consoleTrace = false;
    
    // ID of the setInterval timer
    var intervalId = null;
    
    // current rate; default is normal speed
    var rate = 1.0;
    
    this.setNotifyClipDone = function(notifyClipDoneFn) {
        notifyClipDone = notifyClipDoneFn;
    };
    this.setConsoleTrace =  function(isOn) {
        consoleTrace = isOn;
    };
    
    // clipBeginTime and clipEndTime are in seconds
    // filesrc is an absolute path, local or remote
    this.play = function(filesrc, clipBeginTime, clipEndTime, shouldForceReset) {
        src = filesrc;
        clipBegin = clipBeginTime;
        clipEnd = clipEndTime;
        forceReset = shouldForceReset;
        
        debugPrint("playing " + src + " from " + clipBegin + " to " + clipEnd);
        
        // make sure we haven't already created an element for this audio file
        if (elm == null || elm.getAttribute("src") != src) {
            loadData();
        }
        // the element is already loaded; just need to continue playing at the right point
        else {
            elm.playbackRate = rate;
            continueRender();
        }
    };
    
    this.isPlaying = function() {
        if (elm == null) {
            return false;
        }
        return !elm.paused;
    };
    
    this.resume = function() {
        if (elm != null) {
            elm.play();
        }
    };
    
    this.pause = function() {
        if (elm != null) {
            elm.pause();
        }
    };
    
    this.setNotifyOnPause = function(notifyOnPause) {
        elm.addEventListener("pause", function() {
            notifyOnPause();
        });
    };
    
    this.setNotifyOnPlay = function(notifyOnPlay) {
        elm.addEventListener("play", function() {
            notifyOnPlay();
        });
    };
    
    this.getCurrentTime = function() {
        if (elm != null) {
            return elm.currentTime;
        }
        return 0;
    };
    this.getCurrentSrc = function() {
        return src;
    };
    // volume ranges from 0 to 1.0
    this.setVolume = function(value) {
        if (value < 0) {
            elm.volume = 0;
        }
        else if (value > 1) {
            elm.volume = 1;
        }
        else {
            elm.volume = value;
        }
    };
    // reasonable rate values are from 0.5 (slow) to 2.5 (fast),
    // though no restrictions are hardcoded here
    this.setRate = function(value) {
        if (this.isPlaying()) {
            elm.playbackRate = value;
        }
        rate = value;  
    };
    this.getVolume = function() {
        return elm.volume;  
    };
    this.getRate = function() {
        return rate;
    };
    function loadData(){
        debugPrint("Loading file " + src);
        elm.setAttribute("src", src);
        
        // wait for 'canplay' before continuing
        elm.addEventListener("canplay", setThisTime);
        function setThisTime() {
            elm.removeEventListener("canplay", setThisTime);
            // TODO put something in here for remote files to make sure the file is buffered
        
            if (clipEnd > elm.duration) {
                debugPrint("File is shorter than specified clipEnd time");
                clipEnd = elm.duration;
            }
            debugPrint("Audio data loaded");
            elm.playbackRate = rate;
            continueRender();        
        }
        
        elm.addEventListener("ended", function() {
            // cancel the timer, if any
            if (intervalId != null) {
                clearInterval(intervalId);
            }
            if (notifyClipDone != null) {
                notifyClipDone();
            }
        });
    }
    
    function continueRender() {
        
        // if the current time is already somewhere within the clip that we want to play, then just let it keep playing
        if (forceReset == false && elm.currentTime > clipBegin && elm.currentTime < clipEnd) {
            startClipTimer();
            elm.play();    
        }
        else {
            elm.addEventListener("seeked", seeked);
            debugPrint("setting currentTime from " + elm.currentTime + "to " + clipBegin);
            elm.currentTime = clipBegin;
            function seeked() {
                elm.removeEventListener("seeked", seeked);
                startClipTimer();
                elm.play();
            }
        }
    }
    
    function startClipTimer() {
        
        // cancel the old timer, if any
        if (intervalId != null) {
            clearInterval(intervalId);
        }
        
        // we're using setInterval instead of monitoring the timeupdate event because timeupdate fires, at best, every 200ms, which messes up playback of short phrases.
        // 11ms seems to be chrome's finest allowed granularity for setInterval (and this is for when the tab is active; otherwise it fires about every second)
        intervalId = setInterval(function() {
            if (elm.currentTime >= clipEnd) {
                clearInterval(intervalId);
                debugPrint("clip done");
                if (notifyClipDone != null) {
                    notifyClipDone();
                }
            }
        }, 11);   
    }
    
    function debugPrint(str) {
        if (consoleTrace) {
            console.log("AudioClipPlayer: " + str);
        }
    }
};

// Description: Chooses a pagination strategy

// REFACTORING CANDIDATE: There is an issue here that is a bit hidden. Having this pagination strategy model attached to the 
//   epub makes sense in that each spine item within an epub can be either reflowable or fixed. As such, when navigating through
//   the epub, a decisions as to the type of pagination view must be made dynamically. However, at the moment, while it appears that
//   this is how the pagination strategy is set up, in actual fact, an entire fixed layout epub is rendered based on the type of spine item
//   found at the current spine_position. Since all the other spine items are then rendered assuming they are also fixed layout, the 
//   pagination strategy is never called again when navigating to the other (possibly reflowable) spine items. This will have to be addressed
//   at some point. 

Readium.Models.PaginationStrategySelector = Backbone.Model.extend({

	renderToLastPage: false,

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //	

	initialize: function() {

		this.model = this.get("book");
		this.zoomer = new Readium.Views.FixedLayoutBookZoomer();
	},

	// Description: Determine what the current spine item is and render it
	//   Updates which spine items have been rendered in an array of rendered spine items
	renderSpineItems: function(renderToLast, hashFragmentId) {
		var book = this.model;
		var that = this;
		var rendered_spine_positions = [];

		// clean up the old view if there is one
		if (this.v) {
			this.v.destruct();
		}

		// Spine items as found in the package document can have attributes that override global settings for the ebook. This 
		// requires checking/creating the correct pagination strategy for each spine item
		var spineItem = book.getCurrentSection();
		if (spineItem.isFixedLayout()) {

			this.v = new Readium.Views.FixedPaginationView({model: book, zoomer: this.zoomer});
		}
		// A scrolling epub
		else if (this.shouldScroll()) {

				this.v = new Readium.Views.ScrollingPaginationView({model: book, zoomer: this.zoomer});
		}
		// A reflowable epub
		else {

			this.v = new Readium.Views.ReflowablePaginationView({model: book, zoomer: this.zoomer});
		}

		this.rendered_spine_positions = this.v.render(!!renderToLast, hashFragmentId);
		return this.rendered_spine_positions;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //  

	shouldScroll: function() {
		var optionString = localStorage["READIUM_OPTIONS"];
		var options = (optionString && JSON.parse(optionString) ) || {"singleton": {}};
		return !options["singleton"]["paginate_everything"];
	}
});
Readium.Models.Trigger = function(domNode) {
	var $el = $(domNode);
	this.action 	= $el.attr("action");
	this.ref 		= $el.attr("ref");
	this.event 		= $el.attr("ev:event");
	this.observer 	= $el.attr("ev:observer");
	this.ref 		= $el.attr("ref");
};

Readium.Models.Trigger.prototype.subscribe = function(dom) {
	var selector = "#" + this.observer;
	var that = this;
	$(selector, dom).on(this.event, function() {
		that.execute(dom);
	});
};

Readium.Models.Trigger.prototype.execute = function(dom) {
	var $target = $( "#" + this.ref, dom);
	switch(this.action)
	{
	case "show":
	  $target.css("visibility", "visible");
	  break;
	case "hide":
	  $target.css("visibility", "hidden");
	  break;
	case "play":
	  $target[0].currentTime = 0;
	  $target[0].play();
	  break;
	case "pause":
	  $target[0].pause();
	  break;
	case "resume":
	  $target[0].play();
	  break;
	case "mute":
	  $target[0].muted = true;
	  break;
	case "unmute":
	  $target[0].muted = false;
	  break;
	default:
	  console.log("do not no how to handle trigger " + this.action);
	}
};
// Description: The base model for the set of different pagination view strategies: Reflowable, fixed layout and scrolling
// Rationale: The intention behind this model is to provide implementations for behaviour common to all the pagination 
//   strategies. 
// Notes: This model has a reference to the model for the epub currently being rendered, as well as a "pages" object that
//   contains data and behaviour related to the current set of rendered "pages."

Readium.Views.PaginationViewBase = Backbone.View.extend({

	// Description: All strategies are linked to the same dom element
	el: "#readium-book-view-el",

	/* ------------------------------------------------------------------------------------ */
	//  "PUBLIC" METHODS (THE API)                                                          //
	/* ------------------------------------------------------------------------------------ */

	initialize: function(options) {
		this.zoomer = options.zoomer;
		this.pages = new Readium.Models.ReadiumPagination({model : this.model});
		this.mediaOverlayController = this.model.get("media_overlay_controller");
        this.mediaOverlayController.setPages(this.pages);
        this.mediaOverlayController.setView(this);

		this.pages.on("change:current_page", this.showCurrentPages, this);

		this.model.on("change:font_size", this.setFontSize, this);
		this.model.on("change:two_up", this.pages.toggleTwoUp, this.pages);
        
        this.mediaOverlayController.on("change:mo_text_id", this.highlightText, this);
        this.mediaOverlayController.on("change:active_mo", this.indicateMoIsPlaying, this);
        
		this.bindingTemplate = Handlebars.templates.binding_template;
	},

    iframeLoadCallback: function(e) {
		
		this.applyBindings( $(e.srcElement).contents() );
		this.applySwitches( $(e.srcElement).contents() );
		this.addSwipeHandlers( $(e.srcElement).contents() );
        this.injectMathJax(e.srcElement);
        this.injectLinkHandler(e.srcElement);
        var trigs = this.parseTriggers(e.srcElement.contentDocument);
		this.applyTriggers(e.srcElement.contentDocument, trigs);
        this.mediaOverlayController.pagesLoaded();
	},
	
    // Description: Activates a style set for the ePub, based on the currently selected theme. At present, 
    //   only the day-night alternate tags are available as an option. 
	activateEPubStyle: function(bookDom) {

	    var selector;
		
		// Apply night theme for the book; nothing will be applied if the ePub's style sheets do not contain a style
		// set with the 'night' tag
	    if (this.model.get("current_theme") === "night-theme") {

	    	selector = new Readium.Models.AlternateStyleTagSelector;
	    	bookDom = selector.activateAlternateStyleSet(["night"], bookDom);

	    }
	    else {

			selector = new Readium.Models.AlternateStyleTagSelector;
	    	bookDom = selector.activateAlternateStyleSet([""], bookDom);
	    }
	},

	// REFACTORING CANDIDATE: This method could use a better name. The purpose of this method is to make one or two 
	//   pages of an epub visible. "setUpMode" seems non-specific. 
	// Description: Changes the html to make either 1 or 2 pages visible in their iframes
	setUpMode: function() {
		var two_up = this.model.get("two_up");
		this.$el.toggleClass("two-up", two_up);
		this.$('#spine-divider').toggle(two_up);
	},

	// Description: Iterates through the list of rendered pages and displays those that 
	//   should be visible in the viewer.
	showCurrentPages: function() {
		var that = this;
		var two_up = this.model.get("two_up");
		this.$(".page-wrap").each(function(index) {
			if(!two_up) { 
				index += 1;
			}
			$(this).toggleClass("hidden-page", !that.pages.isPageVisible(index));
		});
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Sometimes views hang around in memory before
	//   the GC gets them. we need to remove all of the handlers
	//   that were registered on the model
	destruct: function() {
		this.pages.off("change:current_page", this.showCurrentPages);
		this.model.off("change:font_size", this.setFontSize);
        this.mediaOverlayController.off("change:mo_text_id", this.highlightText);
        this.mediaOverlayController.off("change:active_mo", this.indicateMoIsPlaying);
		this.resetEl();
	},

	getBindings: function() {
		var packDoc = this.model.epub.getPackageDocument();
		var bindings = packDoc.get('bindings');
		return bindings.map(function(binding) {
			binding.selector = 'object[type="' + binding.media_type + '"]';
			binding.url = packDoc.getManifestItemById(binding.handler).get('href');
			binding.url = packDoc.resolveUri(binding.url);
			return binding;
		})
	},

	applyBindings: function(dom) {
		var that = this;
		var bindings = this.getBindings();
		var i = 0;
		for(var i = 0; i < bindings.length; i++) {
			$(bindings[i].selector, dom).each(function() {
				var params = [];
				var $el = $(this);
				var data = $el.attr('data');
				var url;
				params.push("src=" + that.model.packageDocument.resolveUri(data));
				params.push('type=' + bindings[i].media_type);
				url = bindings[i].url + "?" + params.join('&');
				var content = $(that.bindingTemplate({}));
				// must set src attr separately
				content.attr('src', url);
				$el.html(content);
			});
		}
	},

	applyTriggers: function(dom, triggers) {
		for(var i = 0 ; i < triggers.length; i++) {
			triggers[i].subscribe(dom);
		}
	},

	// Description: For reflowable content we only add what is in the body tag.
	// Lots of times the triggers are in the head of the dom
	parseTriggers: function(dom) {
		var triggers = [];
		$('trigger', dom).each(function() {
			

			triggers.push(new Readium.Models.Trigger(this) );
		});
		
		return triggers;
	},	

	// Description: Parse the epub "switch" tags and hide
	// cases that are not supported
	applySwitches: function(dom) {

		// helper method, returns true if a given case node
		// is supported, false otherwise
		var isSupported = function(caseNode) {

			var ns = caseNode.attributes["required-namespace"];
			if(!ns) {
				// the namespace was not specified, that should
				// never happen, we don't support it then
				console.log("Encountered a case statement with no required-namespace");
				return false;
			}
			// all the xmlns's that readium is known to support
			// TODO this is going to require maintanence
			var supportedNamespaces = ["http://www.w3.org/1998/Math/MathML"];
			return _.include(supportedNamespaces, ns);
		};

		$('switch', dom).each(function(ind) {
			
			// keep track of whether or now we found one
			var found = false;

			$('case', this).each(function() {

				if( !found && isSupported(this) ) {
					found = true; // we found the node, don't remove it
				}
				else {
					$(this).remove(); // remove the node from the dom
				}
			});

			if(found) {
				// if we found a supported case, remove the default
				$('default', this).remove();
			}
		})
	},

	addSwipeHandlers: function(dom) {
		var that = this;
		$(dom).on("swipeleft", function(e) {
			e.preventDefault();
			that.pages.goRight();
			
		});

		$(dom).on("swiperight", function(e) {
			e.preventDefault();
			that.pages.goLeft();
		});
	},

	// inject mathML parsing code into an iframe
    injectMathJax: function (iframe) {
    	var doc, script, head;
		doc = iframe.contentDocument;
		head = doc.getElementsByTagName("head")[0];
		// if the content doc is SVG there is no head, and thus
		// mathjax will not be required
		if(head) {
			script = doc.createElement("script");
			script.type = "text/javascript";
			script.src = MathJax.Hub.config.root+"/MathJax.js?config=readium-iframe";
			head.appendChild(script);
		}
    },

    injectLinkHandler: function(iframe) {
    	var that = this;
    	$('a', iframe.contentDocument).click(function(e) {
    		that.linkClickHandler(e)
    	});
    },

    resetEl: function() {
    	$('body').removeClass("apple-fixed-layout");
    	$("#readium-book-view-el").attr("style", "");
		this.$el.toggleClass("two-up", false);
		this.$('#spine-divider').toggle(false);
		this.zoomer.reset();

    	$('#page-wrap').css({
    		"position": "relative",
    		"right": "0px", 
    		"top": "0px",
    		"-webkit-transform": "scale(1.0) translate(0px, 0px)"
    	});
    }
});


Readium.Views.FixedPaginationView = Readium.Views.PaginationViewBase.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {

		// call the super ctor
		Readium.Views.PaginationViewBase.prototype.initialize.call(this, options);

		var spinePos = this.model.get("spine_position");
		this.model.on("FXL_goToPage", this.spinePositionChangeHandler, this);
		this.model.on("change:two_up", this.setUpMode, this);
		this.model.on("change:meta_size", this.setContainerSize, this);
	},

	render: function() {

		$('body').addClass('apple-fixed-layout');

		// wipe the html
		this.$('#container').html("");
		this.setContainerSize();
		this.setUpMode();

		var that = this;
		var pageNum = 1; // start from page 1
		var offset = this.findPrerenderStart();
		var rendered_spine_positions = [];
		var spine_position = this.model.get("spine_position");

		// Gets each page of the current pub and injects it into the page 
		// keeping track of what has been pre-rendered
		while ( this.shouldPreRender( this.model.getCurrentSection(offset) ) ) {

			this.addPage(this.model.getCurrentSection(offset), pageNum);
			rendered_spine_positions.push(spine_position + offset);
			pageNum += 1;
			offset += 1;
		}

		// set the page we should be on
		var page = rendered_spine_positions.indexOf(spine_position) + 1;
		this.pages.set("num_pages", pageNum - 1);
		this.pages.goToPage(page);

		setTimeout(function() {
			that.setContainerSize();
		}, 15);

		this.showCurrentPages();

		return rendered_spine_positions;
	},

	// get the body element for a page number
    getPageBody: function(pageNum) {
        var pageElm = $("#page-" + pageNum.toString() +" iframe");
        if (pageElm.length > 0) {
            pageElm = pageElm.contents()[0].documentElement;
            return $(pageElm).find("body")
        }
        else {
            return null;
        }
    },
    
    // override
	indicateMoIsPlaying: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
		moHelper.renderFixedMoPlaying(
			this.pages.get("current_page"),
			this.mediaOverlayController.get("active_mo"),
			this
        );
	},
    
    // override
	highlightText: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
		moHelper.renderFixedLayoutMoFragHighlight(
			this.pages.get("current_page"),
			this.mediaOverlayController.get("mo_text_id"),
			this
        );
	},
    
	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// sometimes these views hang around in memory before
	// the GC's get them. we need to remove all of the handlers
	// that were registered on the model
	destruct: function() {

		// call the super constructor
		Readium.Views.PaginationViewBase.prototype.destruct.call(this);

		// remove any listeners registered on the model
		this.model.off("change:two_up", this.setUpMode);
		this.model.off("change:meta_size", this.setUpMode);		
	},

	// Description: Handles clicks of anchor tags by navigating to
	// the proper location in the epub spine, or opening
	// a new window for external links
	linkClickHandler: function(e) {
		e.preventDefault();

		var href;

		// Check for both href and xlink:href attribute and get value
		if (e.currentTarget.attributes["xlink:href"]) {

			href = e.currentTarget.attributes["xlink:href"].value;
		}
		else {

			href = e.currentTarget.attributes["href"].value;
		}

		// Resolve the relative path for the resource
		href = this.resolveRelativeURI(href);

		if (href.match(/^http(s)?:/)) {
			window.open(href);
		} 
		else {
			this.model.goToHref(href);
		}
	},

	// Rationale: For the purpose of looking up EPUB resources in the package document manifest, Readium expects that 
	//   all relative links be specified as relative to the package document URI (or absolute references). However, it is 
	//   valid XHTML for a link to another resource in the EPUB to be specfied relative to the current document's
	//   path, rather than to the package document. As such, URIs passed to Readium must be either absolute references or 
	//   relative to the package document. This method resolves URIs to conform to this condition. 
	resolveRelativeURI: function (rel_uri) {

		var sourceDocManifestHref;
		var sourceDocName;
		var pageSrc;

		// Get the name of the click source document
		sourceDocManifestHref = this.model.getCurrentSection().get("href");
		indexOfFilenameStart = sourceDocManifestHref.lastIndexOf('/') + 1;
		sourceDocName = sourceDocManifestHref.substr(indexOfFilenameStart, rel_uri.length);

		// Iterate through list of FXL pages. Look for the one that is visible and has the name
		$(".fixed-page-wrap").each(function () {

			var $currPage = $('.content-sandbox', this);

			// Get the name of the content document in the page iframe
			var currPageSrc = $currPage.attr("src");
			var pageDocNameStart = currPageSrc.lastIndexOf('/') + 1;
			var pageDocName = currPageSrc.substr(pageDocNameStart, currPageSrc.length);

			if (pageDocName === sourceDocName) {
				pageSrc = currPageSrc;
				return false;
			}
		});

		var relativeURI = new URI(rel_uri);

		// Get URI for resource currently loaded in the view's iframe
		var iframeDocURI = new URI(pageSrc);

		return relativeURI.resolve(iframeDocURI).toString();
	},

	spinePositionChangeHandler: function () {

		var pageNumber = this.model.get("spine_position") + 1;
		this.pages.goToPage(pageNumber);
	},

	// Description: Creates/gets an iFrame which contains a page view to represent a spine item and appends it to an 
	//   element that contains the content of the current ePub. Each of these spine item iframes is not necessarily displayed
	//   immediately. 
	addPage: function(spineItem, pageNum) {

		var that = this;
		var view = spineItem.getPageView();

		view.on("iframe_loaded", function() {
			this.iframeLoadCallback({srcElement: view.iframe()});
			that.applyKeydownHandler($(view.iframe()));
		}, this);

		var content = spineItem.getPageView().render().el;
		$(content).attr("id", "page-" + pageNum.toString());
		this.$('#container').append(content);

		this.showCurrentPages();

		return this;
	},

	setContainerSize: function() {
		
		var meta = this.model.get("meta_size");

		if (meta) {

			this.$el.width(meta.width * 2);
			this.$el.height(meta.height);
			this.zoomer.fitToBest();

			if (!this.zoomed) {

				this.zoomed = true;
				// setTimeout(function() {
				// 	$('#page-wrap').zoomAndScale(); //<= this was a little buggy last I checked but it is a super cool feature
				// }, 1)	
			}
		}
	},	

	findPrerenderStart: function() {
		
		var i = 0;
		while ( this.shouldPreRender( this.model.getCurrentSection(i) ) ) {
			i -= 1;
		}

		return i + 1; // sloppy fix for an off by one error
	},

	// Description: A spine item should pre-render if it is not undefined and should render as a fixed item
	shouldPreRender: function(spineItem) {
		return spineItem && spineItem.isFixedLayout(); 
	},

	// Description: For each fixed-page-wrap(per), if it is one of the current pages, toggle it as visible. If it is not
	//   toggle it as invisible.
	// Note: current_page is an array containing the page numbers (as of 25June2012, a maximum of two pages) of the 
	//   currently visible pages
	showCurrentPages: function() {
		var that = this;
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});

		this.$(".fixed-page-wrap").each(function(index) {
			$(this).toggle(that.pages.isPageVisible(index + 1));
		});

		// remove any artifact of MO highlighting from the current page(s)
        $.each(this.pages.get("current_page"), function(idx) {
            moHelper.removeActiveClass(that.getPageBody(this.toString()));
        });
	},

	setFontSize: function() {
		var size = this.model.get("font_size") / 10;
		$('#readium-content-container').css("font-size", size + "em");
		this.showCurrentPages();
	},

	applyKeydownHandler : function ($pageViewContainer) {

		var that = this;

		$pageViewContainer.contents().keydown(function (e) {

			if (e.which == 39) {
				that.model.paginator.v.pages.goRight();
			}
							
			if (e.which == 37) {
				that.model.paginator.v.pages.goLeft();
			}
		});
	}
});


Readium.Views.FixedPageView = Backbone.View.extend({

	className: "fixed-page-wrap",

	initialize: function() {
		this.template = Handlebars.templates.fixed_page_template;
		this.model.on("change", this.render, this);
	},

	destruct: function() {
		this.model.off("change", this.render);
	},

	render: function() {
		var that = this;
		var json = this.model.toJSON();
		this.$el.html( this.template( json ) );
		this.$el.addClass( this.model.getPageSpreadClass() );
		this.$('.content-sandbox').on("load", function() {
			that.trigger("iframe_loaded");
		});
		return this;
	},

	iframe: function() {
		return this.$('.content-sandbox')[0];
	}
});


Readium.Views.ImagePageView = Backbone.View.extend({

	className: "fixed-page-wrap",

	initialize: function() {
		this.template = Handlebars.templates.image_page_template;
		this.model.on("change", this.render, this);
	},

	render: function() {
		var that = this;
		var json = this.model.toJSON();
		this.$el.html( this.template( json ) );
		this.$el.addClass( this.model.getPageSpreadClass() );

		this.$('img').on("load", function() { that.setSize(); });
		

		return this;
	},

	setSize: function() {
		var $img = this.$('img');
		var width = $img.width();
		var height = $img.height();
		// temp this is a mess but it will do for now...
		if( width > 0) {
			this.model.set({meta_width: width, meta_height: height})
		}
		
	}

});

Readium.Views.ReflowablePaginationView = Readium.Views.PaginationViewBase.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {

		var that = this;

		// call the super ctor
		Readium.Views.PaginationViewBase.prototype.initialize.call(this, options);
		this.page_template = Handlebars.templates.reflowing_template;

		// make sure we have proper vendor prefixed props for when we need them
		this.stashModernizrPrefixedProps();

		// if this book does right to left pagination we need to set the
		// offset on the right
		if(this.model.epub.get("page_prog_dir") === "rtl") {
			this.offset_dir = "right";
		}
		else {
			this.offset_dir = "left";
		}

		this.pages.on("change:current_page", this.pageChangeHandler, this);
		this.model.on("change:toc_visible", this.windowSizeChangeHandler, this);
		this.model.on("repagination_event", this.windowSizeChangeHandler, this);
		this.model.on("change:current_theme", this.injectTheme, this);
		this.model.on("change:two_up", this.setUpMode, this);
		this.model.on("change:two_up", this.adjustIframeColumns, this);
		this.model.on("change:current_margin", this.marginCallback, this);
		this.model.on("save_position", this.savePosition, this);
	},

	render: function(goToLastPage, hashFragmentId) {
		var that = this;
		var json = this.model.getCurrentSection().toJSON();

		// make everything invisible to prevent flicker
		this.setUpMode();
		this.$('#container').html( this.page_template(json) );
		
		this.$('#readium-flowing-content').on("load", function(e) {

			var lastPageElementId = that.injectCFIElements();
			that.adjustIframeColumns();
			that.iframeLoadCallback(e);
			that.setFontSize();
			that.injectTheme();
			that.setNumPages();
			that.applyKeydownHandler();

			// Rationale: The assumption here is that if a hash fragment is specified, it is the result of Readium 
			//   following a clicked linked, either an internal link, or a link from the table of contents. The intention
			//   to follow a link should supersede restoring the last-page position, as this should only be done for the 
			//   case where Readium is re-opening the book, from the library view. 
			if (hashFragmentId) {

				that.goToHashFragment(hashFragmentId);
			}
			else if (lastPageElementId) {

				that.goToHashFragment(lastPageElementId);
			}
			else {

				if (goToLastPage) {

					that.pages.goToLastPage();
				}
				else {

					that.pages.goToPage(1);
				}		
			}
		});
		
		return [this.model.get("spine_position")];
	},

    findVisiblePageElements: function() {

        var $elements = $(this.getBody()).find("[id]");
        var doc = $("#readium-flowing-content").contents()[0].documentElement;
        var doc_top = 0;
        var doc_left = 0;
        var doc_right = doc_left + $(doc).width();
        var doc_bottom = doc_top + $(doc).height();
        
        var visibleElms = this.filterElementsByPosition($elements, doc_top, doc_bottom, doc_left, doc_right);
            
        return visibleElms;
    },
    
    // override
	indicateMoIsPlaying: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
		moHelper.renderReflowableMoPlaying(
			this.model.get("current_theme"),
			this.mediaOverlayController.get("active_mo"),
			this
		);
	},

    // override
	highlightText: function () {
		var moHelper = new Readium.Models.MediaOverlayViewHelper({epubController : this.model});
		moHelper.renderReflowableMoFragHighlight(
			this.model.get("current_theme"),
			this,
			this.mediaOverlayController.get("mo_text_id")
		);
	},
    
	// Description: navigate to a url hash fragment by calculating the page of
	//   the corresponding elem and setting the page number on `this.model`
	//   as precondition the hash fragment should identify an element in the
	//   section rendered by this view
	goToHashFragment: function(hashFragmentId) {

		// this method is triggered in response to 
		var fragment = hashFragmentId;
		if(fragment) {
			var el = $("#" + fragment, this.getBody())[0];

			if(!el) {
				// couldn't find the el. just give up
                return;
			}

			// we get more precise results if we look at the first children
			while (el.children.length > 0) {
				el = el.children[0];
			}

			var page = this.getElemPageNumber(el);
            if (page > 0) {
                this.pages.goToPage(page);	
			}
		}
		// else false alarm no work to do
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Sometimes these views hang around in memory before
	//   the GC's get them. we need to remove all of the handlers
	//   that were registered on the model
	destruct: function() {
		
		this.pages.off("change:current_page", this.pageChangeHandler);
		this.model.off("change:toc_visible", this.windowSizeChangeHandler);
		this.model.off("repagination_event", this.windowSizeChangeHandler);
		this.model.off("change:current_theme", this.windowSizeChangeHandler);
		this.model.off("change:two_up", this.setUpMode);
		this.model.off("change:two_up", this.adjustIframeColumns);
		this.model.off("change:current_margin", this.marginCallback);
		// call the super destructor
		Readium.Views.PaginationViewBase.prototype.destruct.call(this);
	},

	// TODO: Extend this to be correct for right-to-left pagination
	findVisibleTextNode: function () {

        var documentLeft = 0;
        var documentRight;
        var columnGap;
        var columnWidth;
        var doc;
        var $elements;
        var $firstVisibleTextNode;

		// Rationale: The intention here is to get a list of all the text nodes in the document, after which we'll
		//   reduce this to the subset of text nodes that is visible on the page. We'll then select one text node
		//   for which we can create a character offset CFI. This CFI will then refer to a "last position" in the 
		//   EPUB, which can be used if the reader re-opens the EPUB.
		// REFACTORING CANDIDATE: The "audiError" check is a total hack to solve a problem for a particular epub. This 
		//   issue needs to be addressed.
		$elements = $("body", this.getBody()).find(":not(iframe)").contents().filter(function () {
			if (this.nodeType === 3 && !$(this).parent().hasClass("audiError")) {
				return true;
			} else {
				return false;
			}
		});

        doc = $("#readium-flowing-content").contents()[0].documentElement;

        if (this.model.get("two_up")) {
        	columnGap = parseInt($(doc).css("-webkit-column-gap").replace("px",""));
        	columnWidth = parseInt($(doc).css("-webkit-column-width").replace("px",""));
        	documentRight = documentLeft + columnGap + (columnWidth * 2);
        } 
        else {
        	documentRight = documentLeft + $(doc).width();
        }

        // Find the first visible text node 
        $.each($elements, function() {

        	var POSITION_ERROR_MARGIN = 5;
        	var $textNodeParent = $(this).parent();
        	var elementLeft = $textNodeParent.position().left;
        	var elementRight = elementLeft + $textNodeParent.width();
        	var nodeText;

        	// Correct for minor right and left position errors
        	elementLeft = Math.abs(elementLeft) < POSITION_ERROR_MARGIN ? 0 : elementLeft;
        	elementRight = Math.abs(elementRight - documentRight) < POSITION_ERROR_MARGIN ? documentRight : elementRight;

        	// Heuristic to find a text node with actual text
        	nodeText = this.nodeValue.replace(/\n/g, "");
        	nodeText = nodeText.replace(/ /g, "");

        	if (elementLeft <= documentRight 
        		&& elementRight >= documentLeft
        		&& nodeText.length > 10) { // 10 is so the text node is actually a text node with writing

        		$firstVisibleTextNode = $(this);

        		// Break the loop
        		return false;
        	}
        });

        return $firstVisibleTextNode;
	},

	// Currently for left-to-right pagination only
	findVisibleCharacterOffset : function($textNode) {

		var $parentNode;
		var elementTop;
		var elementBottom;
		var POSITION_ERROR_MARGIN = 5;
		var $document;
		var documentTop;
		var documentBottom;
		var percentOfTextOffPage;
		var characterOffset;

		// Get parent
		$parentNode = $textNode.parent();

		// get document
		$document = $($("#readium-flowing-content").contents()[0].documentElement);

		// Find percentage of visible node on page
		documentTop = $document.position().top;
		documentBottom = documentTop + $document.height();

		elementTop = $parentNode.offset().top;
		elementBottom = elementTop + $parentNode.height();

		// Element overlaps top
		if (elementTop < documentTop) {

			percentOfTextOffPage = Math.abs(elementTop - documentTop) / $parentNode.height();
			characterOffsetByPercent = Math.ceil(percentOfTextOffPage * $textNode[0].length);
			characterOffset = Math.ceil(0.5 * ($textNode[0].length - characterOffsetByPercent)) + characterOffsetByPercent;
		}
		else if (elementTop >= documentTop && elementTop <= documentBottom) {
			characterOffset = 1;
		}
		else if (elementTop < documentBottom) {
			characterOffset = 1;
		}

		return characterOffset;
	},

	// returns all the elements in the set that are inside the box
    // separated this function from the one above in order to debug it
    filterElementsByPosition: function($elements, documentTop, documentBottom, documentLeft, documentRight) {
        
        var $visibleElms = $elements.filter(function(idx) {
            var elm_top = $(this).offset().top;
            var elm_left = $(this).offset().left;
            var elm_right = elm_left + $(this).width();
            var elm_bottom = elm_top + $(this).height();
            
            var is_ok_x = elm_left >= documentLeft && elm_right <= documentRight;
            var is_ok_y = elm_top >= documentTop && elm_bottom <= documentBottom;
            
            return is_ok_x && is_ok_y;
        });  

        return $visibleElms;
    },

	// Description: Handles clicks of anchor tags by navigating to
	//   the proper location in the epub spine, or opening
	//   a new window for external links
	linkClickHandler: function (e) {
		e.preventDefault();

		var href;

		// Check for both href and xlink:href attribute and get value
		if (e.currentTarget.attributes["xlink:href"]) {
			href = e.currentTarget.attributes["xlink:href"].value;
		}
		else {
			href = e.currentTarget.attributes["href"].value;
		}

		// Resolve the relative path for the requested resource.
		href = this.resolveRelativeURI(href);
		if (href.match(/^http(s)?:/)) {
			window.open(href);
		} 
		else {
			this.model.goToHref(href);
		}
	},

	// Rationale: For the purpose of looking up EPUB resources in the package document manifest, Readium expects that 
	//   all relative links be specified as relative to the package document URI (or absolute references). However, it is 
	//   valid XHTML for a link to another resource in the EPUB to be specfied relative to the current document's
	//   path, rather than to the package document. As such, URIs passed to Readium must be either absolute references or 
	//   relative to the package document. This method resolves URIs to conform to this condition. 
	resolveRelativeURI: function (rel_uri) {
		var relativeURI = new URI(rel_uri);

		// Get URI for resource currently loaded in the view's iframe
		var iframeDocURI = new URI($("#readium-flowing-content").attr("src"));

		return relativeURI.resolve(iframeDocURI).toString();
	},

	applyKeydownHandler : function () {

		var that = this;

		this.$("#readium-flowing-content").contents().keydown(function (e) {

			if (e.which == 39) {
				that.model.paginator.v.pages.goRight();
			}
							
			if (e.which == 37) {
				that.model.paginator.v.pages.goLeft();
			}
		});
	},

	// REFACTORING CANDIDATE: I think this is actually part of the public interface
	goToPage: function(page) {
        // check to make sure we're not already on that page
        if (this.model.get("current_page") != undefined && this.model.get("current_page").indexOf(page) != -1) {
            return;
        }
		var offset = this.calcPageOffset(page).toString() + "px";
		$(this.getBody()).css(this.offset_dir, "-" + offset);
		this.showContent();
        
        if (this.model.get("two_up") == false || 
            (this.model.get("two_up") && page % 2 === 1)) {
                // when we change the page, we have to tell MO to update its position
                this.mediaOverlayController.reflowPageChanged();
        }
	},

	setFontSize: function() {
		var size = this.model.get("font_size") / 10;
		$(this.getBody()).css("font-size", size + "em");

		// the content size has changed so recalc the number of 
		// pages
		this.setNumPages();
	},

	// Description: we are using experimental styles so we need to 
	//   use modernizr to generate prefixes
	stashModernizrPrefixedProps: function() {
		var cssIfy = function(str) {
			return str.replace(/([A-Z])/g, function(str,m1){ 
				return '-' + m1.toLowerCase(); 
			}).replace(/^ms-/,'-ms-');
		};

		// ask modernizr for the vendor prefixed version
		this.columAxis =  Modernizr.prefixed('columnAxis') || 'columnAxis';
		this.columGap =  Modernizr.prefixed('columnGap') || 'columnGap';
		this.columWidth =  Modernizr.prefixed('columnWidth') || 'columnWidth';

		// we are interested in the css prefixed version
		this.cssColumAxis =  cssIfy(this.columAxis);
		this.cssColumGap =  cssIfy(this.columGap);
		this.cssColumWidth =  cssIfy(this.columWidth);
	},

	getBodyColumnCss: function() {
		var css = {};
		css[this.cssColumAxis] = "horizontal";
		css[this.cssColumGap] = this.gap_width.toString() + "px";
		css[this.cssColumWidth] = this.page_width.toString() + "px";
		css["padding"] = "0px";
		css["margin"] = "0px";
		css["position"] = "absolute";
		css["width"] = this.page_width.toString() + "px";
		css["height"] = this.frame_height.toString() + "px";
		return css;
	},

	injectCFIElements : function () {

		var that = this;
		var contentDocument;
		var epubCFIs;
		var lastPageElementId;

		// Get the content document (assumes a reflowable publication)
		contentDocument = $("#readium-flowing-content").contents()[0];

		// TODO: Could check to make sure the document returned from the iframe has the same name as the 
		//   content document specified by the href returned by the CFI.

		// Inject elements for all the CFIs that reference this content document
		epubCFIs = this.model.get("epubCFIs");
		_.each(epubCFIs, function (cfi, key) {

			if (cfi.contentDocSpinePos === that.model.get("spine_position")) {

				try {
					
					EPUBcfi.Interpreter.injectElement(
						key, 
						contentDocument, 
						cfi.payload,
						["cfi-marker", "audiError"],
	  					[],
	  					["MathJax_Message"]);

					if (cfi.type === "last-page") {
						lastPageElementId = $(cfi.payload).attr("id");
					}
				} 
				catch (e) {

					console.log("Could not inject CFI");
				}
			}
		});

		// This will be undefined unless there is a "last-page" element injected into the page
		return lastPageElementId;
	},

	// Save position in epub
	savePosition : function () {

		var $visibleTextNode;
		var existingCFI;
		var lastPageMarkerExists = false;
		var characterOffset;
		var contentDocumentIdref;
		var packageDocument;
		var generatedCFI;

		// Get first visible element with a text node 
		$visibleTextNode = this.findVisibleTextNode();

		// Check if a last page marker already exists on this page
		try {
			$.each($visibleTextNode.parent().contents(), function () {

				if ($(this).hasClass("last-page")) {
					lastPageMarkerExists = true;
					existingCFI = $(this).attr("data-last-page-cfi");

					// Break out of loop
					return false;
				}
			});
		}
		catch (e) {

			console.log("Could not generate CFI for non-text node as first visible element on page");

			// No need to execute the rest of the save position method if the first visible element is not a text node
			return;
		}

		// Re-add the CFI for the marker on this page and shortcut the method
		// REFACTORING CANDIDATE: This shortcut makes this method confusing, it needs to be refactored for simplicity
		if (lastPageMarkerExists) {

			this.model.addLastPageCFI(existingCFI, this.model.get("spine_position"));
			this.model.save();
			return; 
		}

		characterOffset = this.findVisibleCharacterOffset($visibleTextNode);

		// Get the content document idref
		contentDocumentIdref = this.model.getCurrentSection().get("idref");

		// Get the package document
		// REFACTORING CANDIDATE: This is a temporary approach for retrieving a document representation of the 
		//   package document. Probably best that the package model be able to return this representation of itself.
        $.ajax({

            type: "GET",
            url: this.model.epub.get("root_url"),
            dataType: "xml",
            async: false,
            success: function (response) {

                packageDocument = response;
            }
        });

		// Save the position marker
		generatedCFI = EPUBcfi.Generator.generateCharacterOffsetCFI(
			$visibleTextNode[0], 
			characterOffset, 
			contentDocumentIdref, 
			packageDocument, 
			["cfi-marker", "audiError"], 
			[], 
			["MathJax_Message"]);

		this.model.addLastPageCFI(
			generatedCFI, 
			this.model.get("spine_position"));

		// Save the last page marker been added
		this.model.save();
	},

	adjustIframeColumns: function() {
		var prop_dir = this.offset_dir;
		var $frame = this.$('#readium-flowing-content');

		this.setFrameSize();
		this.frame_width = parseInt($frame.width(), 10);
		this.frame_height = parseInt($frame.height(), 10);
		this.gap_width = Math.floor(this.frame_width / 7);
		if(this.model.get("two_up")) {
			this.page_width = Math.floor((this.frame_width - this.gap_width) / 2);
		}
		else {
			this.page_width = this.frame_width;
		}

		// it is important for us to make sure there is no padding or
		// margin on the <html> elem, or it will mess with our column code
		$(this.getBody()).css( this.getBodyColumnCss() );

		this.setNumPages();
		var page = this.pages.get("current_page")[0] || 1;
		this.goToPage(page);
	},

	// This is now part of the public interface
	// Description: helper method to get the a reference to the documentElement
	// of the document in this strategy's iFrame.
	// TODO: this is a bad name for this function
	getBody: function() {
		return this.$('#readium-flowing-content').contents()[0].documentElement;
	},

	hideContent: function() {
		$("#flowing-wrapper").css("opacity", "0");
	},

	showContent: function() {
		$("#flowing-wrapper").css("opacity", "1");
	},

	calcPageOffset: function(page_num) {
		return (page_num - 1) * (this.page_width + this.gap_width);
	},

	// Rationale: on iOS frames are automatically expanded to fit the content dom
	// thus we cannot use relative size for the iframe and must set abs 
	// pixel size
	setFrameSize: function() {
		var width = this.getFrameWidth().toString() + "px";
		var height = this.getFrameHeight().toString() + "px";

		this.$('#readium-flowing-content').attr("width", width);
		this.$('#readium-flowing-content').attr("height", height);
		this.$('#readium-flowing-content').css("width", width);
		this.$('#readium-flowing-content').css("height", height);
	},

	getFrameWidth: function() {
		var width;
		var margin = this.model.get("current_margin");
		if (margin === 1) {
			this.model.get("two_up") ? (width = 0.95) : (width = 0.90);
		}
		else if (margin === 2) {
			this.model.get("two_up") ? (width = 0.89) : (width = 0.80);
		}
		else if (margin === 3) {
			this.model.get("two_up") ? (width = 0.83) : (width = 0.70);	
		}
		else if (margin === 4) {
			this.model.get("two_up") ? (width = 0.77) : (width = 0.60);	
		}
		else {
			this.model.get("two_up") ? (width = 0.70) : (width = 0.50);	
		}
		
		return Math.floor( $('#flowing-wrapper').width() * width );
	},

	getFrameHeight: function() {
		return $('#flowing-wrapper').height();
	},

	// Description: calculate the number of pages in the current section,
	//   based on section length : page size ratio
	calcNumPages: function() {

		var body, offset, width, num;
		
		// get a reference to the dom body
		body = this.getBody();

		// cache the current offset 
		offset = body.style[this.offset_dir];

		// set the offset to 0 so that all overflow is part of
		// the scroll width
		body.style[this.offset_dir] = "0px";

		// grab the scrollwidth => total content width
		width = this.getBody().scrollWidth;

		// reset the offset to its original value
		body.style[this.offset_dir] = offset;

		// perform calculation and return result...
		num = Math.floor( (width + this.gap_width) / (this.gap_width + this.page_width) );

		// in two up mode, always set to an even number of pages
		if( num % 2 === 0 && this.model.get("two_up")) {
			//num += 1;
		}
		return num;
	},

    getElemPageNumber: function(elem) {
		
		var $elem;
		var elemWasInvisible = false;
		var rects, shift;

		// Rationale: Elements with an epub:type="pagebreak" attribute value are likely to be set as 
		//   display:none, as they indicate the end of a page in the corresponding physical version of a book. We need 
		//   the position of these elements to get the reflowable page number to set in the viewer. Therefore, 
		//   we check if the element has this epub:type value, set it visible, find its location and then set it to 
		//   display:none again. 
		// REFACTORING CANDIDATE: We might want to do this for any element with display:none. 
		$elem = $(elem);
		if ($elem.attr("epub:type") === "pagebreak" && !$elem.is(":visible")) {

			elemWasInvisible = true;
			$elem.show();
		}

		rects = elem.getClientRects();
		if(!rects || rects.length < 1) {
			// if there were no rects the elem had display none
			return -1;
		}

		shift = rects[0][this.offset_dir];
		
		// calculate to the center of the elem (the edge will cause off by one errors)
		shift += Math.abs(rects[0].left - rects[0].right);
		
        // Re-hide the element if it was original set as display:none
        if (elemWasInvisible) {
            $elem.hide();
        }

		// `clientRects` are relative to the top left corner of the frame, but
		// for right to left we actually need to measure relative to right edge
		// of the frame
		if(this.offset_dir === "right") {
			// the right edge is exactly `this.page_width` pixels from the right 
			// edge
			shift = this.page_width - shift;
		}
		// less the amount we already shifted to get to cp
		shift -= parseInt(this.getBody().style[this.offset_dir], 10); 
		return Math.ceil( shift / (this.page_width + this.gap_width) );
	},

	// REFACTORING CANDIDATE: This might be part of the public interface
	getElemPageNumberById: function(elemId) {
        var doc = $("#readium-flowing-content").contents()[0].documentElement;
        var elem = $(doc).find("#" + elemId);
        if (elem.length == 0) {
            return -1;
        }
        else {
            return this.getElemPageNumber(elem[0]);
        }
    },

	pageChangeHandler: function() {
        var that = this;
		this.hideContent();
		setTimeout(function() {
			that.goToPage(that.pages.get("current_page")[0]);
			that.model.paginator.v.savePosition();
		}, 150);
	},

	windowSizeChangeHandler: function() {
		this.adjustIframeColumns();
		
		// Make sure we return to the correct position in the epub (This also requires clearing the hash fragment) on resize.
		this.goToHashFragment(this.model.get("hash_fragment"));
	},
    
	marginCallback: function() {
		this.adjustIframeColumns();
	},

	// Rationale: sadly this is just a reprint of what is already in the
	//   themes stylesheet. It isn't very DRY but the implementation is
	//   cleaner this way
	themes: {
		"default-theme": {
			"background-color": "white",
			"color": "black",
			"mo-color": "#777"
		},

		"vancouver-theme": {
			"background-color": "#DDD",
			"color": "#576b96",
			"mo-color": "#777"
		},

		"ballard-theme": {
			"background-color": "#576b96",
			"color": "#DDD",
			"mo-color": "#888"
		},

		"parchment-theme": {
			"background-color": "#f7f1cf",
			"color": "#774c27",
			"mo-color": "#eebb22"
		},

		"night-theme": {
			"background-color": "#141414",
			"color": "white",
			"mo-color": "#666"
		}
	},

	injectTheme: function() {
		var theme = this.model.get("current_theme");
		if(theme === "default") theme = "default-theme";
		$(this.getBody()).css({
			"color": this.themes[theme]["color"],
			"background-color": this.themes[theme]["background-color"]
		});
		
		// stop flicker due to application for alternate style sheets
		// just set content to be invisible
		$("#flowing-wrapper").css("visibility", "hidden");
		this.activateEPubStyle(this.getBody());

		// wait for new stylesheets to parse before setting back to visible
		setTimeout(function() {
			$("#flowing-wrapper").css("visibility", "visible");	
		}, 100);
	},

	setNumPages: function() {
		var num = this.calcNumPages();
		this.pages.set("num_pages", num);
	}
});
Readium.Views.ScrollingPaginationView = Readium.Views.PaginationViewBase.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function(options) {
		// call the super ctor
		Readium.Views.PaginationViewBase.prototype.initialize.call(this, options);
		this.page_template = Handlebars.templates.scrolling_page_template;
	},

	render: function() {
		var that = this;
		var json = this.model.getCurrentSection().toJSON();
		this.$('#container').html( this.page_template(json) );
		
		this.$('.content-sandbox').on("load", function(e) {
			that.iframeLoadCallback(e);
		});

		return [this.model.get("spine_position")];
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: sometimes these views hang around in memory before
	//   the GC's get them. we need to remove all of the handlers
	//   that were registered on the model
	destruct: function() {
		// call the super destructor
		Readium.Views.PaginationViewBase.prototype.destruct.call(this);
	}
});
Readium.Views.ToolbarView = Backbone.View.extend({

	el: "#toolbar-el",

	initialize: function() {
		this.model.on("change:toolbar_visible", this.renderBarVisibility, this);
		this.model.on("change:full_screen", this.renderFullScreen, this);
		this.model.on("change:current_theme", this.renderThemeButton, this);
        this.model.on("change:spine_position", this.renderMoButtons, this);
        
        var moController = this.model.get("media_overlay_controller");
        moController.on("change:volume", this.renderVolumeButton, this);
        moController.on("change:rate", this.renderRateButton, this);  
	},

	render: function() {
		this.renderBarVisibility();
		this.renderFullScreen();
		this.renderThemeButton();
		this.renderTitle();
		return this;
	},

	renderBarVisibility: function() {
		var visible = this.model.get("toolbar_visible");
		this.$('#show-toolbar-button').toggle( !visible );
		this.$('#toolbar-title').toggle( !visible );
		this.$('#top-bar').toggle( visible );
		return this;
	},

	renderFullScreen: function() {
		var isFs = this.model.get("full_screen");
		this.$("#go-to-fs-ico").toggle( !isFs );
		this.$("#leave-fs-ico").toggle( isFs );
		return this;
	},

	renderThemeButton: function() {
		var isNight = this.model.get("current_theme") === "night-theme";
		this.$('#night-to-day-ico').toggle(isNight);
		this.$('#day-to-night-ico').toggle(!isNight);
		return this;
	},

	renderTitle: function() {
		var title = this.model.epub.get("title");
		this.$('#toolbar-title').html(title);
		return this;
	},
    
    renderMoButtons: function() {
        if (this.model.getCurrentSection().hasMediaOverlay()) {
            $("#play-mo-btn").show();
            $("#mo-volume-btn-group").show();
            $("#mo-rate-btn-group").show();
            this.renderVolumeButton();
            this.renderRateButton();
        }
        else {
            $("#play-mo-btn").hide();
            $("#mo-volume-btn-group").hide();
            $("#mo-rate-btn-group").hide();
        }
    },
    
    renderVolumeButton: function() {
        var moController = this.model.get("media_overlay_controller");
        var value = moController.get("volume");
        $("#mo-volume-slider").val(value);
        
        var isMuted = moController.get("volume") == 0;
        this.$('#mo-volume-btn').toggle(!isMuted);
    	this.$('#mo-volume-muted-btn').toggle(isMuted);
    },
    
    renderRateButton: function() {
        var moController = this.model.get("media_overlay_controller");
        var value = moController.get("rate");
        $("#mo-rate-slider").val(value);
    },
    
	events: {
		"click #hide-toolbar-button": "hide_toolbar",
		"click #show-toolbar-button": "show_toolbar",
		"click #fs-toggle-btn": "toggle_fs",
		"click #toggle-toc-btn": "toggle_toc",
		"click #nightmode-btn": "toggle_night_mode",
		"click #play-mo-btn": "play_mo",
        "change #mo-volume-slider": "set_mo_volume",
        "click #mo-volume-btn": "mute_mo",
        "click #mo-volume-muted-btn": "mute_mo",
        "change #mo-rate-slider": "set_mo_rate",
        "click #mo-rate-btn": "reset_mo_rate"
	},

	show_toolbar: function(e) {
		e.preventDefault();
		this.model.set("toolbar_visible", true);
	},

	hide_toolbar: function(e) {
		e.preventDefault();
		this.model.set("toolbar_visible", false);
	},

	toggle_fs: function(e) {
		e.preventDefault();
		this.model.toggleFullScreen();
	},

	toggle_toc: function(e) {
		e.preventDefault();
		this.model.toggleToc();
	},

	toggle_night_mode: function() {
		var current_theme = this.model.get("current_theme");
		if(current_theme === "night-theme") {
			this.model.set("current_theme", "default-theme");
		}
		else {
			this.model.set("current_theme", "night-theme");
		}
		this.model.save();
	},

    // toggle play/pause
	play_mo: function() {
        var moController = this.model.get("media_overlay_controller");
		if (moController.get("active_mo")) {
			moController.pauseMo();
		}
		else {
			moController.playMo();
		}
	},
    
    set_mo_volume: function() {
        var slider = $("#mo-volume-slider");
        var value = parseFloat(slider.val()).toFixed(1); 
        var moController = this.model.get("media_overlay_controller");
        moController.set("volume", value);
    },
    
    mute_mo: function() {
        var moController = this.model.get("media_overlay_controller");
        // this function toggles between mute and unmute
        moController.mute();
    },
    
    set_mo_rate: function() {
        var slider = $("#mo-rate-slider");
        var value = parseFloat(slider.val()).toFixed(1); 
        var moController = this.model.get("media_overlay_controller");
        moController.set("rate", value);
    },
    
    reset_mo_rate: function() {
        var moController = this.model.get("media_overlay_controller");
        moController.set("rate", 1.0);
    }
    
});
Readium.Views.TocViewBase = Backbone.View.extend({

	el: "#readium-toc",

	initialize: function() {
		this.model.on("change", this.render, this);
		this.model.on("change:visible", this.setVisibility, this);
	},

	events: {
		"click a": "handleClick",
		"click #close-toc-button": "closeToc"
	},

	setVisibility: function() {
		this.$el.toggle(this.model.get("visible"));
	},

	handleClick: function(e) {
		e.preventDefault();
		href = $(e.currentTarget).attr("href");
		this.model.handleLink(href);
	},

	handleSelect : function (e) {

		var href = e.val;
		this.model.handleLink(href);
	},

	closeToc: function(e) {
		e.preventDefault();
		this.model.hide();
	}
});


Readium.Views.NcxTocView = Readium.Views.TocViewBase.extend({ 

	initialize: function() {
		Readium.Views.TocViewBase.prototype.initialize.call(this);
		this.nav_template = Handlebars.templates.ncx_nav_template;
	},

	render: function() {

		var ol;

		this.setVisibility();

		// Construct html for the navPoints in the document		
		ol = this.addNavPointElements(this.model.get("navs"));

		this.$('#toc-body').html("<h2>" + (this.model.get("title") || "Contents") + "</h2>")
		this.$('#toc-body').append(ol);
		this.$('#toc-body').append("<div id='toc-end-spacer'>");
		return this;
	},

	// Description: Constructs an html representation of NCX navPoints, based on an object of navPoint information
	// Rationale: This is a recursive method, as NCX navPoint elements can nest 0 or more of themselves as children
	addNavPointElements: function (jsonNavs) {

		var ol = $("<ol></ol>");
		var that = this;

		$.each(jsonNavs, function (navIndex) {

			var hasNavs;

			// Add the current navPoint element to the TOC html 
			ol.append( that.nav_template(jsonNavs[navIndex]) );

			// Check if the current navPoint has navPoints of its own
			hasNavs = jsonNavs[navIndex].navs.length > 0 ? true : false;
			if (hasNavs) {

				var li = $("<li></li>");
				li.append(that.addNavPointElements(jsonNavs[navIndex].navs));
				ol.append(li);
			}
		});

		return ol; 
	}
});

Readium.Views.XhtmlTocView = Readium.Views.TocViewBase.extend({ 

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	events : {

		"click a": "handleClick",
		"click #close-toc-button": "closeToc",
		"change #toc-body" : "handleSelect"
	},

	render: function() {
			
		this.$('#toc-body').html( this.model.get("body").html() );
		this.formatPageListNavigation();
		this.$('#toc-body').append("<div id='toc-end-spacer'>");
		return this;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	formatPageListNavigation : function () {

		var $navElements;
		var $pageListNavElement;
		var pageListData = [];

		// Search for a nav element with epub:type="page-list". A nav element of this type must not occur more than once.
		$navElements = this.$("nav");
		$pageListNavElement = $navElements.filter(function () {

			if ($(this).attr("epub:type") === 'page-list') {

				// Hide the standard XHTML page-list nav element, as we'll be displaying a select2 drop-down control for this.
				$(this).attr("id", "page-list-select");
				$(this).hide();
				return true;
			}
		});

		// Each nav element has a single ordered list of page numbers. Extract this data into an array so it can be 
		//   loaded in the page-list control
		// TODO: span elements can be used to create sub-headings. Implement functionality to account for this at some point.
		$.each($('a', $pageListNavElement), function () { 

			var $navTarget = $(this);
			pageListData.push({

				id : $navTarget.attr("href"),
				text : "Page-" + $navTarget.text()
			});
		});

		// Create the select2 control
		$("#page-list-select").select2({

			placeholder : "Select a page",
			data : pageListData
		});

		// the select2 adds no-op inline click handlers, but these are not allowed
		// by chromes content securty policy so just remove them
		this.$('[onclick]').removeAttr('onclick');
	}
});
Readium.Views.OptionsView = Backbone.View.extend({

	el: '#viewer-settings-modal',

	initialize: function() {
		this.model.on("change:current_theme", this.renderTheme, this);
		this.model.on("change:two_up", this.renderUpMode, this);
		this.model.on("change:current_margin", this.renderMarginRadio, this);
		this.model.on("change:font_size", this.renderFontSize, this);
	},

	render: function() {
		this.renderTheme();
		this.renderUpMode();
		this.renderMarginRadio();
		this.renderFontSize();
		return this;
	},

	renderTheme: function() {
		this.$('#preview-text')[0].className = this.model.get("current_theme");
		return this;
	},

	renderUpMode: function() {
		var twoUp = this.model.get("two_up");
		this.$("#one-up-option").toggleClass("selected", !twoUp);
		this.$("#two-up-option").toggleClass("selected", twoUp);
		return this;
	},

	renderMarginRadio: function() {
		var id = "#margin-option-" + this.model.get("current_margin");
		this.$('.margin-radio').toggleClass("selected", false);
		this.$(id).toggleClass("selected", true);
		return this;
	},

	renderFontSize: function() {
		var val = this.model.get("font_size");
		var size = (val / 10).toString() + "em";

		// apply the size to the preview text area
		this.$('#preview-text').css("font-size", size);

		// set the value of the slider
		this.$("#font-size-input").val(val);
	},

	events: {
    	"click .theme-option": 			"selectTheme",
    	"click .margin-radio": 			"selectMargin",
    	"click #cancel-settings-but": 	"cancelSettings",
		"click #save-settings-but": 	"applySettings",
    	"change #font-size-input": 		"extractFontSize",
    	"click #one-up-option": function(e) { this.model.set("two_up", false) },
		"click #two-up-option": function(e) { this.model.set("two_up", true) }	
  	},

  	extractFontSize: function(e) {
		var val = $("#font-size-input").val();
		val = parseInt(val, 10);
		this.model.set("font_size", val);
	},

  	selectTheme: function(e) {
  		var id = e.srcElement.id;
  		if(id === "default-theme-option" ) this.model.set("current_theme", "default-theme");
		if(id === "night-theme-option" ) this.model.set("current_theme", "night-theme");
		if(id === "parchment-theme-option" ) this.model.set("current_theme", "parchment-theme");
		if(id === "ballard-theme-option" ) this.model.set("current_theme", "ballard-theme");
		if(id === "vancouver-theme-option" ) this.model.set("current_theme", "vancouver-theme");
  	},

  	selectMargin: function(e) {
  		var id = e.srcElement.id;
  		var num = id[id.length - 1];
  		if(num === "1" ) this.model.set("current_margin", 1);
		if(num === "2" ) this.model.set("current_margin", 2);
		if(num === "3" ) this.model.set("current_margin", 3);
		if(num === "4" ) this.model.set("current_margin", 4);
		if(num === "5" ) this.model.set("current_margin", 5);
  	},

  	cancelSettings: function(e) {
  		this.$el.modal('hide');
  		this.model.resetOptions();
  	},

  	applySettings: function(e) {
  		this.model.applyOptions();
  		this.$el.modal('hide');
  	}


});
// Fixed layout books may have pages that are bigger of smaller than allowed 
// by the viewport. Thus we need to scale the book holding `div` in order to
// if the book to the screen.
Readium.Views.FixedLayoutBookZoomer = Backbone.View.extend({

	el: "#readium-right-content",

	// total amount of space to leave around the pages after calling
	// `fitToWidth` / `fitToHeight`
	horizontalPad: 30,
	verticalPad: 30,

	initialize: function() {
		this.zoomingModel = new Readium.Models.FixedLayoutBookZoomingModel();
	},

	/* ------------------------------------------------------------------------------------ */
  	//  "PUBLIC" METHODS (THE API)                                                          //
  	/* ------------------------------------------------------------------------------------ */

	// apply the current transformations held in this views `BookZoomingModel` to
	// the `el`
	render: function() {
		this.$("#page-wrap").css(this.zoomingModel.getCSSProperties());
		return this;
	},

	// remove any tranformations that have been applied to this `el`
	reset: function() {
		this.zoomingModel.setDefaults();
		this.render();
	},

	// apply the minimum scalar transormation to the div wrapping this books pages
	// in order to have all content displayed 
	fitToBest: function() {
		var widthScale = this.fitToWidthScale();
		var heightScale = this.fitToHeightScale();

		if(widthScale < heightScale) {
			this.applyScale(widthScale);
		}
		else {
			this.applyScale(heightScale);
		}
	},

	// apply transformations that fit the books pages as best as possible linearly
	fitToWidth: function() {
		var scale = this.fitToWidthScale();
		this.applyScale(scale);
	},

	// apply transformations that fit the books pages as best as possible veritcally
	fitToHeight: function() {
		var scale = this.fitToHeightScale();
		this.applyScale(scale);
	},

	
	/* ------------------------------------------------------------------------------------ */
	//  "PRIVATE" HELPERS                                                                   //
	/* ------------------------------------------------------------------------------------ */

	fitToWidthScale: function() {
		return (this.containerWidth() - this.horizontalPad) / this.bookWidth();
	},

	fitToHeightScale: function() {
		return (this.containerHeight() - this.verticalPad) / this.bookHeight();
	},

	applyScale: function(scale) {
		this.zoomingModel.set("scale", scale);
		this.zoomingModel.set("leftShift", this.leftShift(scale));
		this.zoomingModel.set("topShift", this.verticalPad / 2);
		this.render();
	},

	// calculate the amount of left shift required to center the book's pages
	// after applying a given scale transormation
	leftShift: function(scale) {
		var width = this.containerWidth();
		return (width - (this.bookWidth() * scale)) / 2;
	},

	containerWidth: function() {
		return this.$el.width();
	},

	containerHeight: function() {
		return this.$el.height() ;
	},

	bookWidth: function() {
		return this.$("#page-wrap").width();
	},

	bookHeight: function() {
		return this.$("#page-wrap").height();
	}

});


Readium.Models.FixedLayoutBookZoomingModel = Backbone.Model.extend({

	initialize: function() {

		// get the browser vendor prefixed attrs one time, rather than
		// every time we render
		this.styleAttrs = this.getModernizedAttrs();

	},

	defaults: {
		scale: 1,
		leftShift: 0,
		topShift: 0
	},

	setDefaults: function() {
		this.set(this.defaults);
	},

	getModernizedAttrs: function() {
		var attrs = {};
		attrs.transform = this.modernizrCssPrefix("transform");
		attrs.transformOrigin = this.modernizrCssPrefix("transformOrigin");
		return attrs;
	},

	modernizrCssPrefix: function(attr) {
		var str = Modernizr.prefixed(attr);
		return str.replace(/([A-Z])/g, function(str, m1){ 
			return '-' + m1.toLowerCase(); 
		}).replace(/^ms-/,'-ms-');
	},


	getCSSProperties: function() {
		var css = {};
		css[this.styleAttrs.transform] = this.getTransformString();
		css[this.styleAttrs.transformOrigin] = "0 0";
		return css;
	},

	getTransformString: function() {

		str  = "";
		str += "translate(" + this.get("leftShift") + "px, " + this.get("topShift") + "px) ";
		str += "scale(" + this.get("scale").toString() + ")";
		return str;
	}

});
// REFACTORING CANDIDATE: Parts of this model are making calls to the current view through the epubController->paginator->view->etc., 
//   that is a lot of indirection. Perhaps epubController shouldn't be at the centre of this model anymore.

Readium.Views.ViewerApplicationView = Backbone.View.extend({
	el: 'body',

	uiVisible: false,

	initialize: function() {
		
		this.model.on("change:full_screen", this.toggleFullscreen, this);
		this.model.on("change:current_theme", this.renderTheme, this);
		this.model.on("change:toolbar_visible", this.renderPageButtons, this);
		this.model.on("change:toc_visible", this.renderTocVisible, this);

		this.optionsPresenter = new Readium.Models.OptionsPresenter({
			book: this.model
		});
		this.optionsView = new Readium.Views.OptionsView({model: this.optionsPresenter});
		this.optionsView.render();

		// the top bar
		this.toolbar = new Readium.Views.ToolbarView({model: _epubController});
		this.toolbar.render();

		// the table of contents
		this.model.on("change:has_toc", this.init_toc, this);

		this.addGlobalEventHandlers();
	},

	toggleFullscreen: function() {
		if(this.model.get("full_screen")) {
			document.documentElement.webkitRequestFullScreen();	
		}
		else {
			document.webkitCancelFullScreen();				
		}
	},

	addGlobalEventHandlers: function() {
		var book = this.model;
		var that = this;
		window.onresize = function(event) {
			book.trigger("repagination_event");
		}

		$(document).keydown(function(e) {
			if(e.which == 39) {
				that.model.paginator.v.pages.goRight();
			}
							
			if(e.which == 37) {
				that.model.paginator.v.pages.goLeft();
			}
		});

		$("#readium-book-view-el").on("swipeleft", function(e) {
			e.preventDefault();
			that.model.paginator.v.pages.goRight();
			
		});

		$("#readium-book-view-el").on("swiperight", function(e) {
			e.preventDefault();
			that.model.paginator.v.pages.goLeft();
		});
	},

	render: function() {
		// right now we dont do anything but 
		// convention is to return this from render
		this.renderTheme();
		this.renderPageButtons();
		this.renderTocVisible();
		return this; 
	},

	renderPageButtons: function() {
		var vis = this.model.get("toolbar_visible");
		this.$("#prev-page-button").toggle(vis);
		this.$("#next-page-button").toggle(vis);
		return this;
	},

	renderTheme: function() {
		var theme = this.model.get("current_theme");
		this.$el.toggleClass("default-theme", "default-theme" === theme);
		this.$el.toggleClass("night-theme", "night-theme" === theme);
		this.$el.toggleClass("parchment-theme", "parchment-theme" === theme);
		this.$el.toggleClass("ballard-theme", "ballard-theme" === theme);
		this.$el.toggleClass("vancouver-theme", "vancouver-theme" === theme);

		this.$("#readium-book-view-el").toggleClass("default-theme", "default-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("night-theme", "night-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("parchment-theme", "parchment-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("ballard-theme", "ballard-theme" === theme);
		this.$("#readium-book-view-el").toggleClass("vancouver-theme", "vancouver-theme" === theme);
	},

	renderTocVisible: function() {
		this.$el.toggleClass("show-readium-toc", this.model.get("toc_visible"));
		return this;
	},

	init_toc: function() {
		if( this.model.get("has_toc") ) {
			var toc_item = this.model.getToc();			
			this.toc = toc_item.TocView();
			toc_item.fetch();

		}
	},	
	
	events: {
		"click #prev-page-button": 	function() { 
			this.model.paginator.v.pages.goLeft();
		},
		"click #next-page-button": 	function() { 
			this.model.paginator.v.pages.goRight();
		}
  	}
});
// This is the router used by the web served version of readium
// This router is used in the book view of the chrome extension build of readium
Readium.Routers.ViewerRouter = Backbone.Router.extend({

	routes: {
		"viewer.html?book=:key": "openBook",
		"*splat": "splat_handler"
	},

	openBook: function(key) {

		// look up the book by its key in the global array or library data
		var book_data = _.find(window.ReadiumLibraryData, function(obj) {
			return obj.key === key;
		});

		if(book_data) {
			// initialze the viewer for that book
			window._epub = new Readium.Models.EPUB(book_data);
			window._epubController = new Readium.Models.EPUBController(_.extend({epub : window._epub}, book_data));
			window._applicationView = new Readium.Views.ViewerApplicationView({
				model: window._epubController
			});
			window._applicationView.render();
		}
		else {
			// did not find the book in our library
			alert("The book you requested does not exist");
		}

	},

	splat_handler: function(splat) {
		console.log(splat)
	}

});
// Description: This model is responsible for the read-only attributes and content of an epub. 
// Rationale: This is designed as a model to represent the state of an epub as it is maintained by the Readium application.
//   As Readium does not have any authoring capabilities (a saved epub is not modified), this model essentially represents the 
//   epub in a read-only fashion (although this is not enforced).

Readium.Models.EPUB = Backbone.Model.extend({

	defaults: {
    	"can_two_up": true
  	},

  	// ------------------------------------------------------------------------------------ //
  	//  "PUBLIC" METHODS (THE API)                                                          //
  	// ------------------------------------------------------------------------------------ //

	initialize: function() {

		// capture context for use in callback functions
		var that = this;

		// intantiate a [`PackageDocument`](/docs/packageDocument.html)
		this.packageDocument = new Readium.Models.PackageDocument({ 
			book : this, 
			file_path : this.get("package_doc_path") 
			});
	},

	getPackageDocument: function () {

		return this.packageDocument;
	},

  	toJSON: function() {

  		// only save attrs that should be persisted:
  		return {
			"apple_fixed": this.get("apple_fixed"),
			"author": this.get("author"),
			"cover_href": this.get("cover_href"),
			"created_at": this.get("created_at"),
			"description": this.get("description"),
			"epub_version": this.get("epub_version"),
			"fixed_layout": this.get("fixed_layout"),
			"id": this.get("id"),
			"key": this.get("key"),
			"language": this.get("language"),
			"layout": this.get("layout"),
			"modified_date": this.get("modified_date"),
			"ncx": this.get("ncx"),
			"open_to_spread": this.get("open_to_spread"),
			"orientation": this.get("orientation"),
			"package_doc_path": this.get("package_doc_path"),
			"page_prog_dir": this.get("page_prog_dir"),
			"paginate_backwards": this.get("paginate_backwards"),
			"pubdate": this.get("pubdate"),
			"publisher": this.get("publisher"),
			"rights": this.get("rights"),
			"spread": this.get("spread"),
			"src_url": this.get("src_url"),
			"title": this.get("title")
		};
	},

	resolvePath: function(path) {
		return this.packageDocument.resolvePath(path);
	},

	// is this book set to fixed layout at the meta-data level
	isFixedLayout: function() {
		return this.get("fixed_layout") || this.get("apple_fixed");
	}
});
// Description: This model is responsible determining page numbers to display for both reflowable and fixed layout pubs.
// Rationale: This model exists to abstract and encapsulate the logic for determining which pages numbers should be
//   dispalyed in the viewer. The logic for this is reasonably complex, as there a number of different factors that must be
//   taken into account in various cases. These include: The type of the pub (reflowable or fixed layout), the page progression direction, 
//   the reading order of pages, the number of pages displayed on the screen and author preferences 
//   for the location of pages (left/right/centre). 

Readium.Models.PageNumberDisplayLogic = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {},

	// REFACTORING CANDIDATE: This might be better named as getPageNumsToDisplay; the "goto" is confusing; also some
	//   deep nesting here that could be refactored for clarity.
    // Description: This method determines the page numbers to display, given a single page number to "go to"
    // Arguments (
    //   gotoPageNumber (integer): The page number to "go to"
    //   twoUp (boolean): Are two pages currently displayed in the reader?
    //   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
    //   pageProgDirection ("rtl" or "ltr): The page progression direction
    //	)
	getGotoPageNumsToDisplay: function(gotoPageNumber, twoUp, isFixedLayout, pageProgDirection) {

		if (twoUp) {
			
			// Fixed layout page
			if (isFixedLayout) {

				if (pageProgDirection === "rtl") {

					if (this.displayedPageIsLeft(gotoPageNumber)) {

						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else if (this.displayedPageIsRight(gotoPageNumber)) {

						return [gotoPageNumber, gotoPageNumber + 1];
					}
					else {

						return [gotoPageNumber];
					}
				}
				// Left-to-right page progression
				else {

					if (this.displayedPageIsLeft(gotoPageNumber)) {

						return [gotoPageNumber, gotoPageNumber + 1];
					}
					else if (this.displayedPageIsRight(gotoPageNumber)) {

						return [gotoPageNumber - 1, gotoPageNumber];
					}
					else {

						return [gotoPageNumber];
					}
				}
			}
			// This is a reflowable page
			else {
				// in reflowable format, we want this config always:
				// ODD_PAGE |spine| EVEN_PAGE
				if (gotoPageNumber % 2 === 1) {

					return [gotoPageNumber, gotoPageNumber + 1];	
				}
				else {

					return [gotoPageNumber - 1, gotoPageNumber];
				}	
			}
		}
		else {
			
			return [gotoPageNumber];
		}
	},

    // Description: Get the pages numbers to display when moving in reverse reading order
    // Arguments (
    //   prevPageNumberToDisplay (integer): The page to move to; this page must be one of the displayed pages
    //   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
    //   pageProgDirection ("rtl" or "ltr): The page progression direction    	
    //	)
	getPrevPageNumsToDisplay: function (prevPageNumberToDisplay, isFixedLayout, pageProgDirection) {

		// If fixed layout
		if (isFixedLayout) {

			if (pageProgDirection === "rtl") {

				// If the first page is a left page in rtl progression, only one page 
				// can be displayed, even in two-up mode
				if (this.displayedPageIsLeft(prevPageNumberToDisplay) && 
					this.displayedPageIsRight(prevPageNumberToDisplay - 1)) {

					return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
				}
				else {

					return [prevPageNumberToDisplay];
				}
			}
			// Left-to-right progresion
			else {

				if (this.displayedPageIsRight(prevPageNumberToDisplay) &&
					this.displayedPageIsLeft(prevPageNumberToDisplay - 1)) {

					return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
				}
				else {

					return [prevPageNumberToDisplay];
				}
			}
		}
		// A reflowable text
		else {

			return [prevPageNumberToDisplay - 1, prevPageNumberToDisplay];
		}
	},

	// Description: Get the pages to display when moving in reading order
    // Arguments (
    //   nextPageNumberToDisplay (integer): The page to move to; this page must be one of the displayed pages
    //   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
    //   pageProgDirection ("rtl" or "ltr): The page progression direction    	
    //	)
	getNextPageNumsToDisplay: function (nextPageNumberToDisplay, isFixedLayout, pageProgDirection) {

		// If fixed layout
		if (isFixedLayout) {

			if (pageProgDirection === "rtl") {

				// If the first page is a left page in rtl progression, only one page 
				// can be displayed, even in two-up mode
				if (this.displayedPageIsRight(nextPageNumberToDisplay) &&
					this.displayedPageIsLeft(nextPageNumberToDisplay + 1)) {

					return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
				}
				else {

					return [nextPageNumberToDisplay];
				}
			}
			else {

				if (this.displayedPageIsLeft(nextPageNumberToDisplay) && 
					this.displayedPageIsRight(nextPageNumberToDisplay + 1)) {

					return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
				}
				else {

					return [nextPageNumberToDisplay];
				}
			}
		}
		// Reflowable section
		else {

			return [nextPageNumberToDisplay, nextPageNumberToDisplay + 1];
		}
	},

	// Description: This method determines which page numbers to display when switching
	// between a single page and side-by-side page views and vice versa.
	// Arguments (
	//   twoUp (boolean): Are two pages currently displayed in the reader?
	//   displayedPageNumbers (array of integers): An array of page numbers that are currently displayed	
	//   isFixedLayout (boolean): Are the current set of pages fixed layout pages? 
	//   pageProgDirection ("rtl" or "ltr): The page progression direction
	//	)
	// Notes: Authors can specify a fixed layout page as a "center" page, which prevents more than one page
	//   being displayed. This case is not handled yet.
	getPageNumbersForTwoUp: function(twoUp, displayedPageNumbers, pageProgDirection, isFixedLayout) {

		var displayed = displayedPageNumbers;
		var newPages = [];

		// Two pages are currently displayed; find the single page number to display
		if (twoUp) {

			if (displayed[0] === 0) {
				
				newPages[0] = 1;
			} 
			else {
				
				newPages[0] = displayed[0];
			}
		}
		// A single reflowable page is currently displayed; find two pages to display
		else if (!isFixedLayout) {

			if (displayed[0] % 2 === 1) {
				
				newPages[0] = displayed[0];
				newPages[1] = displayed[0] + 1;
			}
			else {
				
				newPages[0] = displayed[0] - 1;
				newPages[1] = displayed[0];
			}
		}
		// A single fixed layout page is displayed
		else {

			// page progression is right-to-left
			if (pageProgDirection === "rtl") {

				if (this.displayedPageIsLeft(displayed[0])) {
					
					newPages[0] = displayed[0] - 1;
					newPages[1] = displayed[0];
				}
				else if (this.displayedPageIsRight(displayed[0])) {
					
					newPages[0] = displayed[0];
					newPages[1] = displayed[0] + 1;
				}

				// TODO: Handle center pages
			}
			// page progression is left-to-right
			else {

				if (this.displayedPageIsLeft(displayed[0])) {
					
					newPages[0] = displayed[0];
					newPages[1] = displayed[0] + 1;
				}
				else if (this.displayedPageIsRight(displayed[0])) {
					
					newPages[0] = displayed[0] - 1;
					newPages[1] = displayed[0];
				}

				// TODO: Handle center pages
			}
		}

		return newPages;
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: The `displayedPageIs...` methods determine if a fixed layout page is right, left or center.
	//
	// Note: This is not an ideal approach, as we're pulling properties directly out of the dom, rather than
	// out of our models. The rationale is that as of Readium 0.4.1, the page-spread-* value
	// is not maintained in the model hierarchy accessible from an ebook object. An alternative
	// would be to infer the left/right/center value from model attributes on ebook, or other objects in
	// ebook's object hierarchy. However, this would duplicate the logic that exists elsewhere for determining right/left/center
	// for a page, which is probably worse than pulling out of the dom. This approach also avoids having to convert
	// from the page number (based on what is rendered on the screen) to spine index. 
	displayedPageIsRight: function (displayedPageNum) {

		return $("#page-" + displayedPageNum).hasClass("right_page") ? true : false;
	},

	displayedPageIsLeft: function (displayedPageNum) {

		return $("#page-" + displayedPageNum).hasClass("left_page") ? true : false;
	},

	displayedPageIsCenter: function (displayedPageNum) {

		return $("#page-" + displayedPageNum).hasClass("center_page") ? true : false;
	}
});

Readium.Models.ReadiumPagination = Backbone.Model.extend({ 

	defaults: {
		"num_pages" : 0
	},

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {

		this.epubController = this.get("model");

		// REFACTORING CANDIDATE: This is not ideal as it muddies the difference between the spine index position and 
		//   the page numbers that result from pagination. 
		this.set("current_page", [this.epubController.get("spine_position") + 1]);

		// Instantiate an object responsible for deciding which pages to display
		this.pageNumberDisplayLogic = new Readium.Models.PageNumberDisplayLogic();
		
		// if content reflows and the number of pages in the section changes
		// we need to adjust the the current page
		this.on("change:num_pages", this.adjustCurrentPage, this);
	},

	// Description: This method determines which page numbers to display when switching
	//   between a single page and side-by-side page views and vice versa.
	toggleTwoUp: function() {

		if (this.epubController.get("can_two_up")) {

			// REFACTORING CANDIDATE: refactor page number display logic to this model
			var newPages = this.pageNumberDisplayLogic.getPageNumbersForTwoUp (
				this.epubController.get("two_up"), 
				this.get("current_page"),
				this.epubController.epub.get("page_prog_dir"),
				this.epubController.getCurrentSection().isFixedLayout()
				);

			this.set({current_page: newPages});
		}	
	},

	// REFACTORING CANDIDATE: This needs to be investigated, but I bet if the prevPage and nextPage methods were 
	//   called directly (goRight and goLeft were removed), the new page number display logic would account for the 
	//   page progression direction and that all this logic could be simplified in both this model and the 
	//   PageNumberDisplayLogic model
	// 
	// Description: turn pages in the rightward direction
	//   ie progression direction is dependent on 
	//   page progression dir
	goRight: function() {
		if (this.epubController.epub.get("page_prog_dir") === "rtl") {
			this.prevPage();
		}
		else {
			this.nextPage();	
		}
	},

	// Description: Turn pages in the leftward direction
	//   ie progression direction is dependent on 
	//   page progression dir
	goLeft: function() {
		if (this.epubController.epub.get("page_prog_dir") === "rtl") {
			this.nextPage();
		}
		else {
			this.prevPage();	
		}
	},

	goToPage: function(gotoPageNumber) {

		var pagesToGoto = this.pageNumberDisplayLogic.getGotoPageNumsToDisplay(
							gotoPageNumber,
							this.epubController.get("two_up"),
							this.epubController.getCurrentSection().isFixedLayout(),
							this.epubController.epub.get("page_prog_dir")
							);
		this.set("current_page", pagesToGoto);
	},

	// Description: Return true if the pageNum argument is a currently visible 
	//   page. Return false if it is not; which will occur if it cannot be found in 
	//   the array.
	isPageVisible: function(pageNum) {
		return this.get("current_page").indexOf(pageNum) !== -1;
	},

	// REFACTORING CANDIDATE: prevPage and nextPage are public but not sure it should be; it's called from the navwidget and viewer.js.
	//   Additionally the logic in this method, as well as that in nextPage(), could be refactored to more clearly represent that 
	//   multiple different cases involved in switching pages.
	prevPage: function() {

		var curr_pg = this.get("current_page");
		var lastPage = curr_pg[0] - 1;

		// Clear the hash fragment if the user has decided to navigate away from it
		this.epubController.set("hash_fragment", undefined);

		if (curr_pg[0] <= 1) {

			this.epubController.goToPrevSection();
		}
		// REFACTORING CANDIDATE: The pagination/spine position relationship is still muddied. As a result, 
		//   the assumption that a single content document (spine element) is rendered in every scrolling view must be
		//   enforced here with this scrolling view specific check condition. 
		else if (this.epubController.paginator.shouldScroll() &&
			     !this.epubController.getCurrentSection().isFixedLayout()) {

			this.epubController.goToPrevSection();
		}
		// Single page navigation
		else if (!this.epubController.get("two_up")){

			this.set("current_page", [lastPage]);

			// Reset spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {
				var pos = this.epubController.get("rendered_spine_items")[lastPage - 1];
				this.epubController.set("spine_position", pos);
			}
		}
		// Move to previous page with two side-by-side pages
		else {

			var pagesToDisplay = this.pageNumberDisplayLogic.getPrevPageNumsToDisplay(
								lastPage,
								this.epubController.getCurrentSection().isFixedLayout(),
								this.epubController.epub.get("page_prog_dir")
								);
			this.set("current_page", pagesToDisplay);

			// Reset spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {
				var ind = (lastPage > 1 ? lastPage - 2 : 0);
				var pos = this.epubController.get("rendered_spine_items")[ind];
				this.epubController.set("spine_position", pos);
			}
		}
	},

	nextPage: function() {

		var curr_pg = this.get("current_page");
		var firstPage = curr_pg[curr_pg.length - 1] + 1;

		// Clear the hash fragment if the user has decided to navigate away from it
		this.epubController.set("hash_fragment", undefined);

		if (curr_pg[curr_pg.length - 1] >= this.get("num_pages")) {

			this.epubController.goToNextSection();
		}
		else if (!this.epubController.get("two_up")) {

			this.set("current_page", [firstPage]);

			// Reset the spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {

				var pos = this.epubController.get("rendered_spine_items")[firstPage - 1];
				this.epubController.set("spine_position", pos);
			}
		}
		// Two pages are being displayed
		else {

			var pagesToDisplay = this.pageNumberDisplayLogic.getNextPageNumsToDisplay(
								firstPage,
								this.epubController.getCurrentSection().isFixedLayout(),
								this.epubController.epub.get("page_prog_dir")
								);
			this.set("current_page", pagesToDisplay);

			// Reset the spine position
			if (this.epubController.get("rendered_spine_items").length > 1) {

				var pos = this.epubController.get("rendered_spine_items")[firstPage - 1];
				this.epubController.set("spine_position", pos);
			}
		}
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	adjustCurrentPage: function() {
		var cp = this.get("current_page");
		var num = this.get("num_pages");
		var two_up = this.epubController.get("two_up");
		if(cp[cp.length - 1] > num) {
			this.goToLastPage();
		}
	},	

	// REFACTORING CANDIDATE: this is strange in that it does not seem to account for 
	//   possibly crossing over a section boundary
	goToLastPage: function() {
		var page = this.get("num_pages");
		this.goToPage(page);
	}
});
(function() {
  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};
templates['binding_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var foundHelper, self=this;


  return "<iframe scrolling=\"no\" \n		frameborder=\"0\" \n		marginwidth=\"0\" \n		marginheight=\"0\" \n		width=\"100%\" \n		height=\"100%\" \n		class='binding-sandbox'>\n</iframe>";});
templates['extracting_item_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<h5>";
  foundHelper = helpers.log_message;
  stack1 = foundHelper || depth0.log_message;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "log_message", { hash: {} }); }
  buffer += escapeExpression(stack1) + "</h5>\n<div class=\"progress progress-striped progress-success active \">	\n		<div role=\"status\" aria-live=\"assertive\" aria-relevant=\"all\" class=\"bar\" style=\"width: ";
  foundHelper = helpers.progress;
  stack1 = foundHelper || depth0.progress;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "progress", { hash: {} }); }
  buffer += escapeExpression(stack1) + "%;\"></div>\n</div>";
  return buffer;});
templates['fixed_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"fixed-page-margin\">\n	<iframe scrolling=\"no\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"";
  foundHelper = helpers.width;
  stack1 = foundHelper || depth0.width;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "width", { hash: {} }); }
  buffer += escapeExpression(stack1) + "px\" \n			height=\"";
  foundHelper = helpers.height;
  stack1 = foundHelper || depth0.height;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "height", { hash: {} }); }
  buffer += escapeExpression(stack1) + "px\" \n			src=\"";
  foundHelper = helpers.uri;
  stack1 = foundHelper || depth0.uri;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "uri", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\"\n			class='content-sandbox'>\n	</iframe>\n</div>";
  return buffer;});
templates['image_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"fixed-page-margin\">\n	<img src=\"";
  foundHelper = helpers.uri;
  stack1 = foundHelper || depth0.uri;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "uri", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\" >\n</div>";
  return buffer;});
templates['library_item_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<div class='info-wrap'>\n	<div class='caption book-info'>\n		<h2 class='green info-item title'>";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.title);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.title", { hash: {} }); }
  buffer += escapeExpression(stack1) + "</h2>\n		<div class='info-item author'>";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.author);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='info-item epub-version'>ePUB ";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.epub_version);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		\n	</div>\n	\n	<img class='cover-image read' src='";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.cover_href);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.cover_href", { hash: {} }); }
  buffer += escapeExpression(stack1) + "' width='150' height='220' alt='Open ePUB ";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.title);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.title", { hash: {} }); }
  buffer += escapeExpression(stack1) + "'>\n	\n	<a href=\"#details-modal-";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.key);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.key", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\" class=\"info-icon\" data-toggle=\"modal\" role=\"button\">\n		<img class='info-icon pull-right' src='/images/library/info-icon.png' height=\"39px\" width=\"39px\" alt='";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.title);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.title", { hash: {} }); }
  buffer += escapeExpression(stack1) + " information'>\n	</a>\n</div>\n\n<div class=\"caption buttons\">\n	<a href=\"#todo\" class=\"btn read\" data-book='";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.key);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.key", { hash: {} }); }
  buffer += escapeExpression(stack1) + "' role='button'>";
  stack1 = "i18n_read";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</a>\n	<a href=\"#details-modal-";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.key);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.key", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\" class=\"btn details\" data-toggle=\"modal\" role=\"button\">\n		";
  stack1 = "i18n_details";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "\n	</a>\n</div>\n\n<div id='details-modal-";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.key);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.key", { hash: {} }); }
  buffer += escapeExpression(stack1) + "' class='modal fade details-modal'>\n	<div class=\"pull-left modal-cover-wrap\">\n		<img class='details-cover-image' src='";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.cover_href);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.cover_href", { hash: {} }); }
  buffer += escapeExpression(stack1) + "' width='150' height='220' alt='ePUB cover'>\n		<div class=\"caption modal-buttons\">\n			<a href=\"#\" class=\"btn read\" data-book='<%= data.key %>' role='button'>";
  stack1 = "i18n_read";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</a>\n			<a class=\"btn btn-danger delete pull-right\" role='button'>";
  stack1 = "i18n_delete";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</a>\n		</div>\n	</div>\n	<div class='caption modal-book-info'>\n		<h3 class='green modal-title'>";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.title);
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "data.title", { hash: {} }); }
  buffer += escapeExpression(stack1) + "</h3>\n		<div class='modal-detail gap'>";
  stack1 = "i18n_author";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.author);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  stack1 = "i18n_publisher";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.publisher);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  stack1 = "i18n_pub_date";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.pubdate);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  stack1 = "i18n_modified_date";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.modified_date);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail gap'>";
  stack1 = "i18n_id";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.id);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail green'>";
  stack1 = "i18n_epub_version";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.epub_version);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  stack1 = "i18n_created_at";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1);
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.created_at);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</div>\n	</div>\n	<div class='modal-detail source'>\n	<span class='green' style=\"padding-right: 10px\">";
  stack1 = "i18n_source";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "</span>\n		";
  foundHelper = helpers.data;
  stack1 = foundHelper || depth0.data;
  stack1 = (stack1 === null || stack1 === undefined || stack1 === false ? stack1 : stack1.src_url);
  foundHelper = helpers.orUnknown;
  stack2 = foundHelper || depth0.orUnknown;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "orUnknown", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "\n	</div>\n</div>			";
  return buffer;});
templates['library_items_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<div id='empty-message'>\n	<p id='empty-message-text' class='green'>\n		";
  stack1 = "i18n_add_items";
  foundHelper = helpers.fetchInzMessage;
  stack2 = foundHelper || depth0.fetchInzMessage;
  if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, stack1, { hash: {} }); }
  else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "fetchInzMessage", stack1, { hash: {} }); }
  else { stack1 = stack2; }
  buffer += escapeExpression(stack1) + "\n	</p>\n	<img id='empty-arrow' src='/images/library/empty_library_arrow.png' alt='' />\n</div>";
  return buffer;});
templates['ncx_nav_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<li class=\"nav-elem\">\n	<a href=\"";
  foundHelper = helpers.href;
  stack1 = foundHelper || depth0.href;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "href", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\">";
  foundHelper = helpers.text;
  stack1 = foundHelper || depth0.text;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "text", { hash: {} }); }
  buffer += escapeExpression(stack1) + "</a>\n</li>";
  return buffer;});
templates['reflowing_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<div id=\"flowing-wrapper\">\n	<iframe scrolling=\"no\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"50%\" \n			height=\"100%\" \n			src=\"";
  foundHelper = helpers.uri;
  stack1 = foundHelper || depth0.uri;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "uri", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\"\n			id=\"readium-flowing-content\">\n	</iframe>\n</div>";
  return buffer;});
templates['scrolling_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


  buffer += "<div id=\"scrolling-content\" class=\"scrolling-page-wrap\">\n	<div class=\"scrolling-page-margin\">\n\n		<iframe scrolling=\"yes\" \n				frameborder=\"0\" \n				marginwidth=\"0\" \n				marginheight=\"0\" \n				width=\"100%\" \n				height=\"100%\" \n				src=\"";
  foundHelper = helpers.uri;
  stack1 = foundHelper || depth0.uri;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "uri", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\"\n				class='content-sandbox'>\n		</iframe>\n	</div>\n</div>";
  return buffer;});
})();
// Description: This model is responsible for coordinating actions for processing of media overlays 
// it does the following:
// - manages MO/spine interaction
// - listens to MO events
// - invokes MO play/pause/resume functions

// Properties of this model: 
//   active_mo
//   mo_text_id


Readium.Models.MediaOverlayController = Backbone.Model.extend({

	defaults: {
		"active_mo" : null, // the currently-playing media overlay; null if nothing is being played
        "mo_text_id": null, // the current MO text fragment identifier
        "rate": 1.0, // the playback rate
        "volume": 1.0 // the volume
	},

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {

        // the current media overlay
        this.mo = null;
        
        // we track the current section to see when it changes
        this.currentSection = null; 
        
        // flags
        this.autoplayNextSpineItem = false;
        this.processingMoTextSrc = false;
        
        // media overlay playback starts here, if not null
        this.moTargetNode = null;
        
        // for mute/unmute
        this.savedVolume = 0;
        
        // readium pages object
        this.pages = null;
        // readium view
        this.currentView = null;
        // readium epub controller, set as a constructor option
		this.epubController = this.get("epubController");
		
        // trigger media overlay position updates
        this.epubController.on("change:spine_position", this.handleSpineChanged, this);   
        
        this.on("change:rate", this.rateChanged, this);
        this.on("change:volume", this.volumeChanged, this);     
	},
    
    // each time there is a new pagination view created, it must call setPages
    setPages: function(pages) {
        if (this.pages != null) {
            this.pages.off();
        }
        this.pages = pages;
    },
    
    // each time there is a new pagination view created, it must call setView
    setView: function(view) {
        this.currentView = view;
    },
    
    // main playback function
	playMo: function() {
        if (this.mo == null) {
            alert("Sorry, there is no audio for this section.");
            return;
        }
        
        this.set("active_mo", this.mo);
        this.mo.on("change:current_text_src", this.handleMoTextSrc, this);
		this.mo.on("change:is_document_done", this.handleMoDocumentDone, this);
        
        var target = this.moTargetNode;
        this.moTargetNode = null;
            
        // FXL
        if (this.currentSection.isFixedLayout()) {
            if (this.mo.get("has_started_playback")) {
                this.resumeMo();
            }
            else {
                this.mo.startPlayback(null);
            }
        }
            
        // Reflowable
        else {
            var currMoPage = -1;
            var currMoId = this.get("mo_text_id");
            if (currMoId != null && currMoId != undefined && currMoId != "") {
                currMoPage = this.currentView.getElemPageNumberById(currMoId);
            }
                
            // if media overlays is on our current page, then resume playback
            var currMoPageIsVisible = this.pages.get("current_page").indexOf(currMoPage) != -1;
                
            if (currMoPageIsVisible) {   
                this.resumeMo();
            }
            else {
                this.mo.startPlayback(target);
            }
        }
	},

    // pause the media overlay playback
	pauseMo: function() {
        if (this.mo) {
			this.mo.off();
			this.mo.pause();
			this.set("active_mo", null);             
		}
	},
    
    // toggles mute/unmute
    mute: function() {
        if (this.mo) {
            // unmute
            if (this.mo.getVolume() == 0) {
                this.set("volume", this.savedVolume);
            }
            // mute
            else {
                this.savedVolume = this.mo.getVolume();
                this.set("volume", 0);
            }
        }
    },
    
    volumeChanged: function() {
        if (this.mo) {
            this.mo.setVolume(this.get("volume"));
        }
    },
    
    rateChanged: function() {
        if (this.mo) {
            this.mo.setRate(this.get("rate"));
        }
    },
    
    // called by the reflowable view when the page changes
    reflowPageChanged: function() {
        // if MO is driving navigation, don't process the page change
        // it's probably something we triggered ourselves
        if (this.processingMoTextSrc || this.autoplayNextSpineItem ) {
            return;
        }
        
        var wasPlaying = this.get("active_mo") != null;
        if (wasPlaying) {
            this.pauseMo();
        }
        
        this.setMoTarget();
        
        // if media overlays were playing, then resume playback
        if (wasPlaying) {
            this.playMo();
        } 
    },
    
    // the pagination view calls this when it has reloaded the pages, for example when the spine item changes
    // we need to wait for this event because the pages shuffle a bit during reloading, 
    // which otherwise causes MO to start playback at the wrong point.
    pagesLoaded: function() {
        // just to be safe, ignore FXL
        if (this.currentSection.isFixedLayout()) {
            return;
        }
        if (this.autoplayNextSpineItem == true) {
            this.autoplayNextSpineItem = false;
            this.playMo();
        }
    },
    
	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" METHODS                                                                   //
	// ------------------------------------------------------------------------------------ //
    resumeMo: function() {
        this.set("mo_text_id", null); // clear it so that any listeners re-hear the event
        this.handleMoTextSrc();
        this.mo.resume();
    },
    
    handleMoTextSrc: function() {
        var textSrc = this.mo.get("current_text_src");
        if (textSrc == null) {
            this.set("mo_text_id", null);
            return;
        }
        this.processingMoTextSrc = true;
        this.epubController.goToHref(textSrc);
        var frag = "";
        if (textSrc.indexOf("#") != -1 && textSrc.indexOf("#") < textSrc.length -1) {
            frag = textSrc.substr(textSrc.indexOf("#")+1);
        }
        this.set("mo_text_id", frag);
        this.processingMoTextSrc = false;    
    },
    
    handleMoDocumentDone: function() {
        if (this.mo != null && this.mo != undefined) {
            if (this.mo.get("is_document_done") == false) {
                return;
            }
        }
        
        this.moTargetNode = null;
        this.pauseMo();
        // advance the spine position
        if (this.epubController.hasNextSection()) {
            this.autoplayNextSpineItem = true; 
            this.epubController.goToNextSection();
        }
    },
    
    handleSpineChanged: function() {
        this.set("mo_text_id", null);
        // sometimes the spine changed event fires but the spine didn't actually change
        if (this.epubController.getCurrentSection() == this.currentSection) {
            return;
        }
        // was something playing?
        if (this.get("active_mo") != null) {
            this.autoplayNextSpineItem = true; 
            this.pauseMo();
        }
        this.currentSection = this.epubController.getCurrentSection();
        this.mo = this.currentSection.getMediaOverlay();
        if (this.mo == null) {
            return;
        }
        
        // keep the volume and rate consistent
        this.mo.setVolume(this.get("volume"));
        this.mo.setRate(this.get("rate"));
        
        this.mo.reset();
        if (this.currentSection.isFixedLayout() && this.autoplayNextSpineItem) {
            this.autoplayNextSpineItem = false;
            this.playMo();
        }
    },
    
    // look at the current page and find the first visible page element that also appears in the document's MO
    setMoTarget: function() {
    	var pageElms;
    	var node;
        // using this instead of "active_mo" because this function could be called when MO is not playing
        if (this.mo == null) {
            return;
        }
        
        if (this.currentSection.isFixedLayout()) {
            // fixed layout doesn't need a target node: the top of the page is always the start of the document
            this.moTargetNode = null;
        }
        else {
        	pageElms = this.currentView.findVisiblePageElements();
            var doc_href = this.currentSection.get("href");
            
	        var node = null;
            for (var i = 0; i<pageElms.length; i++) {
	            var id = $(pageElms[i]).attr("id");
                var src = doc_href + "#" + id;
	            node = this.mo.findNodeByTextSrc(src);
	            if (node) {
	                break;
	            }
	        }
            this.moTargetNode = node;
        }
    }
});
// Description: This model provides helper methods related to Media Overlay functionality required by the fixed and reflowable views.
// Rationale: While these helpers could be included on the view objects themselves, this model was created to encapsulate view functionality
//   related to the display of media overlays for three reasons: First, the requirements for media overlays are expected to grow, which
//   would have produced larger and larger view models (by code size). Second, the primary responsibility of the pagination views is to paginate epub content
//   and provide an interface for accessing rendered content; adding MO methods to those objects would have clouded the abstraction. Third, MO
//   is the primary responsiblity of one contributor. Encapsulating MO view functionality in this model makes it easier for contributors to 
//   focus on their areas of responsibility. 

// REFACTORING CANDIDATE: The interfaces for the methods here are not particularly tight. In some cases, entire views are being 
//   passed to the methods. It would be better if the interfaces were built around something consistent; the page body being passed, 
//   etc. 
//   Interaction with the "pagination" could be improved too. It would be ideal to encorporate the concept of the "currently rendered
//   pages" into the methods here; this would use the ReadiumPagination model, which abstracts this concept. Currently, these methods
//   are working through the backbone views, but essentially using the DOM.

Readium.Models.MediaOverlayViewHelper = Backbone.Model.extend({

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	initialize: function () {

		this.epubController = this.get("epubController");
	},

    // active class comes from the package document metadata
    // authors can specify the class name they want to have applied to 
    // active MO text fragments
    addActiveClass: function(fragElm) {
        var activeClass = this.getActiveClass();
        fragElm.toggleClass(activeClass, true);
    },

    removeActiveClass: function(body) {
        if (body != null && body != undefined) {   
            var activeClass = this.getActiveClass();
            var lastFrag = $(body).find("." + activeClass);
            lastFrag.toggleClass(activeClass, false);
            return lastFrag;
        }
        return null;
    },
    
    // we're not using themes for fixed layout, so just apply the active class name to the
    // current MO fragment, so that any authored styles will be applied.
    renderFixedLayoutMoFragHighlight: function(currentPages, currentMOFrag, fixedLayoutView) {
        var that = this;

        $.each(currentPages, function(idx) {
           var body = fixedLayoutView.getPageBody(this);
           that.removeActiveClass(body);
        }); 
        
		if(currentMOFrag) {
    		$.each(currentPages, function(idx) {
                var body = fixedLayoutView.getPageBody(this);
                var newFrag = $(body).find("#" + currentMOFrag);
                if (newFrag) {
                	that.addActiveClass(newFrag);	
                } 
           });
		}
	},

	renderFixedMoPlaying: function(currentPages, MOIsPlaying, fixedLayoutView) {
        var that = this;
        // if we are using the author's style for highlighting, then just clear it if we are not playing
        if (this.authorActiveClassExists()) {
            if (!MOIsPlaying) {
        		// get rid of the last highlight
                $.each(currentPages, function(idx) {
                   var body = fixedLayoutView.getPageBody(this);
                   that.removeActiveClass(body);
                }); 
            }
        }
	},
    

    // highlight the text
	renderReflowableMoFragHighlight: function(currentTheme, reflowableView, currentMOFrag) {

		if (currentTheme === "default") {
			currentTheme = "default-theme";
		}

		// get rid of the last highlight
		var body = reflowableView.getBody();
        var lastFrag = this.removeActiveClass(body);
        
        // if the author did not define an active class themselves
        if (this.authorActiveClassExists() == false) {
            if (lastFrag) {
                $(lastFrag).css("color", "");
            }
        }
                
		if (currentMOFrag) {
            // add active class to the new MO fragment
            var newFrag = $(body).find("#" + currentMOFrag);
            if (newFrag) {
                this.addActiveClass(newFrag);
                if (this.authorActiveClassExists() == false) {
                    $(newFrag).css("color", reflowableView.themes[currentTheme]["color"]);   
                }
            }
		}
	},	

	// reflowable pagination uses default readium themes, which include a 'fade' effect on the inactive MO text
	renderReflowableMoPlaying: function(currentTheme, MOIsPlaying, reflowableView) {
		
        // if we are using the author's default style for highlighting, then just clear it if we are not playing
        if (this.authorActiveClassExists()) {
            if (!MOIsPlaying) {
        		// get rid of the last highlight
        		var body = reflowableView.getBody();
                var lastFrag = this.removeActiveClass(body);
            }
        }
        else {
    		if (currentTheme === "default") { 
    			currentTheme = "default-theme";
    		}
        
    		var body = reflowableView.getBody();
            if (MOIsPlaying) {
                // change the color of the body text so it looks inactive compared to the MO fragment that is playing
    			$(body).css("color", reflowableView.themes[currentTheme]["mo-color"]);
    		}
    		else {
                // reset the color of the text to the theme default
    			$(body).css("color", reflowableView.themes[currentTheme]["color"]);	

                // remove style info from the last MO fragment
                var lastFrag = this.removeActiveClass(reflowableView.getBody());
                if (lastFrag) {
                    $(lastFrag).css("color", "");
                }
    		}
        }
		
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

    getActiveClass: function() {
        var activeClass = this.epubController.packageDocument.get("metadata").active_class;
        if (activeClass == "") {
            // we need an active class value to use, whether the author specified it or not
            activeClass = "-readium-epub-media-overlay-active";
        }
        return activeClass;
    },
    
    // did the author supply an active-class metdata value
    authorActiveClassExists: function() {
        var activeClass = this.epubController.packageDocument.get("metadata").active_class;
        return activeClass == "" ? false : true;
    }
});
